{"version":3,"sources":["../../../src/core/field-text-check.js","../../../src/core/disabled-notices.js","../../../src/core/getApi.js","../../../src/core/utilities.js","../../../src/core/tn-links-check.js","../../../src/core/markdown-text-check.js","../../../src/core/file-text-check.js","../../../src/core/index.js","../../../../src/core/books/index.js","../../../src/core/annotation-row-check.js","../../../src/core/ta-reference-check.js","../../../src/core/orig-quote-check.js","../../../src/core/plain-text-check.js","../../../src/core/yaml-text-check.js","../../../src/core/tn-table-row-check.js","../node_modules/jspdf/dist sync","../../../src/core/annotation-table-check.js","../../../src/core/markdown-file-contents-check.js","../../../src/core/manifest-text-check.js","../../../src/core/tn-table-text-check.js","../../../src/core/usfm-text-check.js","../../../src/core/usfm-js-check.js","../../../src/core/BCS-usfm-grammar-check.js","../../../src/core/text-handling-functions.js","fonts/SILEOTSR.ttf","core/books.ts","core/getApi.js","core/book-package-check.js","core/utilities.ts","ValidationNotices.js","BookPackageContentValidator.js","RepoValidation.js","App.tsx","serviceWorker.ts","index.tsx","../../../../src/core/books/books.js","../../src/index.js"],"names":["fieldType","fieldName","fieldText","allowedLinks","optionalFieldLocation","checkingOptions","console","JSON","result","noticeList","noticeObject","ourLocation","extractLength","btcError","isNaN","DEFAULT_EXTRACT_LENGTH","halfLength","Math","halfLengthPlus","suggestion","characterIndex","extract","addNoticePartial","priority","message","location","isWhitespace","iy","fieldTextLower","notice","doubleCount","countOccurrences","details","doubledPunctuationCheckList","punctChar","afterSpaceCheckList","beforeSpaceCheckList","beforeEOLCheckList","BAD_CHARACTER_COMBINATIONS","badCharCombination","MATCHED_PUNCTUATION_PAIRS","punctSet","leftChar","rightChar","indexOf","leftCount","rightCount","thisPriority","leftRegex","RegExp","rightRegex","regexResultArray","thisMessage","givenNoticeList","remainingNoticeList","thisNotice","isDisabledNotice","disabledNotices","repoCode","bookID","filename","lineNumber","givenNotice","disabledNotice","matched","baseURL","failedStore","localforage","driver","name","zipStore","cacheStore","unzipStore","Door43Api","setup","cache","store","maxAge","exclude","query","key","req","serialized","formRepoName","languageCode","repo_languageCode","repoName","getUnZippedFile","path","contents","cachedGetFile","username","repository","branch","filePath","Path","getFileFromZip","cachedFetchFileFromServer","cachedGetManifest","manifestContents","formData","yaml","yamlError","manifestJSON","projectEntry","bookPath","success","repos_","bookIDList","Array","whichTestament","books","origLangRepo","adjustedLanguageCode","adjustedBranch","adjustedRepoCode","cachedGetRepositoryZipFile","zipFetchSucceeded","uri","cachedGetFileUsingPartialURL","data","getUID","user","uid","params","q","limit","retrievedRepoListData","retrievedRepoList","desiredMatch","filteredRepoList","repo","response","getZipFromStore","downloadRepositoryZipFile","zipUri","fetch","zipArrayBuffer","optionalPrefix","zipBlob","pathList","JSZip","zip","relativePath","zipPath","file","clTitle","clObject","clOutput","thisPropertyContents","oType","Object","oLength","olError","givenTitle","givenObject","output","givenString","int","GENERAL_LINK1_REGEX","GENERAL_LINK2_REGEX","TA_REGEX","TW_REGEX","OTHER_BOOK_BIBLE_REGEX","THIS_BOOK_BIBLE_REGEX","THIS_CHAPTER_BIBLE_REGEX","checkedArticleStore","markAsChecked","dummyPath","alreadyChecked","ctarResult","givenC","givenV","givenLocation","checkedFileCount","checkedFilenames","checkedRepoNames","trcELerror","getFile_","defaultLanguageCode","trcLCerror","taRepoUsername","trcUNerror","taRepoBranch","trcBRerror","twRepoUsername","twRepoBranch","linksList1","linksList2","totalLinks1","totalLinks2","taLinkCount","twLinkCount","thisChapterBibleLinkCount","thisBookBibleLinkCount","otherBookBibleLinkCount","taRepoName","filepath","taPathParameters","taFileContent","checkMarkdownText","checkTAFileResult","extra","twRepoName","twPathParameters","twFileContent","checkTWFileResult","totalLink","optionalN1","optionalB1","C1","V1","V2","checkResult","linkBookCode","chapterInt","ourParseInt","verseInt","ccError","vvError","numChaptersThisBook","numVersesThisChapter","tlcNCerror","tlcNVerror","B2","C2","BibleLinkCount","twaLinkCount","middleCount","IMAGE_REGEX","fetchLink","addNotice","cachedGetFileUsingFullURL","responseData","thisText","lineText","ourCheckTextField","textOrFileName","lineLocation","checkMarkdownLineContents","dbtcResultObject","checkTextField","noticeEntry","addSuccessMessage","markdownText","mdtcError","successList","lines","headerLevel","lastNumLeadingSpaces","suggestedLines","n","line","numLeadingSpaces","thisHeaderLevel","suggestedLine","removeDisabledNotices","fileType","fileText","optionalFileLocation","plainText","checkPlainText","ourCheckPlainText","LC_ALPHABET_PLUS_DIGITS","rowID","taLinkText","checkTNLinksToOutside","coqResultObject","coqNoticeEntry","drResult","checkedRepoName","checkedFilenameExtension","ourCheckTNLinksToOutside","occurrence","rowLocation","checkOriginalLanguageQuote","ourCheckTNOriginalLanguageQuote","checkSupportReferenceInTA","taRepoLanguageCode","expectFullLink","ourCheckSupportReferenceInTA","octfResultObject","omtcResultObject","ourMarkdownTextChecks","C","V","givenRowLocation","ourRowLocation","linkCheckingOptions","tlcELerror","lowercaseBookID","haveGoodBookID","fields","reference","tags","supportReference","quote","annotation","test","intC","Number","haveGoodChapterNumber","intV","RIDSuggestion","LC_ALPHABET","characterIndeX","LC_ALPHABET_PLUS_DIGITS_PLUS_HYPHEN","annotationType","supportReferenceArticlePart","SRSuggestion","QSuggestion","OSuggestion","ASuggestion","adjustedLink","taRepoSectionName","trcSNerror","qcoError","qcunError","verseText","OBSRepoName","adjC","adjV","OBSPathname","originalMarkdown","gotIt","searchString","bookNumberAndName","originalLanguageRepoCode","originalLanguageRepoName","originalUSFM","foundChapter","foundVerse","bookLine","ixW","ixEnd","field","bits","adjusted_field","getOriginalPassage","colqResult","occurrenceString","gcELerror","quoteBits","gcVTerror","numQuoteBits","bitIndex","partDescription","remainingBits","noBreakSpaceText","textType","textName","ptcError","cptResult","openMarkers","checkPlainLineContents","char","closeCharacterIndex","PAIRED_PUNCTUATION_OPENERS","x","PAIRED_PUNCTUATION_CLOSERS","lastEntry","YAMLText","ytcError","cytResult","allowedLinksInLine","checkYAMLLineContents","checkTextfileContents","ourBasicFileChecks","EXPECTED_TN_HEADING_LINE","B","origQuote","GLQuote","occurrenceNote","OQSuggestion","GLQSuggestion","ONSuggestion","webpackEmptyContext","e","Error","code","keys","resolve","module","exports","id","carResult","ttcError","tableText","lastC","lastV","rowIDList","uniqueRowList","checkAnnotationTSVDataRow","drResultObject","drNoticeEntry","uniqueID","lastintC","lastintV","markdownFilename","ourCheckMarkdownText","ourFileTextCheck","validate","Ajv","ajv","ourYAMLTextChecks","manifestText","cYtResultObject","checkYAMLText","cmtResult","repoBranch","mfcError","formDataKeys","errorObject","projectKeys","keyName","projectFilepath","isBookFolder","BibleBookData","thisBookID","projectFileContent","ttResult","lastB","checkTN_TSVDataRow","givenText","usfmELerror","validLineStartCharacters","fieldLocation","opener","closer","lCount","rCount","checkUSFMCharacterFields","fileLocation","compulsoryMarker","markerSet","expectedMarker","deprecatedMarker","ALLOWED_LINE_START_MARKERS","marker","rest","MARKERS_WITHOUT_CONTENT","MARKERS_WITH_COMPULSORY_CONTENT","Vstr","adjustedRest","charMarker","ourDeleteAll","ixWordEnd","startIndex","nextZIndex","ixZEnd","nextWIndex","ixWEnd","nextFIndex","ixFEnd","checkUSFMLineText","checkUSFMLineInternals","allResults","USFMline","foundMarker","lastIntC","lastIntV","lastMarker","lastRest","findStartMarker","vIndex","usfmICerror","usfmIVerror","firstV","secondV","intFirstV","intSecondV","usfmV12error","restRest","parseInt","usfmIIVerror","thisLength","PARAGRAPH_MARKERS","checkUSFMLineContents","checkUSFMFileContents","mainUSFMCheck","gotDeep","someObject","someSubobject","someSub2object","someSub3object","someSub4object","someSub5object","someSub6object","someSub7object","someSub8object","someSub9object","someSub10object","someSub11object","expectedVersesPerChapterList","result1","runUsfmJsCheck","usfmCIerror","discoveredVerseList","discoveredVerseWithTextList","verseNumberString","verseHasText","hasText","firstVString","secondVString","v","usfmVIerror","usfmPIerror","CVCheck","grammarCheckResult","runBCSGrammarCheck","warningString","relaxedGrammarCheckResult","ourRunBCSGrammarCheck","COMPULSORY_MARKERS","EXPECTED_MARKERS","EXPECTED_BIBLE_BOOK_MARKERS","EXPECTED_PERIPHERAL_BOOK_MARKERS","INTRO_LINE_START_MARKERS","CV_MARKERS","HEADING_TYPE_MARKERS","NOTE_MARKERS","SPECIAL_MARKERS","MILESTONE_MARKERS","concat","DEPRECATED_MARKERS","SIMPLE_CHARACTER_MARKERS","CHARACTER_MARKERS","SIMPLE_INTERNAL_MARKERS","MATCHED_CHARACTER_FORMATTING_PAIRS","addNotice6to7","convertOptions","jsonResult","toJSON","isValidUSFM","returnedJSON","strictnessString","cugResult","ourUsfmParser","grammar","parserResult","ourErrorObject","parseError","contextRE","errorLine","regexResult","lineNumberString","ourErrorMessage","adjustedPriority","ourWarnings","adjustedString","error","warnings","myString","mainString","subString","allowOverlapping","pos","step","findString","replaceString","resultString","bookData","bookId","filter","row","testament","toLowerCase","newTestament","list","i","length","push","title","oldTestament","titlesToBoolean","ob","bookDataTitles","forEach","k","bookIdByTitle","bookTitleById","extraBookList","isOptionalValidBookID","isValidBookID","_id","__id","toUpperCase","usfmNumberNameById","usfm","repoDefaultMap","hbo","UHB","UGNT","en","label","TA","TN","TW","TQ","ST","LT","hi","kn","ru","repoMap","getRepoMap","_","cloneDeep","verifyRepo","errors","repoType","language","a","log","verifyManifest","repoExists","manifestValid","manifestFound","manifestParseFailed","repoFound","getFileCached","projects","join","cachedGet","subject","status","verifyRepos","repoTypes","promises","startTime","Date","findPathForRepo","orgName","split","Promise","all","elapsedSeconds","verifyReposForLanguages","results","finished","langID","langResults","then","findSettingsForLanguage","includes","langRepos","repoType_","getOverridesForRepo","divider","substr","createInstance","INDEXEDDB","URLSearchParams","toString","stringify","url","getItem","username_","fetchFileFromServer","setItem","parse","cachedGetBookFilenameFromManifest","identifier","startsWith","substring","clearCaches","clear","addIfMissing","repos","newRepo","addToStart","unshift","PreLoadRepos","loadOriginalLangs","loadUltAndUst","map","origLangBibles","fetchRepositoryZipFile","get","forceLoad","arrayBuffer","getFileListFromZip","loadAsync","endsWith","fileData","async","encodeURI","checkRepo","setResultValue","ourCheckRepoFileContents","bookOrFileCode","cfBookID","file_content","optionalCheckingOptions","assert","undefined","checkFileContents","cfcResultObject","cfcNoticeEntry","checkRepoResult","successString","checkedFilenameExtensions","style","color","fetchRepositoryZipFile_","getFileListFromZip_","countString","toLocaleString","Set","totalCheckedSize","thisFilepath","thisFilename","pop","thisFilenameExtension","ourBookID","getFile","repoFileContent","replace","add","checkedFilesizes","fileContent","ourCFLocation","filenameMain","checkTN_TSVText","checkFileResult","checkUSFMText","checkManifestText","checkedFilename","checkedFilesize","checkedOptions","checkTQbook","ourCheckTQFileContents","cfFilename","cfResultObject","ctqResult","generalLocation","bookIdLc","isArray","thisPath","pathParts","slice","tqFileContent","checkBookPackage","ourCheckBPFileContents","checkBookPackageResult","newCheckingOptions","originalLanguageRepoUsername","origLang","repoCodeList","checkRepos","orgRepo","orgname","repoLocation","tsvFileName","tqResultObject","padRef2","stringToNumber","value","num","NaN","somewhatNumericalSort","b","aNum","bNum","aStr","bStr","notices_to_mt","renderLink","renderWithUnicodeLink","renderPriority","rawData","mt","columns","render","rowData","customSort","sortChapterVerse","link","cellStyle","fontFamily","excerpt","width","_location","_link","lineNum","fileName","extension","view","repoTypeUC","repoName_","getLink","charPos","sort","rows","newColumns","column","hasData","trimColumns","options","sorting","exportButton","exportAllData","columnsButton","filtering","pageSize","tableIcons","Add","forwardRef","props","ref","Check","Clear","Delete","DetailPanel","Edit","Export","Filter","FirstPage","LastPage","NextPage","PreviousPage","ResetSearch","Search","SortArrow","ThirdStateCheck","ViewColumn","content","fontWeight","href","target","rel","match","getUnicodeRegEx","lastPos","exec","index","matchLen","unicode","withStyles","theme","root","util","Paper","icons","BookPackageContentValidator","language_code","useState","useEffect","renderSummary","rawCBPResults","Typography","checkType","ValidationNotices","RepoValidation","React","setData","repoVisual","editable","hidden","cellEditable","onCellEditApproved","newValue","oldValue","columnDef","reject","_data","org","getApi","lang","setTimeout","propTypes","PropTypes","array","isRequired","languagesValidationResults","doLanguageInitialization","useStyles","makeStyles","createStyles","flexGrow","display","menuButton","marginRight","spacing","appBar","transition","transitions","create","easing","sharp","duration","leavingScreen","appBarShift","marginLeft","easeOut","enteringScreen","formControl","margin","button","instructions","marginTop","marginBottom","hide","drawer","flexShrink","drawerPaper","drawerHeader","alignItems","padding","mixins","toolbar","justifyContent","contentShift","alignItemsAndJustifyContent","offset","queryProcessedOnce","App","state","setState","activeStep","setActiveStep","skipped","setSkipped","setOrg","setLang","CircularProgress","repoValidation","setRepoValidation","steps","isStepSkipped","has","handleNext","newSkipped","values","delete","prevActiveStep","search","window","useQuery","doInitialization","bks","barrayIds","barrayTitles","alert","classes","useTheme","open","setOpen","handleChange","event","checked","className","CssBaseline","AppBar","position","clsx","Toolbar","IconButton","aria-label","onClick","edge","variant","Drawer","anchor","paper","direction","Divider","Stepper","stepProps","labelProps","completed","Step","StepLabel","Container","getStepContent","Button","disabled","FormControl","component","FormLabel","RadioGroup","onChange","val","FormControlLabel","control","Radio","Grid","container","item","xs","states","required","FormGroup","t","Checkbox","FormHelperText","y","joinBookIds","Boolean","hostname","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister","givenBookName","partialMatches","givenBookNameLower","thisBookName","thisBookNameLower","oftenMissingBCVList","entry","chaptersInBook","chapters","err","chapter","verses"],"mappings":"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","file":"static/js/main.fed77f85.chunk.js","sourcesContent":["import { DEFAULT_EXTRACT_LENGTH, MATCHED_PUNCTUATION_PAIRS, BAD_CHARACTER_COMBINATIONS, isWhitespace, countOccurrences } from './text-handling-functions'\r\n\r\n\r\n// const FIELD_TEXT_VALIDATOR_VERSION_STRING = '0.3.3';\r\n\r\n\r\n/**\r\n * @description -- Does basic checks for small errors like leading/trailing spaces, etc.\r\n * @param {string} fieldType -- classification, e.g., TSV, USFM, YAML, link, markdown, raw\r\n * @param {string} fieldName -- used for identification\r\n * @param {string} fieldText -- the field being checked\r\n * @param {boolean} allowedLinks -- doesnt check links -- only checks lack of links\r\n * @param {string} optionalFieldLocation -- used to inform where this field is located\r\n * @param {Object} checkingOptions\r\n */\r\nexport function checkTextField(fieldType, fieldName, fieldText, allowedLinks, optionalFieldLocation, checkingOptions) {\r\n    // We assume that checking for compulsory fields is done elsewhere\r\n\r\n    // Returns a single notice list\r\n    //  The list contains objects with the following fields:\r\n    //      priority (compulsory): the priority number 0..999 (usually 800+ are errors, lower are warnings)\r\n    //      message (compulsory): the error description string\r\n    //      characterIndeX: the 0-based index for the position in the string\r\n    //      extract: a short extract of the string containing the error (or empty-string if irrelevant)\r\n    //      location: the detailed location string\r\n    //  (Returned in this way for more intelligent processing at a higher level)\r\n    // console.log(`checkTextField(${fieldName}, ${fieldText.length.toLocaleString()} chars, ${allowedLinks}, '${optionalFieldLocation}')`);\r\n    console.assert(fieldType !== undefined, \"checkTextField: 'fieldType' parameter should be defined\");\r\n    console.assert(typeof fieldType === 'string', `checkTextField: 'fieldType' parameter should be a string not a '${typeof fieldType}': ${fieldType}`);\r\n    console.assert(fieldType !== '', `checkTextField: 'fieldType' ${fieldType} parameter should be not be an empty string`);\r\n    console.assert(fieldType === 'markdown' || fieldType === 'USFM' || fieldType === 'YAML' || fieldType === 'text' || fieldType === 'raw' || fieldType === 'link', `checkTextField: unrecognised 'fieldType' parameter: '${fieldType}'`);\r\n    console.assert(fieldName !== undefined, \"checkTextField: 'fieldName' parameter should be defined\");\r\n    console.assert(typeof fieldName === 'string', `checkTextField: 'fieldName' parameter should be a string not a '${typeof fieldName}': ${fieldName}`);\r\n    // if (fieldType !== 'markdown')\r\n    //     console.assert(fieldName !== '', `checkTextField: ${fieldType} 'fieldName' parameter should be not be an empty string`);\r\n    console.assert(fieldText !== undefined, \"checkTextField: 'fieldText' parameter should be defined\");\r\n    console.assert(typeof fieldText === 'string', `checkTextField: 'fieldText' parameter should be a string not a '${typeof fieldText}': ${fieldText}`);\r\n    console.assert(allowedLinks === true || allowedLinks === false, \"checkTextField: allowedLinks parameter must be either true or false\");\r\n    if (!allowedLinks) console.assert(fieldText.indexOf('x-tw') < 0, `checkTextField should be allowedLinks for ${fieldType} ${fieldName} ${fieldText}`)\r\n    console.assert(optionalFieldLocation !== undefined, \"checkTextField: 'optionalFieldLocation' parameter should be defined\");\r\n    console.assert(typeof optionalFieldLocation === 'string', `checkTextField: 'optionalFieldLocation' parameter should be a string not a '${typeof optionalFieldLocation}': ${optionalFieldLocation}`);\r\n    console.assert(optionalFieldLocation.indexOf('true') === -1, `checkTextField: 'optionalFieldLocation' parameter should not be '${optionalFieldLocation}'`);\r\n    if (checkingOptions !== undefined)\r\n        console.assert(typeof checkingOptions === 'object', `checkTextField: 'checkingOptions' parameter should be an object not a '${typeof checkingOptions}': ${JSON.stringify(checkingOptions)}`);\r\n\r\n    let result = { noticeList: [] };\r\n\r\n    function addNoticePartial(noticeObject) {\r\n        // We add the fieldName here\r\n        // console.log(`dBTC Notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : \"\"}${extract ? ` ${extract}` : \"\"}${location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"dBTCs addNoticePartial: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `dBTCs addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"dBTCs addNoticePartial: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `dBTCs addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(characterIndex !== undefined, \"dBTCs addNoticePartial: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `dBTCs addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract !== undefined, \"dBTCs addNoticePartial: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `dBTCs addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"dBTCs addNoticePartial: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `dBTCs addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n\r\n        // noticeObject.debugChain = noticeObject.debugChain ? `checkTextField(${fieldType}, ${fieldName}, ${allowedLinks}) ${noticeObject.debugChain}` : `checkTextField(${fieldType}, ${fieldName}, ${allowedLinks})`;\r\n        if (fieldName.length) noticeObject.fieldName = fieldName; // Dont add the field if its blank\r\n        result.noticeList.push(noticeObject);\r\n    }\r\n\r\n\r\n    // Main code for checkTextField()\r\n    if (!fieldText) // Nothing to check\r\n        return result;\r\n\r\n    // Create our more detailed location string by prepending the fieldName\r\n    let ourLocation = optionalFieldLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (btcError) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n    // console.log(`Using supplied extractLength=${extractLength}`, `cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n    let suggestion = fieldText.trim();\r\n\r\n    let characterIndex;\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 895)\r\n        && (characterIndex = fieldText.indexOf('\\u200B')) >= 0) {\r\n        const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/\\u200B/g, '') + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n        addNoticePartial({ priority: 895, message: \"Field contains zero-width space(s)\", characterIndex, extract, location: ourLocation });\r\n        suggestion = suggestion.replace(/\\u200B/g, ''); // Or should it be space ???\r\n    }\r\n\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 638)\r\n        && isWhitespace(fieldText)) {\r\n        addNoticePartial({ priority: 638, message: \"Only found whitespace\", location: ourLocation });\r\n        return result;\r\n    }\r\n\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 993)\r\n        && (characterIndex = fieldText.indexOf('<<<<<<<')) >= 0) {\r\n        const iy = characterIndex + halfLength; // Want extract to focus more on what follows\r\n        const extract = (iy > halfLength ? '' : '') + fieldText.substring(iy - halfLength, iy + halfLengthPlus).replace(/ /g, '') + (iy + halfLengthPlus < fieldText.length ? '' : '')\r\n\r\n        addNoticePartial({ priority: 993, message: \"Unresolved GIT conflict\", characterIndex, extract, location: ourLocation });\r\n    } else {\r\n        if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 992)\r\n            && (characterIndex = fieldText.indexOf('=======')) >= 0) {\r\n            const iy = characterIndex + halfLength; // Want extract to focus more on what follows\r\n            const extract = (iy > halfLength ? '' : '') + fieldText.substring(iy - halfLength, iy + halfLengthPlus).replace(/ /g, '') + (iy + halfLengthPlus < fieldText.length ? '' : '')\r\n            addNoticePartial({ priority: 992, message: \"Unresolved GIT conflict\", characterIndex, extract, location: ourLocation });\r\n        } else {\r\n            if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 991)\r\n                && (characterIndex = fieldText.indexOf('>>>>>>>>')) >= 0) {\r\n                const iy = characterIndex + halfLength; // Want extract to focus more on what follows\r\n                const extract = (iy > halfLength ? '' : '') + fieldText.substring(iy - halfLength, iy + halfLengthPlus).replace(/ /g, '') + (iy + halfLengthPlus < fieldText.length ? '' : '')\r\n                addNoticePartial({ priority: 991, message: \"Unresolved GIT conflict\", characterIndex, extract, location: ourLocation });\r\n            }\r\n        }\r\n    }\r\n\r\n    if (fieldText[0] === ' ') {\r\n        const extract = fieldText.substring(0, extractLength).replace(/ /g, '') + (fieldText.length > extractLength ? '' : '');\r\n        if (fieldText[1] === ' ') // spaces plural\r\n            addNoticePartial({ priority: 110, message: `Unexpected leading spaces`, characterIndex: 0, extract, location: ourLocation });\r\n        else\r\n            addNoticePartial({ priority: 109, message: `Unexpected leading space`, characterIndex: 0, extract, location: ourLocation });\r\n    } else if (fieldText[0] === '\\u2060') {\r\n        const extract = fieldText.substring(0, extractLength).replace(/\\u2060/g, '') + (fieldText.length > extractLength ? '' : '');\r\n        addNoticePartial({ priority: 770, message: `Unexpected leading word-joiner`, characterIndex: 0, extract, location: ourLocation });\r\n        if (suggestion[0] === '\\u2060') suggestion = suggestion.substring(1);\r\n    } else if (fieldText[0] === '\\u200D') {\r\n        const extract = fieldText.substring(0, extractLength).replace(/\\u200D/g, '') + (fieldText.length > extractLength ? '' : '');\r\n        addNoticePartial({ priority: 771, message: `Unexpected leading zero-width joiner`, characterIndex: 0, extract, location: ourLocation });\r\n        if (suggestion[0] === '\\u200D') suggestion = suggestion.substring(1);\r\n    }\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 64)\r\n        && (characterIndex = fieldText.indexOf('<br> ')) >= 0) {\r\n        const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/ /g, '') + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n        addNoticePartial({ priority: 64, message: \"Unexpected leading space(s) after break\", characterIndex, extract, location: ourLocation });\r\n    }\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 63)\r\n        && (characterIndex = fieldText.indexOf('\\\\n ')) >= 0) {\r\n        const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/ /g, '') + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n        addNoticePartial({ priority: 63, message: \"Unexpected leading space(s) after line break\", characterIndex, extract, location: ourLocation });\r\n    }\r\n\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 772)\r\n        && fieldText[fieldText.length - 1] === '\\u2060') {\r\n        const extract = fieldText.substring(0, extractLength).replace(/\\u2060/g, '') + (fieldText.length > extractLength ? '' : '');\r\n        addNoticePartial({ priority: 772, message: `Unexpected trailing word-joiner`, characterIndex: 0, extract, location: ourLocation });\r\n        if (suggestion[suggestion.length - 1] === '\\u2060') suggestion = suggestion.substring(0, suggestion.length - 1);\r\n    } else if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 773)\r\n        && fieldText[fieldText.length - 1] === '\\u200D') {\r\n        const extract = fieldText.substring(0, extractLength).replace(/\\u200D/g, '') + (fieldText.length > extractLength ? '' : '');\r\n        addNoticePartial({ priority: 773, message: `Unexpected trailing zero-width joiner`, characterIndex: 0, extract, location: ourLocation });\r\n        if (suggestion[suggestion.length - 1] === '\\u200D') suggestion = suggestion.substring(0, suggestion.length - 1);\r\n    }\r\n\r\n    // Find leading line breaks (but not if the whole line is just the line break sequence)\r\n    const fieldTextLower = fieldText.toLowerCase();\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 107)\r\n        && (fieldTextLower.substring(0, 2) === '\\\\n' || fieldTextLower.substring(0, 4) === '<br>' || fieldTextLower.substring(0, 5) === '<br/>' || fieldTextLower.substring(0, 6) === '<br />')\r\n        && fieldTextLower !== '\\\\n' && fieldTextLower !== '<br>' && fieldTextLower !== '<br/>' && fieldTextLower !== '<br />') {\r\n        const extract = fieldText.substring(0, extractLength) + (fieldText.length > extractLength ? '' : '');\r\n        addNoticePartial({ priority: 107, message: \"Unexpected leading line break\", characterIndex: 0, extract, location: ourLocation });\r\n        while (suggestion.toLowerCase().substring(0, 2) === '\\\\n') suggestion = suggestion.substring(2);\r\n        while (suggestion.toLowerCase().substring(0, 4) === '<br>') suggestion = suggestion.substring(4);\r\n        while (suggestion.toLowerCase().substring(0, 5) === '<br/>') suggestion = suggestion.substring(5);\r\n        while (suggestion.toLowerCase().substring(0, 6) === '<br />') suggestion = suggestion.substring(6);\r\n    }\r\n\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 95)\r\n        && fieldText[fieldText.length - 1] === ' ')\r\n        // Markdown gives meaning to two spaces at the end of a line\r\n        if (fieldType !== 'markdown' || fieldText.length < 3 || fieldText[fieldText.length - 2] !== ' ' || fieldText[fieldText.length - 3] === ' ') {\r\n            const extract = (fieldText.length > extractLength ? '' : '') + fieldText.substring(fieldText.length - 10).replace(/ /g, '');\r\n            const notice = { priority: 95, message: \"Unexpected trailing space(s)\", extract, location: ourLocation };\r\n            if ((fieldType !== 'raw' && fieldType !== 'text') || fieldName.substring(0, 6) !== 'from \\\\')\r\n                notice.characterIndex = fieldText.length - 1; // characterIndex means nothing for processed USFM\r\n            addNoticePartial(notice);\r\n        }\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 94)\r\n        && (characterIndex = fieldText.indexOf(' <br')) >= 0) {\r\n        const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/ /g, '') + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n        addNoticePartial({ priority: 94, message: \"Unexpected trailing space(s) before break\", characterIndex, extract, location: ourLocation });\r\n    }\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 93)\r\n        && (characterIndex = fieldText.indexOf(' \\\\n')) >= 0) {\r\n        const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/ /g, '') + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n        addNoticePartial({ priority: 93, message: \"Unexpected trailing space(s) before line break\", characterIndex, extract, location: ourLocation });\r\n    }\r\n\r\n    // Find trailing line breaks (but not if the whole line is just the line break sequence)\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 104)\r\n        && (fieldTextLower.substring(fieldTextLower.length - 2) === '\\\\n' || fieldTextLower.substring(fieldTextLower.length - 4) === '<br>' || fieldTextLower.substring(fieldTextLower.length - 5) === '<br/>' || fieldTextLower.substring(fieldTextLower.length - 6) === '<br />')\r\n        && fieldTextLower !== '\\\\n' && fieldTextLower !== '<br>' && fieldTextLower !== '<br/>' && fieldTextLower !== '<br />') {\r\n        const extract = (fieldText.length > extractLength ? '' : '') + fieldText.substring(fieldText.length - 10);\r\n        addNoticePartial({ priority: 104, message: \"Unexpected trailing line break\", characterIndex: fieldText.length - 1, extract, location: ourLocation });\r\n        while (suggestion.toLowerCase().substring(suggestion.length - 2) === '\\\\n') suggestion = suggestion.substring(0, suggestion.length - 2);\r\n        while (suggestion.toLowerCase().substring(suggestion.length - 4) === '<br>') suggestion = suggestion.substring(0, suggestion.length - 4);\r\n        while (suggestion.toLowerCase().substring(suggestion.length - 5) === '<br/>') suggestion = suggestion.substring(0, suggestion.length - 5);\r\n        while (suggestion.toLowerCase().substring(suggestion.length - 6) === '<br />') suggestion = suggestion.substring(0, suggestion.length - 6);\r\n    }\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 124)\r\n        && (characterIndex = fieldText.indexOf('  ')) >= 0\r\n        && (fieldType !== 'markdown' || characterIndex !== fieldText.length - 2)) {\r\n        const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/ /g, '') + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n        const doubleCount = countOccurrences(fieldText, '  ');\r\n        let notice;\r\n        if (doubleCount === 1)\r\n            notice = { priority: 124, message: \"Unexpected double spaces\", extract, location: ourLocation };\r\n        else\r\n            notice = { priority: 224, message: \"Multiple unexpected double spaces\", details: `${doubleCount} occurrencesonly first is displayed`, extract, location: ourLocation };\r\n        if ((fieldType !== 'raw' && fieldType !== 'text') || fieldName.substring(0, 6) !== 'from \\\\')\r\n            notice.characterIndex = characterIndex; // characterIndex means nothing for processed USFM\r\n        if (!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < notice.priority)\r\n            addNoticePartial(notice);\r\n        // Note: replacing double-spaces in the suggestion is done later -- after other suggestion modifications which might affect it\r\n    }\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 583)\r\n        && (characterIndex = fieldText.indexOf('\\n')) >= 0) {\r\n        const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n        addNoticePartial({ priority: 583, message: \"Unexpected newLine character\", characterIndex, extract, location: ourLocation });\r\n        suggestion = suggestion.replace(/\\n/g, ' ');\r\n    }\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 582)\r\n        && (characterIndex = fieldText.indexOf('\\r')) >= 0) {\r\n        const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n        addNoticePartial({ priority: 582, message: \"Unexpected carriageReturn character\", characterIndex, extract, location: ourLocation });\r\n        suggestion = suggestion.replace(/\\r/g, ' ');\r\n    }\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 581)\r\n        && (characterIndex = fieldText.indexOf('\\xA0')) >= 0) { // non-break space\r\n        const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/\\xA0/g, '') + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n        addNoticePartial({ priority: 581, message: \"Unexpected non-break space character\", characterIndex, extract, location: ourLocation });\r\n        suggestion = suggestion.replace(/\\xA0/g, ' ');\r\n    }\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 580)\r\n        && (characterIndex = fieldText.indexOf('\\u202F')) >= 0) { // narrow non-break space\r\n        const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/\\u202F/g, '') + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n        const notice = { priority: 580, message: \"Unexpected narrow non-break space character\", extract, location: ourLocation };\r\n        if ((fieldType !== 'raw' && fieldType !== 'text') || fieldName.substring(0, 6) !== 'from \\\\')\r\n            notice.characterIndex = characterIndex; // characterIndex means nothing for processed USFM\r\n        addNoticePartial(notice);\r\n        suggestion = suggestion.replace(/\\u202F/g, ' ');\r\n    }\r\n    if (fieldName === 'OrigQuote' || fieldName === 'Quote') {\r\n        if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 179)\r\n            && (characterIndex = fieldText.indexOf(' ')) >= 0) {\r\n            const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n            addNoticePartial({ priority: 179, message: \"Unexpected space before ellipse character\", characterIndex, extract, location: ourLocation });\r\n            suggestion = suggestion.replace(/ /g, '');\r\n        }\r\n        if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 178)\r\n            && (characterIndex = fieldText.indexOf(' ')) >= 0) {\r\n            const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n            addNoticePartial({ priority: 178, message: \"Unexpected space after ellipse character\", characterIndex, extract, location: ourLocation });\r\n            suggestion = suggestion.replace(/ /g, '');\r\n        }\r\n    }\r\n    suggestion = suggestion.replace(/ {2}/g, ' ');\r\n\r\n    if (!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 177) {\r\n        // Check for doubled punctuation chars (international)\r\n        // Doesnt check for doubled forward slash by default coz that might occur in a link, e.g., https://etc\r\n        //  or doubled # coz that occurs in markdown\r\n        let doubledPunctuationCheckList = '({}<>:!?\\';&@^%+=|$';\r\n        if (!allowedLinks) doubledPunctuationCheckList += '/[].)'; // Double square brackets can be part of markdown links, double periods can be part of a path\r\n        if (fieldType !== 'markdown') doubledPunctuationCheckList += '_*#~'; // There are used for markdown formatting\r\n        if (fieldType !== 'USFM' || fieldText.indexOf('x-morph') < 0) doubledPunctuationCheckList += ',\"'; // Allowed in original language morphology fields\r\n        if (fieldType !== 'YAML' || !fieldText.startsWith('--')) // NOTE: First hyphen may have been removed in preprocessing\r\n            doubledPunctuationCheckList += '-';\r\n        for (const punctChar of doubledPunctuationCheckList) {\r\n            if ((characterIndex = fieldText.indexOf(punctChar + punctChar)) >= 0) {\r\n                let extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n                const notice = { priority: 177, message: `Unexpected doubled ${punctChar} characters`, extract, location: ourLocation };\r\n                if ((fieldType !== 'raw' && fieldType !== 'text') || fieldName.substring(0, 6) !== 'from \\\\')\r\n                    notice.characterIndex = characterIndex; // characterIndex means nothing for processed USFM\r\n                addNoticePartial(notice);\r\n            }\r\n        }\r\n    }\r\n    if (!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 195) {\r\n        // Check for punctuation chars following space and at start of line\r\n        //  Removed $\r\n        let afterSpaceCheckList = ')}>:,!.-?;/@^#%';\r\n        if (fieldType !== 'markdown') afterSpaceCheckList += '_*~'; // These are used for markdown formatting\r\n        if (fieldType !== 'USFM' || (fieldText.indexOf('x-lemma') < 0 && fieldText.indexOf('x-tw') < 0)) afterSpaceCheckList += '|';\r\n        if (fieldType !== 'YAML') afterSpaceCheckList += '\\'\"'; // These are used for YAML strings, e.g., version: '0.15'\r\n        // if (fieldName === 'OrigQuote' || fieldName === 'Quote') afterSpaceCheckList += ''; // NOT NEEDED -- this is specifically checked elsewhere\r\n        for (const punctChar of afterSpaceCheckList) {\r\n            if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 191)\r\n                && (characterIndex = fieldText.indexOf(' ' + punctChar)) >= 0) {\r\n                let extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n                const notice = { priority: 191, message: `Unexpected ${punctChar} character after space`, extract, location: ourLocation };\r\n                if ((fieldType !== 'raw' && fieldType !== 'text') || fieldName.substring(0, 6) !== 'from \\\\')\r\n                    notice.characterIndex = characterIndex; // characterIndex means nothing for processed USFM\r\n                addNoticePartial(notice);\r\n            }\r\n            if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 195)\r\n                && (punctChar !== '-' || fieldType !== 'YAML')\r\n                && (punctChar !== '!' || fieldType !== 'markdown') // image tag\r\n                && fieldText[0] === punctChar) {\r\n                characterIndex = 0;\r\n                let extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n                addNoticePartial({ priority: 195, message: `Unexpected ${punctChar} character at start of line`, characterIndex, extract, location: ourLocation });\r\n            }\r\n        }\r\n        if (fieldType === 'USFM')\r\n            suggestion = suggestion.replace(/| /g, '|');\r\n    }\r\n\r\n    if (!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 192) {\r\n        // Check for punctuation chars before space\r\n        //  Removed ' (can be normal, e.g., Jesus' cloak)\r\n        //  Removed \r\n        let beforeSpaceCheckList = '({</@\\\\^|$';\r\n        if (fieldType !== 'markdown') beforeSpaceCheckList += '_~'; // These are used for markdown formatting\r\n        if (fieldType !== 'markdown' && fieldType !== 'USFM') beforeSpaceCheckList += '*'; // There are used for markdown formatting and USFM closing markers\r\n        if (fieldType !== 'YAML') beforeSpaceCheckList += '[';\r\n        for (const punctChar of beforeSpaceCheckList) {\r\n            if ((characterIndex = fieldText.indexOf(punctChar + ' ')) >= 0) {\r\n                let extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n                const notice = { priority: 192, message: `Unexpected space after ${punctChar} character`, extract, location: ourLocation };\r\n                if ((fieldType !== 'raw' && fieldType !== 'text') || fieldName.substring(0, 6) !== 'from \\\\')\r\n                    notice.characterIndex = characterIndex; // characterIndex means nothing for processed USFM\r\n                addNoticePartial(notice);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 193) {\r\n        // Check for punctuation chars at end of line\r\n        //  Removed ' (can be normal, e.g., Jesus' cloak)\r\n        let beforeEOLCheckList = '([{</@\\\\^|$';\r\n        if (fieldType !== 'markdown') beforeEOLCheckList += '_~'; // These are used for markdown formatting\r\n        if (fieldType !== 'markdown' && fieldType !== 'USFM') beforeEOLCheckList += '*'; // There are used for markdown formatting and USFM closing markers\r\n        for (const punctChar of beforeEOLCheckList) {\r\n            if (punctChar !== '' && fieldText[fieldText.length - 1] === punctChar) {\r\n                characterIndex = fieldText.length - 1;\r\n                let extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n                const notice = { priority: 193, message: `Unexpected ${punctChar} character at end of line`, extract, location: ourLocation };\r\n                if ((fieldType !== 'raw' && fieldType !== 'text') || fieldName.substring(0, 6) !== 'from \\\\')\r\n                    notice.characterIndex = characterIndex; // characterIndex means nothing for processed USFM\r\n                addNoticePartial(notice);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 849)\r\n        // Check for bad combinations of characters\r\n        for (const badCharCombination of BAD_CHARACTER_COMBINATIONS)\r\n            if ((characterIndex = fieldText.indexOf(badCharCombination)) >= 0) {\r\n                let extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '');\r\n                addNoticePartial({ priority: 849, message: `Unexpected '${badCharCombination}' character combination`, characterIndex, extract, location: ourLocation });\r\n            }\r\n\r\n    // // Check for problems created by tC Create or something\r\n    // characterIndex = fieldText.indexOf('\\\\[');\r\n    // if (characterIndex === -1) characterIndex = fieldText.indexOf('\\\\]');\r\n    // if (characterIndex !== -1) {\r\n    //     let extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '');\r\n    //     addNoticePartial({ priority: 849, message: \"Unexpected \\\\[ or \\\\] characters\", characterIndex, extract, location: ourLocation });\r\n    // }\r\n\r\n    // if (countOccurrences(fieldText, '(') !== countOccurrences(fieldText, ')')) {\r\n    //     console.log(`checkTextField(${fieldType}, ${fieldName}, '${fieldText}', ${allowedLinks}, ${ourLocation}) found ${countOccurrences(fieldText, '(')} '(' but ${countOccurrences(fieldText, ')')} ')'`);\r\n    //     addNoticePartial({ priority: 1, message: `Mismatched ( ) characters`, details: `left=${countOccurrences(fieldText, '(').toLocaleString()}, right=${countOccurrences(fieldText, ')').toLocaleString()}`, location: ourLocation });\r\n    // }\r\n    // Check matched pairs in the field\r\n    for (const punctSet of MATCHED_PUNCTUATION_PAIRS) {\r\n        // Cant check '' coz they might be used as apostrophe\r\n        const leftChar = punctSet[0], rightChar = punctSet[1];\r\n        // if (fieldType === 'markdown' && leftChar === '<') continue; // markdown uses this for block quote\r\n        // TODO: The following 'continue' might not be doing the 2nd lot of checks\r\n        if ((fieldType === 'USFM' || fieldName.startsWith('from \\\\') || (fieldType === 'markdown' && fieldName === ''))\r\n            && '([{'.indexOf(leftChar) >= 0) continue; // Start/end can be on different lines\r\n        if (fieldType !== 'markdown' || leftChar !== '<') { // > is a markdown block marker and also used for HTML, e.g., <br>\r\n            const leftCount = countOccurrences(fieldText, leftChar),\r\n                rightCount = countOccurrences(fieldText, rightChar);\r\n            if (leftCount !== rightCount\r\n                && (rightChar !== '' || leftCount > rightCount)) { // Closing single quote is also used as apostrophe in English\r\n                // NOTE: These are higher priority than similar checks in a whole file which is less specific\r\n                const thisPriority = leftChar === '' ? 163 : 563;\r\n                if (!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < thisPriority)\r\n                    addNoticePartial({ priority: thisPriority, message: `Mismatched ${leftChar}${rightChar} characters`, details: `left=${leftCount.toLocaleString()}, right=${rightCount.toLocaleString()}`, location: ourLocation });\r\n            }\r\n            try { // This regex build fails for some of the characters\r\n                const leftRegex = new RegExp(`(\\\\w)\\\\${leftChar}(\\\\w)`, 'g'), rightRegex = new RegExp(`(\\\\w)\\\\${rightChar}(\\\\w)`, 'g');\r\n                // console.log(`leftRegex is ${leftRegex}`);\r\n                let regexResultArray;\r\n                // eslint-disable-next-line no-cond-assign\r\n                while (regexResultArray = leftRegex.exec(fieldText))\r\n                    if ((fieldType !== 'markdown' || regexResultArray[0][0] !== '_')\r\n                        && (fieldType !== 'YAML' || leftChar !== '{')) {\r\n                        // console.log(`Got misplaced left ${leftChar} in ${fieldType} ${fieldName} '${fieldText}':`, JSON.stringify(regexResultArray));\r\n                        let thisPriority = 717, thisMessage = `Misplaced ${leftChar} character`;\r\n                        if (leftChar === '(' && regexResultArray[0][2] === 's') { thisPriority = 17; thisMessage = `Possible misplaced ${leftChar} character`; } // Lower priority for words like 'thing(s)'\r\n                        if (!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < thisPriority)\r\n                            addNoticePartial({ priority: thisPriority, message: thisMessage, extract: regexResultArray[0], location: ourLocation });\r\n                    }\r\n                if (rightChar !== '') // Cant check '' coz they might be used as apostrophe\r\n                    // eslint-disable-next-line no-cond-assign\r\n                    while (regexResultArray = rightRegex.exec(fieldText))\r\n                        if ((fieldType !== 'markdown' || regexResultArray[0][2] !== '_')\r\n                            && (fieldType !== 'YAML' || rightChar !== '}')) {\r\n                            // console.log(`Got misplaced right ${rightChar} in ${fieldType} ${fieldName} '${fieldText}':`, JSON.stringify(regexResultArray));\r\n                            if (!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 716)\r\n                                addNoticePartial({ priority: 716, message: `Misplaced ${rightChar} character`, extract: regexResultArray[0], location: ourLocation });\r\n                        }\r\n            } catch { }\r\n        }\r\n    }\r\n\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 765)\r\n        && !allowedLinks) {\r\n        // Simple check that there arent any\r\n        characterIndex = fieldText.indexOf('://');\r\n        if (characterIndex === -1) characterIndex = fieldText.indexOf('http');\r\n        if (characterIndex === -1) characterIndex = fieldText.indexOf('ftp');\r\n        // The following might have to be removed if text fields can contain email addresses\r\n        if (characterIndex === -1) characterIndex = fieldText.indexOf('.org');\r\n        if (characterIndex === -1) characterIndex = fieldText.indexOf('.com');\r\n        if (characterIndex === -1) characterIndex = fieldText.indexOf('.info');\r\n        if (characterIndex === -1) characterIndex = fieldText.indexOf('.bible');\r\n        if (characterIndex >= 0) {\r\n            let extract = `${characterIndex > halfLength ? '' : ''}${fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus)}${characterIndex + halfLengthPlus < fieldText.length ? '' : ''}`\r\n            addNoticePartial({ priority: 765, message: \"Unexpected link\", characterIndex, extract, location: ourLocation });\r\n        }\r\n    }\r\n\r\n    // See if we have a suggestion\r\n    if (suggestion !== fieldText) {\r\n        // console.log(`Had text ${fieldText}`);\r\n        // console.log(`Sug text ${suggestion}`);\r\n        result.suggestion = suggestion;\r\n    }\r\n\r\n    return result;\r\n}\r\n// end of checkTextField function\r\n","/* This file handles the suppression of notices where we dont want to disable or remove the actual check,\r\n    but we just want to disable it for certain resources to handle special cases.\r\n    In some cases, its to handle software deficiencies.\r\n\r\n  NOTE: This is only recommended for resources which are relatively stable,\r\n          e.g., completed book packages\r\n        as it can rely on details like filename and maybe line number.\r\n*/\r\n\r\n\r\n// const DISABLED_NOTICES_VERSION_STRING = '0.2.0';\r\n\r\n\r\nconst disabledNotices = [\r\n  // Just enter enough details to disable the required message(s) and no unwanted ones\r\n  //  i.e., you can be as specific as you need about username and/or lineNumber, etc.\r\n\r\n  // TODO: Remove this -- its only temporary to handle valid TN links like [](../02/20/zu5f) that are checked as issues\r\n  { repoCode: 'TN', priority: 648, }, // \"More [ ]( ) links than valid Bible links\" not yet properly handled by this package\r\n\r\n  { repoCode: 'TN', priority: 450, }, // TN \"Resource container link should have '*' language code with (not 'en')\" as tC cant handle it yet!\r\n\r\n  { repoCode: 'ST', message: \"Bad punctuation nesting: } closing character doesnt match\", bookID: 'NEH', }, // 777 - complex { } nesting in direct speech\r\n  { repoCode: 'ST', message: \"Bad punctuation nesting:  closing character doesnt match\", bookID: 'NEH', }, // 777 - complex { } nesting in direct speech\r\n\r\n  { repoCode: 'LT', priority: 638, fieldName: '\\\\p', }, // \"Only found whitespace\" tC3 outputs trailing spaces here\r\n  { repoCode: 'ST', priority: 638, fieldName: '\\\\p', }, // \"Only found whitespace\" tC3 outputs trailing spaces here\r\n  { repoCode: 'LT', priority: 124, extract: '\\\\p', }, // \"Unexpected double spaces\" tC3 outputs trailing spaces here\r\n  { repoCode: 'ST', priority: 124, extract: '\\\\p', }, // \"Unexpected double spaces\" tC3 outputs trailing spaces here\r\n  { repoCode: 'LT', message: \"Unexpected space after | character\", }, // 192 tC3 outputs an unneeded/unwanted space in \\zaln-s\r\n  { repoCode: 'ST', message: \"Unexpected space after | character\", }, // 192 tC3 outputs an unneeded/unwanted space in \\zaln-s\r\n  { repoCode: 'LT', priority: 95, }, // \"Unexpected trailing space(s)\" tC3 outputs trailing spaces all over the place\r\n  { repoCode: 'ST', priority: 95, }, // \"Unexpected trailing space(s)\" tC3 outputs trailing spaces all over the place\r\n\r\n  { repoCode: 'TA', priority: 104, }, // \"Unexpected trailing line break\" UTA uses trailing <BR> for (1) (2) (3) style numbered lists\r\n\r\n  { repoCode: 'TA', message: \"Unexpected  character after space\", }, // 191 -- temp en-dashes\r\n  { repoCode: 'TA', message: \"Unexpected space after  character\", }, // 192 -- temp en-dashes\r\n\r\n  { repoCode: 'TA', priority: 172, }, // \"Header levels should only increment by one\" not required for TA\r\n\r\n  { repoCode: 'TA', filename: 'translate/translate-alphabet/01.md', message: \"At end of text with unclosed  opening character\", }, // 768\r\n  { repoCode: 'TA', filename: 'translate/translate-alphabet/01.md', message: \"Mismatched  characters\", }, // 462\r\n  { repoCode: 'TA', filename: 'translate/translate-textvariants/01.md', message: \"Unexpected space after [ character\", }, // 192\r\n  { repoCode: 'TA', filename: 'translate/translate-formatsignals/01.md', message: \"Unexpected space after ( character\", }, // 192\r\n\r\n  // This file has a space-separated list of typical quotation symbols\r\n  { repoCode: 'TA', filename: 'translate/figs-quotemarks/01.md', message: \"Unexpected space after  character\", lineNumber: 3, }, // 192\r\n  { repoCode: 'TA', filename: 'translate/figs-quotemarks/01.md', message: \"Unexpected space after  character\", lineNumber: 16, }, // 192\r\n  { repoCode: 'TA', filename: 'translate/figs-quotemarks/01.md', message: \"Unexpected space after  character\", lineNumber: 16, }, // 192\r\n  { repoCode: 'TA', filename: 'translate/figs-quotemarks/01.md', message: \"Unexpected space after  character\", }, // 192\r\n  { repoCode: 'TA', filename: 'translate/figs-quotemarks/01.md', message: \"Unexpected space after  character\", }, // 192\r\n  { repoCode: 'TA', filename: 'translate/figs-quotemarks/01.md', message: \"Unexpected space after  character\", }, // 192\r\n\r\n  { repoCode: 'TA', filename: 'translate/figs-quotemarks/01.md', message: \"Unexpected . character after space\", lineNumber: 16, }, // 191\r\n  { repoCode: 'TA', filename: 'translate/figs-quotemarks/01.md', message: \"Unexpected  character after space\", }, // 191\r\n  { repoCode: 'TA', filename: 'translate/figs-quotemarks/01.md', message: \"Unexpected  character after space\", }, // 191\r\n  { repoCode: 'TA', filename: 'translate/figs-quotemarks/01.md', message: \"Unexpected  character after space\", }, // 191\r\n  { repoCode: 'TA', filename: 'translate/figs-quotemarks/01.md', message: \"Unexpected  character after space\", }, // 191\r\n  { repoCode: 'TA', filename: 'translate/figs-quotemarks/01.md', message: \"Unexpected  character after space\", }, // 191\r\n\r\n  { repoCode: 'TA', filename: 'translate/figs-metaphor/01.md', message: \"Possible misplaced ( character\", }, // 17\r\n];\r\n\r\n\r\n/**\r\n *\r\n * @param {Object} givenNotice\r\n * @returns true if the givenNotice has a match in the disabledNotices list above\r\n */\r\nexport function isDisabledNotice(givenNotice) {\r\n  // if (givenNotice.priority===638) console.log(`isDisabledNotice(${JSON.stringify(givenNotice)})`);\r\n  for (const disabledNotice of disabledNotices) {\r\n    let matched = true;\r\n    for (const propertyName in disabledNotice)\r\n      if (givenNotice[propertyName] !== disabledNotice[propertyName]) {\r\n        matched = false;\r\n        break;\r\n      }\r\n    if (matched) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {Array} givenNoticeList\r\n * @returns a new list of notices with disabled ones removed\r\n */\r\nexport function removeDisabledNotices(givenNoticeList) {\r\n  const remainingNoticeList = [];\r\n  for (const thisNotice of givenNoticeList) {\r\n      if (!isDisabledNotice(thisNotice))\r\n          remainingNoticeList.push(thisNotice);\r\n  }\r\n  // console.log(`removeDisabledNotices: returning ${remainingNoticeList.length} from ${givenNoticeList.length} notices`);\r\n  return remainingNoticeList;\r\n}\r\n","import Path from 'path';\r\nimport yaml from 'yaml';\r\nimport localforage from 'localforage';\r\nimport { setup } from 'axios-cache-adapter';\r\nimport JSZip from 'jszip';\r\nimport * as books from './books';\r\nimport { clearCheckedArticleCache } from './tn-links-check';\r\n\r\n\r\n// const GETAPI_VERSION_STRING = '0.6.7';\r\n\r\nconst MAX_INDIVIDUAL_FILES_TO_DOWNLOAD = 5; // More than this and it downloads the zipfile for the entire repo\r\n\r\nconst baseURL = 'https://git.door43.org/';\r\nconst apiPath = 'api/v1';\r\n\r\n\r\n// caches failed http file fetches so we dont waste time with repeated attempts\r\nconst failedStore = localforage.createInstance({\r\n  driver: [localforage.INDEXEDDB],\r\n  name: 'CV-failed-store',\r\n});\r\n\r\n// caches zip file fetches done by cachedGetRepositoryZipFile()\r\nconst zipStore = localforage.createInstance({\r\n  driver: [localforage.INDEXEDDB],\r\n  name: 'CV-zip-store',\r\n});\r\n\r\n// caches http file fetches done by cachedFetchFileFromServer()\r\nconst cacheStore = localforage.createInstance({\r\n  driver: [localforage.INDEXEDDB],\r\n  name: 'CV-web-cache',\r\n});\r\n\r\n// caches the unzipped files requested so we dont do repeated unzipping of the same file which is slow in JS\r\nconst unzipStore = localforage.createInstance({\r\n  driver: [localforage.INDEXEDDB],\r\n  name: 'CV-unzip-store',\r\n});\r\n\r\n// API for http requests\r\n// NOTE: Even if data expires in this AxiosCacheAdapter, the localforage caches dont have the same / any expiry ages\r\n//        (We expect the users of the demos to manually clear the caches when an update is required.)\r\nconst Door43Api = setup({\r\n  baseURL: baseURL,\r\n  cache: {\r\n    store: cacheStore,\r\n    maxAge: 1 * 60 * 60 * 1000, // 1 hour (unless they manually clear the cache)\r\n    exclude: { query: false },\r\n    key: req => {\r\n      // if (req.params) debugger\r\n      let serialized = req.params instanceof URLSearchParams ?\r\n        req.params.toString() : JSON.stringify(req.params) || '';\r\n      return req.url + serialized;\r\n    },\r\n  },\r\n});\r\n\r\n\r\n/**\r\n * Clear all the localforage.INDEXEDDB stores\r\n * @return {Promise<void>}\r\n */\r\nexport async function clearCaches() {\r\n  console.log(\"Clearing all four CV localforage.INDEXEDDB caches\");\r\n  // const tasks = [zipStore, cacheStore].map(localforage.clear);\r\n  // const results = await Promise.all(tasks);\r\n  // results.forEach(x => console.log(\"Done it\", x));\r\n  await failedStore.clear();\r\n  await zipStore.clear();\r\n  await cacheStore.clear(); // This is the one used by the Axion Door43Api (above)\r\n  await unzipStore.clear();\r\n  await clearCheckedArticleCache(); // Used for checking TA and TW articles referred to by TN links\r\n}\r\n\r\n\r\n/**\r\n * @description - Forms and returns a Door43 repoName string\r\n * @param {String} languageCode - the language code, e.g., 'en'\r\n * @param {String} repoCode - the repo code, e.g., 'TQ2'\r\n * @return {String} - the Door43 repoName string\r\n */\r\nexport function formRepoName(languageCode, repoCode) {\r\n  //    console.log(`formRepoName('${languageCode}', '${repoCode}')`);\r\n\r\n  // TODO: Should we also check the username 'unfoldingWord' and/or 'Door43-Catalog' here???\r\n  //        (We dont currently have the username available in this function.)\r\n  if (repoCode === 'LT') repoCode = languageCode === 'en' ? 'ULT' : 'GLT';\r\n  if (repoCode === 'ST') repoCode = languageCode === 'en' ? 'UST' : 'GST';\r\n\r\n  let repo_languageCode = languageCode;\r\n  if (repoCode === 'UHB') repo_languageCode = 'hbo';\r\n  else if (repoCode === 'UGNT') repo_languageCode = 'el-x-koine';\r\n\r\n  let repoName;\r\n\r\n  // if (repoCode.endsWith('2')) repoCode = repoCode.substring(0, repoCode.length - 1);\r\n  repoName = `${repo_languageCode}_${repoCode.toLowerCase()}`;\r\n  return repoName;\r\n}\r\n\r\n\r\n/**\r\n * add new repo to list if missing\r\n * @param repos\r\n * @param newRepo\r\n */\r\n/*\r\nfunction addToListIfMissing(repos, newRepo) {\r\n  if (!repos.includes(newRepo)) {\r\n    repos.unshift(newRepo);\r\n  }\r\n}\r\n*/\r\n\r\n\r\n/**\r\n * try to get previously unzipped file from cache\r\n * @param {string} path\r\n * @return {Promise<unknown>} resolves to file contents or null if not found\r\n */\r\nasync function getUnZippedFile(path) {\r\n  // console.log(`getUnZippedFile(${path})`);\r\n  const contents = await unzipStore.getItem(path.toLowerCase());\r\n  return contents;\r\n}\r\n\r\n\r\n/**\r\n * searches for files in this order:\r\n *   - cache of uncompressed files (unzipStore)\r\n *   - cache of zipped repos (zipStore)\r\n *   - and finally calls cachedFetchFileFromServer() which first checks in cacheStore to see if already fetched. * @param {String} username\r\n * @param {String} repository\r\n * @param {String} path\r\n * @param {String} branch\r\n * @return {Promise<*>}\r\n */\r\n// This is the function that we call the most from the outside\r\nexport async function cachedGetFile({ username, repository, path, branch }) {\r\n  // console.log(`cachedGetFile(${username}, ${repository}, ${path}, ${branch})`);\r\n  console.assert(typeof username === 'string' && username.length, `cachedGetFile: username parameter should be a non-empty string not ${typeof username}: ${username}`);\r\n  console.assert(typeof repository === 'string' && repository.length, `cachedGetFile: repository parameter should be a non-empty string not ${typeof repository}: ${repository}`);\r\n  console.assert(typeof path === 'string' && path.length, `cachedGetFile: path parameter should be a non-empty string not ${typeof path}: ${path}`);\r\n  console.assert(typeof branch === 'string' && branch.length, `cachedGetFile: branch parameter should be a non-empty string not ${typeof branch}: ${branch}`);\r\n\r\n  const filePath = Path.join(username, repository, path, branch);\r\n  let contents = await getUnZippedFile(filePath);\r\n  if (contents) {\r\n    // console.log(`cachedGetFile got ${filePath} from unzipped cache`);\r\n    return contents;\r\n  }\r\n\r\n  contents = await getFileFromZip({ username, repository, path, branch });\r\n  // if (contents)\r\n  //   if (filePath.indexOf('_tq/') < 0) // Dont log for TQ2 files coz too many\r\n  //     console.log(`  cachedGetFile got ${filePath} from zipfile`);\r\n  if (!contents) {\r\n    contents = await cachedFetchFileFromServer({ username, repository, path, branch });\r\n  }\r\n\r\n  if (contents) {\r\n    // save unzipped file in cache to speed later retrieval\r\n    await unzipStore.setItem(filePath.toLowerCase(), contents);\r\n    // if (filePath.indexOf('_tq/') < 0) // Dont log for TQ2 files coz too many\r\n    //   console.log(`cachedGetFile saved ${filePath} to cache for next time`);\r\n  }\r\n  // else console.error(`cachedGetFile(${username}, ${repository}, ${path}, ${branch}) -- failed to get file`);\r\n\r\n  return contents;\r\n}\r\n\r\n\r\n/**\r\n * Retrieve manifest.yaml from requested repo\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} branch\r\n * @return {Promise<[]|*[]>} resolves to manifest contents if downloaded (else undefined)\r\n */\r\nasync function cachedGetManifest({ username, repository, branch }) {\r\n  // console.log(`cachedGetManifest(${username}, ${repository}, ${branch})`);\r\n\r\n  const manifestContents = await cachedGetFile({ username, repository, path: 'manifest.yaml', branch });\r\n  let formData;\r\n  try {\r\n    formData = yaml.parse(manifestContents);\r\n    // console.log(\"yaml.parse(YAMLText) got formData\", JSON.stringify(formData));\r\n  }\r\n  catch (yamlError) {\r\n    console.error(`${username} ${repository} ${branch} manifest yaml parse error: ${yamlError.message}`);\r\n  }\r\n  return formData;\r\n}\r\n\r\n\r\n/**\r\n * Retrieve manifest.yaml from requested repo\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} branch\r\n * @param {string} bookID -- 3-character USFM book code\r\n * @return {Promise<[]|*[]>} resolves to filename from the manifest for the book (else undefined)\r\n */\r\nexport async function cachedGetBookFilenameFromManifest({ username, repository, branch, bookID }) {\r\n  // console.log(`cachedGetBookFilenameFromManifest(${username}, ${repository}, ${branch}, ${bookID})`);\r\n  const manifestJSON = await cachedGetManifest({ username, repository, branch });\r\n  for (const projectEntry of manifestJSON.projects) {\r\n    if (projectEntry.identifier === bookID) {\r\n      let bookPath = projectEntry.path;\r\n      if (bookPath.startsWith('./')) bookPath = bookPath.substring(2);\r\n      return bookPath;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Preloads any necessary repo zips, before running book package checks\r\n *   This allows the calling app to clear cache and start loading repos in the backgound as soon as it starts up.\r\n *      In this case it would not need to use await to wait for results.\r\n *   TRICKY: note that even if the user is super fast in selecting books and clicking next, it will not hurt anything.\r\n *            cachedGetFileFromZipOrServer() would just be fetching files directly from repo until the zips are loaded.\r\n *            After that the files would be pulled out of zipStore.\r\n * @param {string} username\r\n * @param {string} languageCode\r\n * @param {Array} bookIDList - one or more books that will be checked\r\n * @param {string} branch - optional, defaults to master\r\n * @param {Array} repoList - optional, list of repos to pre-load\r\n * @return {Promise<Boolean>} resolves to true if file loads are successful\r\n */\r\nexport async function preloadReposIfNecessary(username, languageCode, bookIDList, branch, repoList) {\r\n  // NOTE: We preload TA and TW by default because we are likely to have many links to those repos\r\n  //        We preload TQ by default because it has thousands of files (17,337), so individual file fetches might be slow\r\n  //          even for one book which might have several hundred files.\r\n  console.log(`preloadReposIfNecessary(${username}, ${languageCode}, ${bookIDList} (${typeof bookID}), ${branch}, [${repoList}])`);\r\n  let success = true;\r\n\r\n  const repos_ = [...repoList];\r\n  if (bookIDList.length === 1 && bookIDList[0] === 'OBS') {\r\n    if (!repos_.includes('OBS'))\r\n      repos_.unshift('OBS'); // push to beginning of list\r\n  }\r\n  if (bookIDList && Array.isArray(bookIDList) && bookIDList.length > MAX_INDIVIDUAL_FILES_TO_DOWNLOAD) { // Fetch individually if checking less books\r\n    // make sure we have the original languages needed\r\n    for (const bookID of bookIDList) {\r\n      if (bookID !== 'OBS') {\r\n        const whichTestament = books.testament(bookID); // returns 'old' or 'new'\r\n        const origLangRepo = whichTestament === 'old' ? 'UHB' : 'UGNT';\r\n        if (!repos_.includes(origLangRepo))\r\n          repos_.unshift(origLangRepo);\r\n      }\r\n    }\r\n  }\r\n  // console.log(\"  Adjusted repo list\", repos_.length, JSON.stringify(repos_));\r\n\r\n  // // See if the required repos are there already\r\n  // console.log(`Check if need to preload ${repos_.length} repos: ${repos_}`)\r\n  // const newRepoList = [];\r\n  // for (const repoCode of repos_) {\r\n  //   const repoName = formRepoName(languageCode, repoCode);\r\n  //   // console.log(`preloadReposIfNecessary: checking zip file for ${repoName}`);\r\n  //   const uri = zipUri({ username, repository: repoName, branch });\r\n  //   const zipBlob = await zipStore.getItem(uri.toLowerCase());\r\n  //   if (!zipBlob) newRepoList.push(repoCode);\r\n  // }\r\n\r\n  // if (newRepoList.length) { // Fetch zipped versions of all the repos needing to be preloaded\r\n  //   console.log(`Need to preload ${newRepoList.length} repos: ${newRepoList}`)\r\n  //   for (const repoCode of newRepoList) {\r\n  //     const repoName = formRepoName(languageCode, repoCode);\r\n  //     console.log(`preloadReposIfNecessary: preloading zip file for ${repoName}`);\r\n  //     const zipFetchSucceeded = await cachedGetRepositoryZipFile({ username, repository: repoName, branch });\r\n  //     if (!zipFetchSucceeded) {\r\n  //       console.log(`preloadReposIfNecessary: misfetched zip file for ${repoCode} repo with ${zipFetchSucceeded}`);\r\n  //       success = false;\r\n  //     }\r\n  //   }\r\n  // }\r\n  // else console.log(\"All repos were cached already!\");\r\n\r\n  for (const repoCode of repos_) {\r\n    let adjustedLanguageCode = languageCode;\r\n    if ((languageCode === 'hbo' && repoCode !== 'UHB') || (languageCode === 'el-x-koine' && repoCode !== 'UGNT'))\r\n      adjustedLanguageCode = 'en'; // Assume English then\r\n    let adjustedBranch = branch;\r\n    let adjustedRepoCode = repoCode;\r\n    if (repoCode === 'TQ2') { adjustedRepoCode = 'TQ'; adjustedBranch = 'newFormat'; }\r\n    else if (repoCode === 'TN2') { adjustedRepoCode = 'TN'; adjustedBranch = 'newFormat'; }\r\n    const repoName = formRepoName(adjustedLanguageCode, adjustedRepoCode);\r\n    // console.log(`preloadReposIfNecessary: preloading zip file for ${repoName}`);\r\n    const zipFetchSucceeded = await cachedGetRepositoryZipFile({ username, repository: repoName, branch: adjustedBranch });\r\n    if (!zipFetchSucceeded) {\r\n      console.error(`preloadReposIfNecessary() misfetched zip file for ${repoCode} repo with ${zipFetchSucceeded}`);\r\n      success = false;\r\n    }\r\n  }\r\n  return success;\r\n}\r\n\r\n\r\n/**\r\n * does http file fetch from server  uses cacheStore to minimize repeated fetches of same file\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} path\r\n * @param {string} branch\r\n * @return {Promise<null|any>} resolves to file content\r\n */\r\nasync function cachedFetchFileFromServer({ username, repository, path, branch = 'master' }) {\r\n  // console.log(`cachedFetchFileFromServer(${username}, ${repository}, ${path}, ${branch})`);\r\n  // TODO: Check how slow this next call is -- can it be avoided or cached?\r\n  // RJH removed this 2Oct2020 -- whats the point -- it just slows things down --\r\n  //      if it needs to be checked, should be checked before this point\r\n  // const repositoryExistsOnDoor43 = await repositoryExistsOnDoor43({ username, repository });\r\n  // let uri;\r\n  const uri = Path.join(username, repository, 'raw/branch', branch, path);\r\n  const failMessage = await failedStore.getItem(uri.toLowerCase());\r\n  if (failMessage) {\r\n    // console.log(`  cachedFetchFileFromServer failed previously for ${uri}: ${failMessage}`);\r\n    return null;\r\n  }\r\n  try {\r\n    // console.log(\"URI=\",uri);\r\n    const data = await cachedGetFileUsingPartialURL({ uri });\r\n    // console.log(\"Got data\", data);\r\n    return data;\r\n  }\r\n  catch (fffsError) {\r\n    console.error(`cachedFetchFileFromServer could not fetch ${username} ${repository} ${branch} ${path}: ${fffsError}`)\r\n      /* await */ failedStore.setItem(uri.toLowerCase(), fffsError.message);\r\n    return null;\r\n  }\r\n  // } else { // ! repositoryExistsOnDoor43\r\n  //   console.error(`cachedFetchFileFromServer repo ${username} '${repository}' does not exist!`);\r\n  //   /* await */ failedStore.setItem(uri.toLowerCase(), `Repo '${repository}' does not exist!`);\r\n  //   return null;\r\n  // }\r\n};\r\n\r\n\r\n/**\r\n *  older getFile without that doesnt use the unzipStore\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} path\r\n * @param {string} branch\r\n * @return {Promise<*>}\r\n */\r\n/*\r\nasync function cachedGetFileFromZipOrServer({ username, repository, path, branch }) {\r\n  // console.log(`cachedGetFileFromZipOrServer(${username}, ${repository}, ${path}, ${branch})`);\r\n  let file;\r\n  file = await getFileFromZip({ username, repository, path, branch });\r\n  if (!file) {\r\n    file = await cachedFetchFileFromServer({ username, repository, path, branch });\r\n  }\r\n  return file;\r\n}\r\n*/\r\n\r\nasync function getUID({ username }) {\r\n  // console.log(`getUID(${username})`);\r\n  const uri = Path.join(apiPath, 'users', username);\r\n  // console.log(`getUID uri=${uri}`);\r\n  const user = await cachedGetFileUsingPartialURL({ uri });\r\n  // console.log(`getUID user=${user}`);\r\n  const { id: uid } = user;\r\n  // console.log(`  getUID returning: ${uid}`);\r\n  return uid;\r\n}\r\n\r\nexport async function repositoryExistsOnDoor43({ username, repository }) {\r\n  // console.log(`repositoryExistsOnDoor43(${username}, ${repository})`);\r\n  let uid;\r\n  try {\r\n    uid = await getUID({ username });\r\n  } catch (uidError) {\r\n    console.error(`repositoryExistsOnDoor43(${username}, ${repository}) - invalid username`, uidError.message);\r\n    return false;\r\n  }\r\n  // console.log(`repositoryExistsOnDoor43 uid=${uid}`);\r\n  // Default limit is 10 -- way too small\r\n  const params = { q: repository, limit: 500, uid }; // Documentation says limit is 50, but larger numbers seem to work ok\r\n  const uri = Path.join(apiPath, 'repos', `search`);\r\n  // console.log(`repositoryExistsOnDoor43 uri=${uri}`);\r\n  let retrievedRepoList;\r\n  try {\r\n    const { data: retrievedRepoListData } = await cachedGetFileUsingPartialURL({ uri, params });\r\n    retrievedRepoList = retrievedRepoListData;\r\n  }\r\n  catch (rEE) {\r\n    console.error(`repositoryExistsOnDoor43(${username}, ${repository}) - error fetching repo list`, rEE.message);\r\n    return false;\r\n  }\r\n  // console.log(\"retrievedRepoList.length\", retrievedRepoList.length);\r\n  if (retrievedRepoList.length < 1) {\r\n    console.log(`repositoryExistsOnDoor43(${username}, ${repository}) - no repos found`, retrievedRepoList);\r\n    return false;\r\n  }\r\n  // console.log(`repositoryExistsOnDoor43 retrievedRepoList (${retrievedRepoList.length})=${JSON.stringify(retrievedRepoList)}`);\r\n  // for (const thisRepo of retrievedRepoList) console.log(`  thisRepo (${JSON.stringify(Object.keys(thisRepo))}) =${JSON.stringify(thisRepo.name)}`);\r\n  const desiredMatch = `${username}/${repository}`.toLowerCase();\r\n  const filteredRepoList = retrievedRepoList.filter(repo => repo.full_name.toLowerCase() === desiredMatch);\r\n  if (filteredRepoList.length < 1) {\r\n    console.log(`repositoryExistsOnDoor43(${username}, ${repository}) - repo not found`, retrievedRepoList.length, filteredRepoList.length);\r\n    return false;\r\n  }\r\n  // const foundRepo = filteredRepoList[0];\r\n  // console.log(`repositoryExistsOnDoor43 foundRepo=${JSON.stringify(foundRepo)}`);\r\n  return true;\r\n};\r\n\r\n\r\nasync function cachedGetFileUsingPartialURL({ uri, params }) {\r\n  // console.log(`cachedGetFileUsingPartialURL(${uri}, ${JSON.stringify(params)})`);\r\n  // console.log(`  get querying: ${baseURL+uri}`);\r\n  const response = await Door43Api.get(baseURL + uri, { params });\r\n  if (response.request.fromCache !== true) console.log(`  Door43Api downloaded Door43 ${uri}`);\r\n  // console.log(`  cachedGetFileUsingPartialURL returning: ${JSON.stringify(response.data)}`);\r\n  return response.data;\r\n};\r\n\r\nexport async function cachedGetFileUsingFullURL({ uri, params }) {\r\n  // console.log(`cachedGetFileUsingFullURL(${uri}, ${params})`);\r\n  const response = await Door43Api.get(uri, { params });\r\n  if (response.request.fromCache !== true) console.log(`  Door43Api downloaded ${uri}`);\r\n  // console.log(`  cachedGetFileUsingFullURL returning: ${response.data}`);\r\n  return response.data;\r\n};\r\n\r\n\r\n/*\r\nfunction fetchRepositoriesZipFiles({username, languageId, branch}) {\r\n  const repositories = resourceRepositories({languageId});\r\n  const promises = Object.values(repositories).map(repository => {\r\n    return downloadRepositoryZipFile({username, repository, branch});\r\n  });\r\n  const zipArray = await Promise.all(promises);\r\n  return zipArray;\r\n};\r\n*/\r\n\r\n\r\n/**\r\n * retrieve repo as zip file\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} branch\r\n * @param {boolean} forceLoad - if not true, then use existing repo in zipstore\r\n * @return {Promise<[]|*[]>} resolves to true if downloaded\r\n */\r\nexport async function cachedGetRepositoryZipFile({ username, repository, branch }, forceLoad = false) {\r\n  // https://git.door43.org/{username}/{repository}/archive/{branch}.zip\r\n  // console.log(`cachedGetRepositoryZipFile(${username}, ${repository}, ${branch}, ${forceLoad})`);\r\n\r\n  if (!forceLoad) { // see if we already have in zipStore\r\n    const zipBlob = await getZipFromStore(username, repository, branch);\r\n    if (zipBlob) {\r\n      // console.log(`cachedGetRepositoryZipFile for ${username}, ${repository}, ${branch} -- already loaded`);\r\n      return true;\r\n    }\r\n  }\r\n  return downloadRepositoryZipFile({ username, repository, branch });\r\n};\r\n\r\n\r\nasync function downloadRepositoryZipFile({ username, repository, branch }) {\r\n  console.log(`downloadRepositoryZipFile(${username}, ${repository}, ${branch})`);\r\n  // RJH removed this 2Oct2020 -- whats the point -- it just slows things down --\r\n  //      if it needs to be checked, should be checked before this point\r\n  // const repoExists = await repositoryExistsOnDoor43({ username, repository });\r\n  // if (!repoExists) {\r\n  //   console.error(`downloadRepositoryZipFile(${username}, ${repository}, ${branch}) -- repo doesnt even exist`);\r\n  //   return null;\r\n  // }\r\n\r\n  // Template is https://git.door43.org/{username}/{repository}/archive/{branch}.zip\r\n  const uri = zipUri({ username, repository, branch });\r\n  const response = await fetch(uri);\r\n  if (response.status === 200 || response.status === 0) {\r\n    const zipArrayBuffer = await response.arrayBuffer(); // blob storage not supported on mobile\r\n    await zipStore.setItem(uri.toLowerCase(), zipArrayBuffer);\r\n    // console.log(`  downloadRepositoryZipFile(${username}, ${repository}, ${branch}) -- saved zip: ${uri}`);\r\n    return true;\r\n  } else {\r\n    console.error(`downloadRepositoryZipFile(${username}, ${repository}, ${branch}) -- got response status: ${response.status}`);\r\n    return false;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * pull repo from zipstore and get a file list\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} branch\r\n * @param {string} optionalPrefix - to filter by book, etc.\r\n * @return {Promise<[]|*[]>}  resolves to file list\r\n */\r\nexport async function getFileListFromZip({ username, repository, branch, optionalPrefix }) {\r\n  // console.log(`getFileListFromZip(${username}, ${repository}, ${branch}, ${optionalPrefix})`);\r\n\r\n  const uri = zipUri({ username, repository, branch });\r\n  let zipBlob = await getZipFromStore(username, repository, branch);\r\n\r\n  if (!zipBlob) { // Seems that we need to load the zip file first\r\n    const response = await fetch(uri);\r\n    if (response.status === 200 || response.status === 0) {\r\n      const zipArrayBuffer = await response.arrayBuffer(); // blob storage not supported on mobile\r\n      zipBlob = await zipStore.setItem(uri.toLowerCase(), zipArrayBuffer);\r\n    } else {\r\n      console.error(`getFileListFromZip got response status: ${response.status}`);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  const pathList = [];\r\n  try {\r\n    if (zipBlob) {\r\n      // console.log(`  Got zipBlob for uri=${uri}`);\r\n      const zip = await JSZip.loadAsync(zipBlob);\r\n      // console.log(`  Got zip`);\r\n      // Now we need to fetch the list of files from the repo\r\n      // zip.forEach(function (relativePath, fileObject) {\r\n      zip.forEach(function (relativePath) {\r\n        // console.log(`relPath=${relativePath}`)\r\n        // consoleLogObject('fileObject', fileObject);\r\n        if (!relativePath.endsWith('/')) // its not a folder\r\n        {\r\n          if (relativePath.startsWith(`${repository}/`)) // remove repo name prefix\r\n            relativePath = relativePath.substring(repository.length + 1);\r\n          if (relativePath.length\r\n            && !relativePath.startsWith('.git') // skips files in these folders\r\n            && !relativePath.startsWith('.apps') // skips files in this folder\r\n            && (!optionalPrefix || relativePath.startsWith(optionalPrefix))) // its the correct prefix\r\n            pathList.push(relativePath);\r\n        }\r\n      })\r\n    }\r\n    // else console.log(\"  getFileListFromZip: No zipBlob\");\r\n  } catch (error) {\r\n    console.error(`getFileListFromZip got: ${error.message}`);\r\n  }\r\n\r\n  // console.log(`getFileListFromZip is returning (${pathList.length}) entries: ${pathList}`);\r\n  return pathList;\r\n}\r\n\r\n\r\n/**\r\n * try to get zip file from cache\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} branch\r\n * @return {Promise<unknown>} resolves to null if not found\r\n */\r\nasync function getZipFromStore(username, repository, branch) {\r\n  // console.log(`getZipFromStore(${username}, ${repository}, ${branch})`);\r\n  const uri = zipUri({ username, repository, branch });\r\n  // console.log(`  uri=${uri}`);\r\n  const zipBlob = await zipStore.getItem(uri.toLowerCase());\r\n  // console.log(`  getZipFromStore(${uri} -- empty: ${!zipBlob}`);\r\n  return zipBlob;\r\n}\r\n\r\n\r\n/**\r\n * pull repo from zipstore and get the unzipped file\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} branch\r\n * @param {object} optionalPrefix\r\n * @return {Promise<[]|*[]>} resolves to unzipped file if found or null\r\n */\r\nasync function getFileFromZip({ username, repository, path, branch }) {\r\n  // console.log(`getFileFromZip(${username}, ${repository}, ${path}, ${branch})`);\r\n  let file;\r\n  const zipBlob = await getZipFromStore(username, repository, branch);\r\n  try {\r\n    if (zipBlob) {\r\n      // console.log(`  Got zipBlob for uri=${uri}`);\r\n      const zip = await JSZip.loadAsync(zipBlob);\r\n      const zipPath = Path.join(repository.toLowerCase(), path);\r\n      // console.log(`  zipPath=${zipPath}`);\r\n      file = await zip.file(zipPath).async('string');\r\n      // console.log(`    Got zipBlob ${file.length} bytes`);\r\n    }\r\n    // else console.log(\"  No zipBlob\");\r\n  } catch (error) {\r\n    if (error.message.indexOf(' is null') < 0)\r\n      console.error(`getFileFromZip for ${username} ${repository} ${path} ${branch} got: ${error.message}`);\r\n    file = null;\r\n  }\r\n  return file;\r\n};\r\n\r\n\r\nfunction zipUri({ username, repository, branch = 'master' }) {\r\n  // console.log(`zipUri(${username}, ${repository}, ${branch})`);\r\n  const zipPath = Path.join(username, repository, 'archive', `${branch}.zip`);\r\n  const zipUri = baseURL + zipPath;\r\n  return zipUri;\r\n};\r\n\r\n\r\n// async function fetchTree({ username, repository, sha = 'master' }) {\r\n//   // console.log(`fetchTree(${username}, ${repository}, ${sha})`);\r\n//   let data;\r\n//   try {\r\n//     const uri = Path.join('api/v1/repos', username, repository, 'git/trees', sha);\r\n//     // console.log(`  uri='${uri}'`);\r\n//     data = await cachedGetFileUsingPartialURL({ uri });\r\n//     // console.log(`  data (${typeof data})`);\r\n//     return data;\r\n//     // const tree = JSON.parse(data); // RJH: Why was this here???\r\n//     // console.log(`  tree (${typeof tree})`);\r\n//     // return tree;\r\n//   } catch (error) {\r\n//     console.error(`fetchTree got: ${error.message}`);\r\n//     console.log(`  Data was: ${JSON.stringify(data)}`);\r\n//     return null;\r\n//   }\r\n// };\r\n\r\n\r\n/*\r\nasync function recursiveTree({username, repository, path, sha}) {\r\n  console.log(\"recurse tree args:\",username,repository,path,sha)\r\n  let tree = {};\r\n  const pathArray = path.split();\r\n  const results = fetchTree({username, repository, sha});\r\n  const result = results.tree.filter(item => item.path === pathArray[0])[0];\r\n  if (result) {\r\n    if (result.type === 'tree') {\r\n      const childPath = pathArray.slice(1).join('/');\r\n      const children = recursiveTree({username, repository, path: childPath, sha: result.sha});\r\n      tree[result.path] = children;\r\n    } else if (result.type === 'blob') {\r\n      tree[result.path] = true;\r\n    }\r\n  }\r\n};\r\n\r\nasync function fileExists({username, repository, path, branch}) {\r\n  // get root listing\r\n  recursiveTree()\r\n  // get recursive path listing\r\n}\r\n*/\r\n","// utilities\r\n\r\n// import { isUndefined } from 'lodash';\r\n\r\n\r\nexport function consoleLogObject(clTitle, clObject) {\r\n    // Print an objects componenets to the console\r\n    // Note: the following line succeeds even if length and/or size are undefined\r\n    let clOutput = `cLO: ${clTitle} ${typeof clObject} (length=${clObject.length}) (size=${clObject.size}):\\n`;\r\n    for (const clPropertyName in clObject) {\r\n        // console.log(\"   \", clTitle, clPropertyName); // for debugging only!\r\n        let thisPropertyContents = \"\" + clObject[clPropertyName];\r\n        if (thisPropertyContents.length > 50)\r\n            thisPropertyContents = `(${thisPropertyContents.length}) ${thisPropertyContents.substring(0, 50)}`;\r\n        let oType = typeof clObject[clPropertyName];\r\n        // From https://stackoverflow.com/questions/12996871/why-does-typeof-array-with-objects-return-object-and-not-array#12996879\r\n        if (oType === \"object\" && Object.prototype.toString.call(clObject[clPropertyName]) === \"[object Array]\")\r\n            oType = \"array\";\r\n        clOutput += `  ${clPropertyName} (type=${oType})`;\r\n        let oLength;\r\n        try { oLength = clObject[clPropertyName].length; }\r\n        catch (olError) { oLength = \"null\" }\r\n        if (oLength !== undefined) clOutput += ` (length=${oLength})`;\r\n        if (thisPropertyContents !== undefined) clOutput += `: ${thisPropertyContents}\r\n`;\r\n    }\r\n    console.log(clOutput);\r\n}\r\n// end of consoleLogObject function\r\n\r\n\r\nexport function displayPropertyNames(givenTitle, givenObject) {\r\n    let output = `dPN: ${givenTitle} ${typeof givenObject}:\r\n`;\r\n    for (const propertyName in givenObject)\r\n        output += `  ${propertyName} (type=${typeof givenObject[propertyName]})\r\n`;\r\n    console.log(output);\r\n}\r\n// end of displayPropertyNames function\r\n\r\n\r\nexport function ourParseInt(givenString) {\r\n    /*\r\n    The regular parseInt() function is too forgiving\r\n\r\n    See https://stackoverflow.com/questions/1133770/how-to-convert-a-string-to-an-integer-in-javascript\r\n\r\n    This one throws an error if the entire field doesnt give an integer.\r\n    */\r\n\r\n    /* First attempt\r\n    const int1 = parseInt(givenString, 10); // Dont let the function guess the base (if the string has a leading zero)\r\n    const int2 = givenString * 1; // This one is less forgiving it seems\r\n    if (int1!==int2) console.log(`From '${givenString}' we got ${int1} (${typeof int1}) and ${int2} (${typeof int2})`)\r\n    if (isNaN(int2) || isNaN(int1)\r\n    || int2===undefined || int1==undefined\r\n    || int2!==int1)\r\n        throw \"String is not a simple integer\";\r\n    return int1;\r\n    */\r\n\r\n    // Optimised version\r\n    const int = givenString * 1; // This one is less forgiving it seems\r\n  // eslint-disable-next-line no-throw-literal\r\n    if (isNaN(int)) throw `String '${givenString}'is not a simple integer`;\r\n    return int;\r\n}\r\n\r\n\r\n/*\r\n *\r\n * @param {string} bookID - 3-character UPPERCASE Book Id\r\n * @requires {number} 0..99\r\n */\r\n/*\r\nexport function getBookNumber(bookID) {\r\n    // console.log(`getBookNumber(${bookID})`)\r\n    let numberResult = 99; // default 'unknown' value\r\n    if (bookID==='FRT') numberResult = 0;\r\n    else if (bookID==='BAK') numberResult = 68;\r\n    else if (bookID==='OBS') numberResult = 80;\r\n    else if (bookID==='MANIFEST') numberResult = 81;\r\n    else if (bookID==='MEDIA') numberResult = 82;\r\n    else if (bookID==='LICENSE') numberResult = 83;\r\n    else if (bookID==='README') numberResult = 84;\r\n    else {\r\n        const thisUSFMNumberName = usfmNumberName(bookID);\r\n        numberResult = ourParseInt(thisUSFMNumberName.substring(0, 2)); // 01..67 converted to number\r\n    // } catch {}\r\n    }\r\n    // For everything else\r\n    // console.log(`getBookNumber(${bookID})) returning ${numberResult}`);\r\n    return numberResult;\r\n}\r\n*/\r\n\r\n/*\r\n// function to convert an array to an object\r\n// with keys being 0..n\r\nexport const array_to_obj = ( ar => {\r\n  const ob = {};\r\n  Object.assign(ob,ar);\r\n  return ob;\r\n});\r\n\r\n// function to convert map to object\r\nexport const map_to_obj = ( mp => {\r\n  const ob = {};\r\n  mp.forEach((v,k) => {ob[k]=v});\r\n  return ob;\r\n});\r\n\r\n// function to convert object to a map\r\nexport const obj_to_map = ( ob => {\r\n  const mp = new Map();\r\n  Object.keys ( ob ).forEach (k => { mp.set(k, ob[k]) });\r\n  return mp;\r\n});\r\n\r\n// function to convert word frequency map\r\n// to an object suitable for MaterialTable\r\nexport const wf_to_mt = ( ob => {\r\n  const mt = {};\r\n  mt.title = \"Word Frequency\";\r\n  mt.columns = [\r\n      { title: \"Word\", field: \"word\" },\r\n      { title: \"Count\", field: \"check\" },\r\n  ];\r\n  mt.data = [];\r\n  Object.keys(ob).forEach ( w => {\r\n      mt.data.push({ word: w, check: ob[w] })\r\n  })\r\n\r\n  mt.options = { sorting: true, exportButton: true };\r\n\r\n  return mt;\r\n});\r\n\r\n// function to convert an array of words to\r\n// an object suitable for MaterialTable\r\nexport const aw_to_mt = ( ar => {\r\n  // first convert array to object\r\n  const ob = array_to_obj(ar);\r\n  const mt = {};\r\n  mt.title = \"All Words in Text Order\";\r\n  mt.columns = [\r\n      { title: \"Order\", field: \"order\" , type: \"numeric\"},\r\n      { title: \"Word\", field: \"word\" },\r\n  ];\r\n  mt.data = [];\r\n  Object.keys(ob).forEach ( n => {\r\n      mt.data.push({ order: n, word: ob[n] })\r\n  });\r\n\r\n  mt.options = { sorting: true };\r\n\r\n  return mt;\r\n});\r\n*/\r\n","import localforage from 'localforage';\r\nimport Path from 'path';\r\nimport * as books from '../core/books/books';\r\nimport { DEFAULT_EXTRACT_LENGTH, countOccurrences } from './text-handling-functions'\r\nimport { cachedGetFile, checkMarkdownText } from '../core';\r\nimport { ourParseInt } from './utilities';\r\n// import { consoleLogObject } from '../core/utilities';\r\n\r\n\r\n// const TN_LINKS_VALIDATOR_VERSION_STRING = '0.6.6';\r\n\r\nconst DEFAULT_LANGUAGE_CODE = 'en';\r\nconst DEFAULT_BRANCH = 'master';\r\n\r\nconst GENERAL_LINK1_REGEX = new RegExp('\\\\[.+?\\\\]\\\\(.+?\\\\)', 'g');\r\nconst GENERAL_LINK2_REGEX = new RegExp('\\\\[\\\\[.+?\\\\]\\\\]', 'g');\r\n\r\nconst TA_REGEX = new RegExp('\\\\[\\\\[rc://([^ /]+?)/ta/man/([^ /]+?)/([^ \\\\]]+?)\\\\]\\\\]', 'g');\r\nconst TW_REGEX = new RegExp('\\\\[\\\\[rc://([^ /]+?)/tw/dict/bible/([^ /]+?)/([^ \\\\]]+?)\\\\]\\\\]', 'g');\r\n\r\n// TODO: Allow [Titus 1:9](../01/09/pzi1)\r\n// TODO: See if \"[2:23](../02/03.md)\" is found by more than one regex below\r\nconst OTHER_BOOK_BIBLE_REGEX = new RegExp('\\\\[((?:1 |2 |3 )?)((?:\\\\w+? )?)(\\\\d{1,3}):(\\\\d{1,3})\\\\]\\\\(([123A-Z]{2,3})/(\\\\d{1,3})/(\\\\d{1,3})\\\\.md\\\\)', 'g');\r\nconst THIS_BOOK_BIBLE_REGEX = new RegExp('\\\\[((?:1 |2 |3 )?)((?:\\\\w+? )?)(\\\\d{1,3}):(\\\\d{1,3})\\\\]\\\\((\\\\.{2,3})/(\\\\d{1,3})/(\\\\d{1,3})\\\\.md\\\\)', 'g');\r\nconst THIS_CHAPTER_BIBLE_REGEX = new RegExp('\\\\[((?:1 |2 |3 )?)((?:\\\\w+? )?)(?:(\\\\d{1,3}):)?(\\\\d{1,3})\\\\]\\\\(\\\\./(\\\\d{1,3})\\\\.md\\\\)', 'g');\r\n\r\n\r\n// Caches the path names of files which have been already checked\r\n//  Used for storing paths to TA and TW articles that have already been checked\r\nconst checkedArticleStore = localforage.createInstance({\r\n    driver: [localforage.INDEXEDDB],\r\n    name: 'CV-checked-path-store',\r\n});\r\n\r\nexport async function clearCheckedArticleCache() {\r\n    console.log(\"clearCheckedArticleCache()\");\r\n    await checkedArticleStore.clear();\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} username\r\n * @param {string} repository name\r\n * @param {string} path\r\n * @param {string} branch\r\n */\r\nasync function markAsChecked({ username, repository, path, branch }) {\r\n    // console.log(`markAsChecked(${username}, ${repository}, ${path}, ${branch})`);\r\n    const dummyPath = Path.join(username, repository, branch, path);\r\n    await checkedArticleStore.setItem(dummyPath, true);\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} username\r\n * @param {string} repository name\r\n * @param {string} path\r\n * @param {string} branch\r\n */\r\nasync function alreadyChecked({ username, repository, path, branch }) {\r\n    // console.log(`alreadyChecked(${username}, ${repository}, ${path}, ${branch})`);\r\n    const dummyPath = Path.join(username, repository, branch, path);\r\n    return await checkedArticleStore.getItem(dummyPath);\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @param {string} bookID\r\n * @param {string} fieldName\r\n * @param {string} fieldText\r\n * @param {string} givenLocation\r\n * @param {Object} checkingOptions\r\n */\r\nexport async function checkTNLinksToOutside(bookID, givenC, givenV, fieldName, fieldText, givenLocation, checkingOptions) {\r\n    /* This is for the case of the OccurrenceNote field containing markdown links\r\n\r\n    bookID is a three-character UPPERCASE USFM book identifier or 'OBS'.\r\n\r\n    These notes may contain links\r\n        to TA, e.g., (See: [[rc://en/ta/man/translate/figs-metaphor]] and \r\n        to TWs, e.g., (See: [[rc://en/tw/dict/bible/other/death]] and \r\n        To Bibles, e.g.,  how you translated this in [Revelation 3:11](../03/11.md).\r\n\r\n    // You can supply the function to try to load outside links\r\n    //      checkingOptions?.getFile takes parameters ({username, repository, path, branch})\r\n    // and\r\n    //      checkingOptions?.defaultLanguageCode\r\n\r\n    // We attempt to fetch any TA links to test that the destination is really there\r\n    //  -- you can control this with:\r\n    //      checkingOptions?.taRepoUsername\r\n    //      checkingOptions?.taRepoBranch (or tag)\r\n    //      checkingOptions?.checkLinkedTAArticleFlag\r\n\r\n    // We attempt to fetch any TW links to test that the destination is really there\r\n    //  -- you can control this with:\r\n    //      checkingOptions?.twRepoUsername\r\n    //      checkingOptions?.twRepoBranch (or tag)\r\n    //      checkingOptions?.checkLinkedTWArticleFlag\r\n    */\r\n\r\n    // console.log(`checkTNLinksToOutside v${TN_LINKS_VALIDATOR_VERSION_STRING} ${bookID} (${fieldName}, (${fieldText.length}) '${fieldText}', ${givenLocation}, )`);\r\n    console.assert(bookID !== undefined, \"checkTNLinksToOutside: 'bookID' parameter should be defined\");\r\n    console.assert(typeof bookID === 'string', `checkTNLinksToOutside: 'bookID' parameter should be a string not a '${typeof bookID}'`);\r\n    console.assert(bookID.length === 3, `checkTNLinksToOutside: 'bookID' parameter should be three characters long not ${bookID.length}`);\r\n    console.assert(bookID.toUpperCase() === bookID, `checkTNLinksToOutside: 'bookID' parameter should be UPPERCASE not '${bookID}'`);\r\n    console.assert(bookID === 'OBS' || books.isValidBookID(bookID), `checkTNLinksToOutside: '${bookID}' is not a valid USFM book identifier`);\r\n    console.assert(typeof givenC === 'string', `checkTNLinksToOutside: 'givenC' parameter should be a string not a '${typeof givenC}'`);\r\n    console.assert(typeof givenV === 'string', `checkTNLinksToOutside: 'givenV' parameter should be a string not a '${typeof givenV}'`);\r\n    console.assert(fieldName !== undefined, \"checkTNLinksToOutside: 'fieldText' parameter should be defined\");\r\n    console.assert(typeof fieldName === 'string', `checkTNLinksToOutside: 'fieldText' parameter should be a string not a '${typeof fieldName}'`);\r\n    console.assert(fieldName === 'OccurrenceNote' || fieldName === 'Annotation', `checkTNLinksToOutside: 'fieldName' parameter should be 'OccurrenceNote' or 'Annotation' not '${fieldName}'`);\r\n    console.assert(fieldText !== undefined, \"checkTNLinksToOutside: 'fieldText' parameter should be defined\");\r\n    console.assert(typeof fieldText === 'string', `checkTNLinksToOutside: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);\r\n    console.assert(givenLocation !== undefined, \"checkTNLinksToOutside: 'fieldText' parameter should be defined\");\r\n    console.assert(typeof givenLocation === 'string', `checkTNLinksToOutside: 'fieldText' parameter should be a string not a '${typeof givenLocation}'`);\r\n    console.assert(fieldName === 'OccurrenceNote' || fieldName === 'Annotation', `Unexpected checkTNLinksToOutside fieldName='${fieldName}'`);\r\n\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n    const ctarResult = { noticeList: [], checkedFileCount: 0, checkedFilenames: [], checkedRepoNames: [] };\r\n\r\n    function addNoticePartial(noticeObject) {\r\n        // console.log(`checkTNLinksToOutside Notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : \"\"}${extract ? ` ${extract}` : \"\"}${location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"cTNlnk addNoticePartial: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `cTNlnk addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"cTNlnk addNoticePartial: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `cTNlnk addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(characterIndex !== undefined, \"cTNlnk addNoticePartial: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cTNlnk addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract !== undefined, \"cTNlnk addNoticePartial: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cTNlnk addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"cTNlnk addNoticePartial: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `cTNlnk addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n        // noticeObject.debugChain = noticeObject.debugChain ? `checkTNLinksToOutside ${noticeObject.debugChain}` : `checkTNLinksToOutside(${fieldName})`;\r\n        ctarResult.noticeList.push({ ...noticeObject, bookID, fieldName });\r\n    }\r\n\r\n\r\n    // Main code for checkTNLinksToOutside\r\n    // Get any options that were suppplied, or else set default values\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (trcELerror) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n    // console.log(`Using supplied extractLength=${extractLength}`, `cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n    const getFile_ = (checkingOptions && checkingOptions?.getFile) ? checkingOptions?.getFile : cachedGetFile;\r\n    let defaultLanguageCode;\r\n    try { defaultLanguageCode = checkingOptions?.defaultLanguageCode; } catch (trcLCerror) { }\r\n    if (!defaultLanguageCode) defaultLanguageCode = DEFAULT_LANGUAGE_CODE;\r\n    // console.log(\"checkTNLinksToOutside defaultLanguageCode\", defaultLanguageCode);\r\n\r\n    let taRepoUsername;\r\n    try { taRepoUsername = checkingOptions?.taRepoUsername; } catch (trcUNerror) { }\r\n    if (!taRepoUsername) taRepoUsername = defaultLanguageCode === 'en' ? 'unfoldingWord' : 'Door43-Catalog';\r\n    let taRepoBranch;\r\n    try { taRepoBranch = checkingOptions?.taRepoBranch; } catch (trcBRerror) { }\r\n    if (!taRepoBranch) taRepoBranch = DEFAULT_BRANCH;\r\n    let twRepoUsername;\r\n    try { twRepoUsername = checkingOptions?.twRepoUsername; } catch (trcUNerror) { }\r\n    if (!twRepoUsername) twRepoUsername = defaultLanguageCode === 'en' ? 'unfoldingWord' : 'Door43-Catalog';\r\n    let twRepoBranch;\r\n    try { twRepoBranch = checkingOptions?.twRepoBranch; } catch (trcBRerror) { }\r\n    if (!twRepoBranch) twRepoBranch = DEFAULT_BRANCH;\r\n\r\n    let regexResultArray;\r\n\r\n    // Find total links\r\n    const linksList1 = fieldText.match(GENERAL_LINK1_REGEX) || [];\r\n    // console.log(`linksList1=${JSON.stringify(linksList1)}`);\r\n    const linksList2 = fieldText.match(GENERAL_LINK2_REGEX) || [];\r\n    const totalLinks1 = linksList1.length;\r\n    const totalLinks2 = linksList2.length;\r\n    let taLinkCount = 0, twLinkCount = 0, thisChapterBibleLinkCount = 0, thisBookBibleLinkCount = 0, otherBookBibleLinkCount = 0;\r\n\r\n    // Check TA links like [[rc://en/ta/man/translate/figs-metaphor]]\r\n    // console.log(\"checkTNLinksToOutside: Search for TA links\")\r\n    // eslint-disable-next-line no-cond-assign\r\n    while (regexResultArray = TA_REGEX.exec(fieldText)) {\r\n        // console.log(`  checkTNLinksToOutside TA resultArray=${JSON.stringify(resultArray)}`);\r\n        taLinkCount += 1;\r\n        console.assert(regexResultArray.length === 4, `Expected 4 fields (not ${regexResultArray.length})`)\r\n        let languageCode = regexResultArray[1];\r\n        if (languageCode !== '*') {\r\n            const characterIndex = TA_REGEX.lastIndex - regexResultArray[0].length + 7; // lastIndex points to the end of the field that was found\r\n            const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n            addNoticePartial({ priority: 450, message: \"Resource container link should have '*' language code\", details: `not '${languageCode}'`, characterIndex, extract, location: ourLocation });\r\n        } else { // At the moment, tC cant handle these links with * so we have to ensure that they're not there\r\n            const characterIndex = TA_REGEX.lastIndex - regexResultArray[0].length + 7; // lastIndex points to the end of the field that was found\r\n            const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '')\r\n            addNoticePartial({ priority: 950, message: \"tC cannot yet process '*' language code\", characterIndex, extract, location: ourLocation });\r\n        }\r\n        if (!languageCode || languageCode === '*') languageCode = defaultLanguageCode;\r\n        const taRepoName = `${languageCode}_ta`;\r\n        // console.log(`Got taRepoName=${taRepoName}`);\r\n        const filepath = `${regexResultArray[2]}/${regexResultArray[3]}/01.md`; // Other files are title.md, sub-title.md\r\n        // console.log(`Got tA filepath=${filepath}`);\r\n\r\n        if (!checkingOptions?.disableAllLinkFetchingFlag) {\r\n            // console.log(`Need to check against ${taRepoName}`);\r\n            const taPathParameters = { username: taRepoUsername, repository: taRepoName, path: filepath, branch: taRepoBranch };\r\n            let taFileContent;\r\n            try {\r\n                taFileContent = await getFile_(taPathParameters);\r\n                // console.log(\"Fetched fileContent for\", taRepoName, filepath, typeof fileContent, fileContent.length);\r\n            } catch (trcGCerror) {\r\n                // console.error(`checkTNLinksToOutside(${bookID}, ${fieldName}, ) failed to load TA for '${taRepoUsername}', '${taRepoName}', '${filepath}', '${taRepoBranch}', ${trcGCerror.message}`);\r\n                addNoticePartial({ priority: 885, message: `Error loading ${fieldName} TA link`, extract: regexResultArray[0], location: `${ourLocation} ${filepath}: ${trcGCerror}` });\r\n            }\r\n            if (!taFileContent)\r\n                addNoticePartial({ priority: 886, message: `Unable to find ${fieldName} TA link`, extract: regexResultArray[0], location: `${ourLocation} ${filepath}` });\r\n            else if (taFileContent.length < 10)\r\n                addNoticePartial({ priority: 884, message: `Linked ${fieldName} TA article seems empty`, extract: regexResultArray[0], location: `${ourLocation} ${filepath}` });\r\n            else if (checkingOptions?.checkLinkedTAArticleFlag === true) {\r\n                // console.log(`checkTNLinksToOutside got ${checkingOptions?.checkLinkedTAArticleFlag} so checking TA article: ${filepath}`);\r\n                if (await alreadyChecked(taPathParameters) !== true) {\r\n                    // console.log(`checkTNLinksToOutside needs to check TA article: ${filepath}`);\r\n                    const checkTAFileResult = await checkMarkdownText(languageCode, `TA ${regexResultArray[3]}.md`, taFileContent, ourLocation, checkingOptions);\r\n                    for (const noticeObject of checkTAFileResult.noticeList)\r\n                        ctarResult.noticeList.push({ ...noticeObject, username: taRepoUsername, repoCode: 'TA', repoName: taRepoName, filename: filepath, location: ` linked to${ourLocation}`, extra: 'TA' });\r\n                    ctarResult.checkedFileCount += 1;\r\n                    ctarResult.checkedFilenames.push(`${regexResultArray[3]}.md`);\r\n                    ctarResult.checkedFilesizes = taFileContent.length;\r\n                    ctarResult.checkedFilenameExtensions = ['md'];\r\n                    ctarResult.checkedRepoNames.push(taRepoName);\r\n                    markAsChecked(taPathParameters); // dont bother waiting for the result\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check TW links like [[rc://en/tw/dict/bible/other/death]]\r\n    //  (These are not nearly as many as TA links.)\r\n    // console.log(\"checkTNLinksToOutside: Search for TW links\")\r\n    // eslint-disable-next-line no-cond-assign\r\n    while (regexResultArray = TW_REGEX.exec(fieldText)) {\r\n        // console.log(`  checkTNLinksToOutside TW resultArray=${JSON.stringify(resultArray)}`);\r\n        twLinkCount += 1;\r\n        console.assert(regexResultArray.length === 4, `Expected 4 fields (not ${regexResultArray.length})`)\r\n        let languageCode = regexResultArray[1];\r\n        if (!languageCode || languageCode === '*') languageCode = defaultLanguageCode;\r\n        const twRepoName = `${languageCode}_tw`;\r\n        // console.log(`Got twRepoName=${twRepoName}`);\r\n        const filepath = `bible/${regexResultArray[2]}/${regexResultArray[3]}.md`; // Other files are title.md, sub-title.md\r\n        // console.log(`Got tW filepath=${filepath}`);\r\n\r\n        if (!checkingOptions?.disableAllLinkFetchingFlag) {\r\n            // console.log(`Need to check against ${twRepoName}`);\r\n            const twPathParameters = { username: twRepoUsername, repository: twRepoName, path: filepath, branch: twRepoBranch };\r\n            let twFileContent;\r\n            try {\r\n                twFileContent = await getFile_(twPathParameters);\r\n                // console.log(\"Fetched fileContent for\", twRepoName, filepath, typeof fileContent, fileContent.length);\r\n            } catch (trcGCerror) {\r\n                console.error(`checkTNLinksToOutside(${bookID}, ${fieldName}, ) failed to load TW`, twRepoUsername, twRepoName, filepath, twRepoBranch, trcGCerror.message);\r\n                addNoticePartial({ priority: 882, message: `Error loading ${fieldName} TW link`, extract: regexResultArray[0], location: `${ourLocation} ${filepath}: ${trcGCerror}` });\r\n            }\r\n            if (!twFileContent)\r\n                addNoticePartial({ priority: 883, message: `Unable to find ${fieldName} TW link`, extract: regexResultArray[0], location: `${ourLocation} ${filepath}` });\r\n            else { // we got the content of the TW article\r\n                if (twFileContent.length < 10)\r\n                    addNoticePartial({ priority: 881, message: `Linked ${fieldName} TW article seems empty`, extract: regexResultArray[0], location: `${ourLocation} ${filepath}` });\r\n                else if (checkingOptions?.checkLinkedTWArticleFlag === true) {\r\n                    // console.log(`checkTNLinksToOutside got ${checkingOptions?.checkLinkedTWArticleFlag} so checking TW article: ${filepath}`);\r\n                    if (await alreadyChecked(twPathParameters) !== true) {\r\n                        // console.log(`checkTNLinksToOutside needs to check TW article: ${filepath}`);\r\n                        const checkTWFileResult = await checkMarkdownText(languageCode, `TW ${regexResultArray[3]}.md`, twFileContent, ourLocation, checkingOptions);\r\n                        for (const noticeObject of checkTWFileResult.noticeList)\r\n                            ctarResult.noticeList.push({ ...noticeObject, username: twRepoUsername, repoCode: 'TW', repoName: twRepoName, filename: filepath, location: ` linked to${ourLocation}`, extra: 'TW' });\r\n                        ctarResult.checkedFileCount += 1;\r\n                        ctarResult.checkedFilenames.push(`${regexResultArray[3]}.md`);\r\n                        ctarResult.checkedFilesizes = twFileContent.length;\r\n                        ctarResult.checkedFilenameExtensions = ['md'];\r\n                        ctarResult.checkedRepoNames.push(twRepoName);\r\n                        markAsChecked(twPathParameters); // dont bother waiting for the result\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // console.log(\"checkTNLinksToOutside: Search for Bible links\")\r\n\r\n    // Check this chapter Bible links like [Revelation 3:11](./11.md)\r\n    // eslint-disable-next-line no-cond-assign\r\n    while (regexResultArray = THIS_CHAPTER_BIBLE_REGEX.exec(fieldText)) {\r\n        // console.log(`  checkTNLinksToOutside THIS_CHAPTER_BIBLE_REGEX regexResultArray=${JSON.stringify(regexResultArray)}`);\r\n        thisChapterBibleLinkCount += 1;\r\n        console.assert(regexResultArray.length === 6, `Expected 6 fields (not ${regexResultArray.length})`);\r\n        let [totalLink, optionalN1, optionalB1, C1, V1, V2] = regexResultArray;\r\n\r\n        if (optionalN1) console.assert(optionalB1, `Should have book name as well as number '${optionalN1}'`);\r\n        if (optionalB1) {\r\n            optionalB1 = `${optionalN1}${optionalB1}`.trim(); // e.g., 1 Timothy\r\n            if (defaultLanguageCode === 'en') { // should be able to check the book name\r\n                const checkResult = books.isGoodEnglishBookName(optionalB1);\r\n                // console.log(optionalB1, \"isGoodEnglishBookName checkResult\", checkResult);\r\n                if (checkResult === undefined || checkResult === false)\r\n                    addNoticePartial({ priority: 143, message: \"Unknown Bible book name in link\", details: totalLink, extract: optionalB1, location: ourLocation });\r\n            }\r\n        }\r\n\r\n        let linkBookCode = bookID;\r\n\r\n        const chapterInt = ourParseInt(givenC), verseInt = ourParseInt(V2);\r\n        try {\r\n            if (ourParseInt(C1) !== chapterInt)\r\n                addNoticePartial({ priority: 743, message: \"Chapter numbers of markdown Bible link dont match\", details: `${C1} vs ${chapterInt}`, extract: totalLink, location: ourLocation });\r\n        } catch (ccError) {\r\n            console.error(`TN Link Check couldnt compare chapter numbers: ${ccError}`);\r\n        }\r\n        try {\r\n            if (ourParseInt(V1) !== ourParseInt(verseInt))\r\n                addNoticePartial({ priority: 742, message: \"Verse numbers of markdown Bible link dont match\", details: `${V1} vs ${verseInt}`, extract: totalLink, location: ourLocation });\r\n        } catch (vvError) {\r\n            console.error(`TN Link Check couldnt compare verse numbers: ${vvError}`);\r\n        }\r\n\r\n        if (linkBookCode) { // then we know which Bible book this link is to\r\n            // So we can check for valid C:V numbers\r\n            let numChaptersThisBook, numVersesThisChapter;\r\n            console.assert(linkBookCode.toLowerCase() !== 'obs', \"Shouldnt happen in tn-links-check\");\r\n            try {\r\n                numChaptersThisBook = books.chaptersInBook(linkBookCode.toLowerCase()).length;\r\n            } catch (tlcNCerror) { }\r\n            try {\r\n                numVersesThisChapter = books.versesInChapter(linkBookCode.toLowerCase(), chapterInt);\r\n            } catch (tlcNVerror) { }\r\n            if (!chapterInt || chapterInt < 1 || chapterInt > numChaptersThisBook)\r\n                addNoticePartial({ priority: 655, message: \"Bad chapter number in markdown Bible link\", details: `${linkBookCode} ${chapterInt} vs ${numChaptersThisBook} chapters`, extract: totalLink, location: ourLocation });\r\n            else if (!verseInt || verseInt < 0 || verseInt > numVersesThisChapter)\r\n                addNoticePartial({ priority: 653, message: \"Bad verse number in markdown Bible link\", details: `${linkBookCode} ${chapterInt}:${verseInt} vs ${numVersesThisChapter} verses`, extract: totalLink, location: ourLocation });\r\n        }\r\n    }\r\n\r\n    // Check this book Bible links like [Revelation 3:11](../03/11.md)\r\n    // eslint-disable-next-line no-cond-assign\r\n    while (regexResultArray = THIS_BOOK_BIBLE_REGEX.exec(fieldText)) {\r\n        // console.log(`  checkTNLinksToOutside THIS_BOOK_BIBLE_REGEX regexResultArray=${JSON.stringify(regexResultArray)}`);\r\n        thisBookBibleLinkCount += 1;\r\n        console.assert(regexResultArray.length === 8, `Expected 8 fields (not ${regexResultArray.length})`);\r\n        let [totalLink, optionalN1, optionalB1, C1, V1, B2, C2, V2] = regexResultArray;\r\n\r\n        if (optionalN1) console.assert(optionalB1, `Should have book name as well as number '${optionalN1}'`);\r\n        if (optionalB1) {\r\n            optionalB1 = `${optionalN1}${optionalB1}`.trim(); // e.g., 1 Timothy\r\n            if (defaultLanguageCode === 'en') { // should be able to check the book name\r\n                const checkResult = books.isGoodEnglishBookName(optionalB1);\r\n                // console.log(optionalB1, \"isGoodEnglishBookName checkResult\", checkResult);\r\n                if (checkResult === undefined || checkResult === false)\r\n                    addNoticePartial({ priority: 143, message: \"Unknown Bible book name in link\", details: totalLink, extract: optionalB1, location: ourLocation });\r\n            }\r\n        }\r\n\r\n        let linkBookCode = B2 === '..' ? bookID : B2;\r\n\r\n        const chapterInt = ourParseInt(C2), verseInt = ourParseInt(V2);\r\n        try {\r\n            if (ourParseInt(C1) !== chapterInt)\r\n                addNoticePartial({ priority: 743, message: \"Chapter numbers of markdown Bible link dont match\", details: `${C1} vs ${chapterInt}`, extract: totalLink, location: ourLocation });\r\n        } catch (ccError) {\r\n            console.error(`TN Link Check couldnt compare chapter numbers: ${ccError}`);\r\n        }\r\n        try {\r\n            if (ourParseInt(V1) !== ourParseInt(verseInt))\r\n                addNoticePartial({ priority: 742, message: \"Verse numbers of markdown Bible link dont match\", details: `${V1} vs ${verseInt}`, extract: totalLink, location: ourLocation });\r\n        } catch (vvError) {\r\n            console.error(`TN Link Check couldnt compare verse numbers: ${vvError}`);\r\n        }\r\n\r\n        if (linkBookCode) { // then we know which Bible book this link is to\r\n            // So we can check for valid C:V numbers\r\n            let numChaptersThisBook, numVersesThisChapter;\r\n            console.assert(linkBookCode.toLowerCase() !== 'obs', \"Shouldnt happen in tn-links-check\");\r\n            try {\r\n                numChaptersThisBook = books.chaptersInBook(linkBookCode.toLowerCase()).length;\r\n            } catch (tlcNCerror) { }\r\n            try {\r\n                numVersesThisChapter = books.versesInChapter(linkBookCode.toLowerCase(), chapterInt);\r\n            } catch (tlcNVerror) { }\r\n            if (!chapterInt || chapterInt < 1 || chapterInt > numChaptersThisBook)\r\n                addNoticePartial({ priority: 655, message: \"Bad chapter number in markdown Bible link\", details: `${linkBookCode} ${chapterInt} vs ${numChaptersThisBook} chapters`, extract: totalLink, location: ourLocation });\r\n            else if (!verseInt || verseInt < 0 || verseInt > numVersesThisChapter)\r\n                addNoticePartial({ priority: 653, message: \"Bad verse number in markdown Bible link\", details: `${linkBookCode} ${chapterInt}:${verseInt} vs ${numVersesThisChapter} verses`, extract: totalLink, location: ourLocation });\r\n        }\r\n    }\r\n\r\n    // Check other book Bible links like [Revelation 3:11](../03/11.md)\r\n    // eslint-disable-next-line no-cond-assign\r\n    while (regexResultArray = OTHER_BOOK_BIBLE_REGEX.exec(fieldText)) {\r\n        console.log(`  checkTNLinksToOutside OTHER_BOOK_BIBLE_REGEX regexResultArray=${JSON.stringify(regexResultArray)}`);\r\n        otherBookBibleLinkCount += 1;\r\n        console.assert(regexResultArray.length === 8, `Expected 8 fields (not ${regexResultArray.length})`);\r\n        let [totalLink, optionalN1, optionalB1, C1, V1, B2, C2, V2] = regexResultArray;\r\n\r\n        if (optionalN1) console.assert(optionalB1, `Should have book name as well as number '${optionalN1}'`);\r\n        if (optionalB1) {\r\n            optionalB1 = `${optionalN1}${optionalB1}`.trim(); // e.g., 1 Timothy\r\n            if (defaultLanguageCode === 'en') { // should be able to check the book name\r\n                const checkResult = books.isGoodEnglishBookName(optionalB1);\r\n                // console.log(optionalB1, \"isGoodEnglishBookName checkResult\", checkResult);\r\n                if (checkResult === undefined || checkResult === false)\r\n                    addNoticePartial({ priority: 143, message: \"Unknown Bible book name in link\", details: totalLink, extract: optionalB1, location: ourLocation });\r\n            }\r\n        }\r\n\r\n        let linkBookCode = B2 === '..' ? bookID : B2;\r\n\r\n        const chapterInt = ourParseInt(C2), verseInt = ourParseInt(V2);\r\n        try {\r\n            if (ourParseInt(C1) !== chapterInt)\r\n                addNoticePartial({ priority: 743, message: \"Chapter numbers of markdown Bible link dont match\", details: `${C1} vs ${chapterInt}`, extract: totalLink, location: ourLocation });\r\n        } catch (ccError) {\r\n            console.error(`TN Link Check couldnt compare chapter numbers: ${ccError}`);\r\n        }\r\n        try {\r\n            if (ourParseInt(V1) !== ourParseInt(verseInt))\r\n                addNoticePartial({ priority: 742, message: \"Verse numbers of markdown Bible link dont match\", details: `${V1} vs ${verseInt}`, extract: totalLink, location: ourLocation });\r\n        } catch (vvError) {\r\n            console.error(`TN Link Check couldnt compare verse numbers: ${vvError}`);\r\n        }\r\n\r\n        if (linkBookCode) { // then we know which Bible book this link is to\r\n            // So we can check for valid C:V numbers\r\n            let numChaptersThisBook, numVersesThisChapter;\r\n            console.assert(linkBookCode.toLowerCase() !== 'obs', \"Shouldnt happen in tn-links-check\");\r\n            try {\r\n                numChaptersThisBook = books.chaptersInBook(linkBookCode.toLowerCase()).length;\r\n            } catch (tlcNCerror) { }\r\n            try {\r\n                numVersesThisChapter = books.versesInChapter(linkBookCode.toLowerCase(), chapterInt);\r\n            } catch (tlcNVerror) { }\r\n            if (!chapterInt || chapterInt < 1 || chapterInt > numChaptersThisBook)\r\n                addNoticePartial({ priority: 655, message: \"Bad chapter number in markdown Bible link\", details: `${linkBookCode} ${chapterInt} vs ${numChaptersThisBook} chapters`, extract: totalLink, location: ourLocation });\r\n            else if (!verseInt || verseInt < 0 || verseInt > numVersesThisChapter)\r\n                addNoticePartial({ priority: 653, message: \"Bad verse number in markdown Bible link\", details: `${linkBookCode} ${chapterInt}:${verseInt} vs ${numVersesThisChapter} verses`, extract: totalLink, location: ourLocation });\r\n        }\r\n    }\r\n\r\n    // Check for additional links that we cant explain\r\n    const BibleLinkCount = thisChapterBibleLinkCount + thisBookBibleLinkCount + otherBookBibleLinkCount;\r\n    if (totalLinks1 > BibleLinkCount)\r\n        addNoticePartial({ priority: 648, message: \"More [ ]( ) links than valid Bible links\", details: `detected ${totalLinks1} link${totalLinks1 === 1 ? '' : 's'} but ${BibleLinkCount ? `only ${BibleLinkCount}` : 'no'} Bible link${BibleLinkCount === 1 ? '' : 's'} from ${JSON.stringify(linksList1)}`, location: ourLocation });\r\n    const twaLinkCount = twLinkCount + taLinkCount;\r\n    if (totalLinks2 > twaLinkCount)\r\n        addNoticePartial({ priority: 649, message: \"More [[ ]] links than valid TA/TW links\", details: `detected ${totalLinks2} link${totalLinks2 === 1 ? '' : 's'} but ${twaLinkCount ? `only ${twaLinkCount}` : 'no'} TA/TW link${twaLinkCount === 1 ? '' : 's'} from ${JSON.stringify(linksList2)}`, location: ourLocation });\r\n\r\n    // Check for badly formed links (not processed by the above code)\r\n    // Check for badly formed [[ ]] links\r\n    let leftCount = countOccurrences(fieldText, '[[');\r\n    let rightCount = countOccurrences(fieldText, ']]');\r\n    if (leftCount !== rightCount)\r\n        addNoticePartial({ priority: 845, message: `Mismatched [[ ]] link characters`, details: `left=${leftCount.toLocaleString()}, right=${rightCount.toLocaleString()}`, location: ourLocation });\r\n    else {\r\n        leftCount = countOccurrences(fieldText, '[[rc://');\r\n        if (leftCount !== rightCount)\r\n            addNoticePartial({ priority: 844, message: `Mismatched [[rc:// ]] link characters`, details: `left=${leftCount.toLocaleString()}, right=${rightCount.toLocaleString()}`, location: ourLocation });\r\n    }\r\n    // Check for badly formed [ ]( ) links\r\n    leftCount = countOccurrences(fieldText, '[');\r\n    const middleCount = countOccurrences(fieldText, '](');\r\n    rightCount = countOccurrences(fieldText, ')');\r\n    if (leftCount < middleCount || rightCount < middleCount)\r\n        addNoticePartial({ priority: 843, message: `Mismatched [ ]( ) link characters`, details: `left=${leftCount.toLocaleString()}, middle=${middleCount.toLocaleString()}, right=${rightCount.toLocaleString()}`, location: ourLocation });\r\n\r\n\r\n    // console.log(`checkTNLinksToOutside is returning ${JSON.stringify(ctarResult)}`);\r\n    return ctarResult;\r\n}\r\n// end of checkTNLinksToOutside function\r\n","import { DEFAULT_EXTRACT_LENGTH } from './text-handling-functions'\r\nimport { checkTextField } from './field-text-check';\r\nimport { cachedGetFileUsingFullURL } from '../core/getApi';\r\nimport { removeDisabledNotices } from './disabled-notices';\r\n\r\n\r\nconst MARKDOWN_TEXT_VALIDATOR_VERSION_STRING = '0.4.3';\r\n\r\nconst IMAGE_REGEX = new RegExp('!\\\\[([^\\\\]]+?)\\\\]\\\\(([^ \\\\]]+?)\\\\)', 'g');\r\n\r\n\r\n/**\r\n *\r\n * @param {string} languageCode\r\n * @param {string} textOrFileName -- used for identification\r\n * @param {string} markdownText -- the actual text to be checked\r\n * @param {string} givenLocation\r\n * @param {Object} checkingOptions\r\n */\r\nexport async function checkMarkdownText(languageCode, textOrFileName, markdownText, givenLocation, checkingOptions) {\r\n    /* This function is optimised for checking the entire markdown text, i.e., all lines.\r\n\r\n    This text may not necessarily be from a file -- it may be from a (multiline) field within a file\r\n\r\n    Note: This function does not check that any link targets in the markdown are valid links.\r\n\r\n     Returns a result object containing a successList and a noticeList\r\n     */\r\n    // console.log(`checkMarkdownText(${textName}, ${markdownText.length}, ${givenLocation})`);\r\n    console.assert(languageCode !== undefined, \"checkMarkdownText: 'languageCode' parameter should be defined\");\r\n    console.assert(typeof languageCode === 'string', `checkMarkdownText: 'languageCode' parameter should be a string not a '${typeof languageCode}': ${languageCode}`);\r\n    console.assert(textOrFileName !== undefined, \"checkMarkdownText: 'textOrFileName' parameter should be defined\");\r\n    console.assert(typeof textOrFileName === 'string', `checkMarkdownText: 'textOrFileName' parameter should be a string not a '${typeof textOrFileName}': ${textOrFileName}`);\r\n    console.assert(markdownText !== undefined, \"checkMarkdownText: 'markdownText' parameter should be defined\");\r\n    console.assert(typeof markdownText === 'string', `checkMarkdownText: 'markdownText' parameter should be a string not a '${typeof markdownText}': ${markdownText}`);\r\n    console.assert(givenLocation !== undefined, \"checkMarkdownText: 'optionalFieldLocation' parameter should be defined\");\r\n    console.assert(typeof givenLocation === 'string', `checkMarkdownText: 'optionalFieldLocation' parameter should be a string not a '${typeof givenLocation}': ${givenLocation}`);\r\n    console.assert(givenLocation.indexOf('true') === -1, `checkMarkdownText: 'optionalFieldLocation' parameter should not be '${givenLocation}'`);\r\n    console.assert(checkingOptions !== undefined, \"checkMarkdownText: 'checkingOptions' parameter should be defined\");\r\n    if (checkingOptions !== undefined)\r\n        console.assert(typeof checkingOptions === 'object', `checkMarkdownText: 'checkingOptions' parameter should be an object not a '${typeof checkingOptions}': ${JSON.stringify(checkingOptions)}`);\r\n\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (mdtcError) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(\"Using default extractLength=\" + extractLength);\r\n    }\r\n    // else\r\n    // console.log(\"Using supplied extractLength=\" + extractLength, `cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    // const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    // const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(\"Using halfLength=\" + halfLength, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n    const result = { successList: [], noticeList: [] };\r\n\r\n    function addSuccessMessage(successString) {\r\n        // console.log(\"checkMarkdownText success: \" + successString);\r\n        result.successList.push(successString);\r\n    }\r\n    function addNotice(noticeObject) {\r\n        // console.log(`checkMarkdownText addNotice: (priority=${noticeObject.priority}) ${noticeObject.message}${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : \"\"}${noticeObject.extract ? \" \" + extract : \"\"}${noticeObject.location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"cMdT addNotice: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `cMdT addNotice: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"cMdT addNotice: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `cMdT addNotice: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(characterIndex !== undefined, \"cMdT addNotice: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cMdT addNotice: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract !== undefined, \"cMdT addNotice: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cMdT addNotice: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"cMdT addNotice: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `cMdT addNotice: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n\r\n        // noticeObject.debugChain = noticeObject.debugChain ? `checkMarkdownText(${languageCode}, ${textOrFileName}) ${noticeObject.debugChain}` : `checkMarkdownText(${languageCode}, ${textOrFileName})`;\r\n        result.noticeList.push(noticeObject); // Used to have filename: textName, but that isnt always a filename !!!\r\n    }\r\n    // end of addNotice function\r\n\r\n    function ourCheckTextField(fieldName, lineNumber, fieldText, allowedLinks, optionalFieldLocation, checkingOptions) {\r\n        /**\r\n        * @description - checks the given text field and processes the returned results\r\n        * @param {String} fieldName - name of the field being checked\r\n        * @param {String} fieldText - the actual text of the field being checked\r\n        * @param {boolean} allowedLinks - true if links are allowed in the field, otherwise false\r\n        * @param {String} optionalFieldLocation - description of where the field is located\r\n        * @param {Object} checkingOptions - parameters that might affect the check\r\n        */\r\n        // Does basic checks for small errors like leading/trailing spaces, etc.\r\n\r\n        // We assume that checking for compulsory fields is done elsewhere\r\n\r\n        // Updates the global list of notices\r\n        // console.log(`cMdT ourCheckTextField(${fieldName}, (${fieldText.length}), ${allowedLinks}, ${optionalFieldLocation}, )`);\r\n        console.assert(fieldName !== undefined, \"cMdT ourCheckTextField: 'fieldName' parameter should be defined\");\r\n        console.assert(typeof fieldName === 'string', `cMdT ourCheckTextField: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);\r\n        console.assert(lineNumber !== undefined, \"cMdT ourCheckTextField: 'lineNumber' parameter should be defined\");\r\n        console.assert(typeof lineNumber === 'number', `cMdT ourCheckTextField: 'lineNumber' parameter should be a number not a '${typeof lineNumber}'`);\r\n        console.assert(fieldText !== undefined, \"cMdT ourCheckTextField: 'fieldText' parameter should be defined\");\r\n        console.assert(typeof fieldText === 'string', `cMdT ourCheckTextField: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);\r\n        console.assert(allowedLinks === true || allowedLinks === false, \"cMdT ourCheckTextField: allowedLinks parameter must be either true or false\");\r\n        console.assert(optionalFieldLocation !== undefined, \"cMdT ourCheckTextField: 'optionalFieldLocation' parameter should be defined\");\r\n        console.assert(typeof optionalFieldLocation === 'string', `cMdT ourCheckTextField: 'optionalFieldLocation' parameter should be a string not a '${typeof optionalFieldLocation}'`);\r\n\r\n        const dbtcResultObject = checkTextField('markdown', fieldName, fieldText, allowedLinks, optionalFieldLocation, checkingOptions);\r\n\r\n        // If we need to put everything through addNotice, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const noticeEntry of dbtcResultObject.noticeList)\r\n            addNotice({ ...noticeEntry, lineNumber });\r\n        return dbtcResultObject.suggestion; // There may or may not be one!\r\n    }\r\n    // end of ourCheckTextField function\r\n\r\n\r\n    /**\r\n     *\r\n     * @param {string} lineNumber\r\n     * @param {string} lineText -- text to be checked\r\n     * @param {string} lineLocation\r\n     * @returns {string} suggestion (may be undefined) -- suggested fixed replacement field\r\n     */\r\n    async function checkMarkdownLineContents(lineNumber, lineText, lineLocation) {\r\n\r\n        // console.log(`checkMarkdownLineContents for ${lineNumber} '${lineText}' at${lineLocation}`);\r\n\r\n        // Check for image links\r\n        let regexResultArray;\r\n        // eslint-disable-next-line no-cond-assign\r\n        while (regexResultArray = IMAGE_REGEX.exec(lineText)) {\r\n            // console.log(`Got markdown image in line ${lineNumber}:`, JSON.stringify(regexResultArray));\r\n            if (regexResultArray[1] !== 'OBS Image') console.log(\"This code was only checked for 'OBS Image' links\");\r\n            const fetchLink = regexResultArray[2];\r\n            if (!fetchLink.startsWith('https://'))\r\n                addNotice({ priority: 749, message: \"Markdown image link seems faulty\", lineNumber, extract: fetchLink, location: lineLocation });\r\n            else if (checkingOptions?.disableAllLinkFetchingFlag !== true) {\r\n                // console.log(`Need to check existence of ${fetchLink}`);\r\n                try {\r\n                    const responseData = await cachedGetFileUsingFullURL({ uri: fetchLink });\r\n                    console.assert(responseData.length > 10, `Expected ${fetchLink} image file to be longer: ${responseData.length}`);\r\n                    // console.log(\"Markdown link fetch got response: \", responseData.length);\r\n                } catch (flError) {\r\n                    console.error(`Markdown image link fetch had an error fetching '${fetchLink}': ${flError}`);\r\n                    addNotice({ priority: 748, message: \"Error fetching markdown image link\", lineNumber, extract: fetchLink, location: lineLocation });\r\n                }\r\n            }\r\n        }\r\n\r\n        let thisText = lineText; // so we can adjust it\r\n\r\n        // Remove leading and trailing hash signs #\r\n        thisText = thisText.replace(/^#+|#+$/g, '');\r\n        // console.log(`After removing hashes have '${thisText}'`);\r\n\r\n        // Remove leading spaces\r\n        thisText = thisText.replace(/^ +/g, '');\r\n\r\n        // Remove leading block text markers >\r\n        while (thisText.startsWith('>'))\r\n            thisText = thisText.replace(/^>+ */g, '');\r\n        // if (thisText.indexOf('>') >= 0) console.log(`After removing leading block text markers from '${lineText}' still have '${thisText}'`);\r\n\r\n        // Remove leading spaces again\r\n        // thisText = thisText.replace(/^ +/g, '');\r\n        // console.log(`After removing leading spaces have '${thisText}'`);\r\n\r\n        // // Remove leading asterisks\r\n        // thisText = thisText.replace(/^\\*/g,'')\r\n        // console.log(`After removing asterisks have '${thisText}'`);\r\n\r\n        // // Remove leading spaces again now\r\n        // thisText = thisText.replace(/^ +/g,'')\r\n        // console.log(`After removing more leading spaces have '${thisText}'`);\r\n\r\n        let suggestion;\r\n        if (thisText && lineText[0] !== '|') // Doesnt really make sense to check table line entries\r\n            suggestion = ourCheckTextField(textOrFileName, lineNumber, thisText, true, lineLocation, checkingOptions);\r\n\r\n        if (thisText === lineText) // i.e., we didnt premodify the field being checked (otherwise suggestion could be wrong)\r\n            return suggestion;\r\n    }\r\n    // end of checkMarkdownLine function\r\n\r\n\r\n    // Main code for checkMarkdownText function\r\n    const lines = markdownText.split('\\n');\r\n    // console.log(`  '${location}' has ${lines.length.toLocaleString()} total lines`);\r\n\r\n    let headerLevel = 0;\r\n    let lastNumLeadingSpaces = 0;\r\n    // let lastLineContents;\r\n    const suggestedLines = [];\r\n    for (let n = 1; n <= lines.length; n++) {\r\n\r\n        const line = lines[n - 1];\r\n        let numLeadingSpaces;\r\n        if (line) {\r\n\r\n            const thisHeaderLevel = line.match(/^#*/)[0].length;\r\n            // console.log(`Got thisHeaderLevel=${thisHeaderLevel} for ${line}${atString}`);\r\n            if (thisHeaderLevel > headerLevel + 1\r\n                && !textOrFileName.startsWith('TA ')) // Suppress this notice for translationAcademy subsections\r\n                addNotice({ priority: 172, message: \"Header levels should only increment by one\", lineNumber: n, characterIndex: 0, location: ourLocation });\r\n            if (thisHeaderLevel > 0)\r\n                headerLevel = thisHeaderLevel;\r\n\r\n            numLeadingSpaces = line.match(/^ */)[0].length;\r\n            // console.log(`Got numLeadingSpaces=${numLeadingSpaces} for ${line}${atString}`);\r\n            if (numLeadingSpaces && lastNumLeadingSpaces && numLeadingSpaces !== lastNumLeadingSpaces)\r\n                addNotice({ priority: 472, message: \"Nesting of header levels seems confused\", lineNumber: n, characterIndex: 0, location: ourLocation });\r\n\r\n            const suggestedLine = await checkMarkdownLineContents(n, line, ourLocation);\r\n            suggestedLines.push(suggestedLine === undefined ? line : suggestedLine);\r\n        } else {\r\n            // This is a blank line\r\n            numLeadingSpaces = 0;\r\n            suggestedLines.push('');\r\n        }\r\n\r\n        // lastLineContents = line;\r\n        lastNumLeadingSpaces = numLeadingSpaces;\r\n    }\r\n\r\n    const suggestion = suggestedLines.join('\\n');\r\n    if (suggestion !== markdownText) {\r\n        // console.log(`Had markdown ${markdownText}`);\r\n        // console.log(`Sug markdown ${suggestion}`);\r\n        result.suggestion = suggestion;\r\n    }\r\n\r\n    if (!checkingOptions?.suppressNoticeDisablingFlag) {\r\n        // console.log(`checkMarkdownText: calling removeDisabledNotices(${result.noticeList.length}) having ${JSON.stringify(checkingOptions)}`);\r\n        result.noticeList = removeDisabledNotices(result.noticeList);\r\n    }\r\n\r\n    addSuccessMessage(`Checked all ${lines.length.toLocaleString()} line${lines.length === 1 ? '' : 's'}${ourLocation}.`);\r\n    if (result.noticeList)\r\n        addSuccessMessage(`checkMarkdownText v${MARKDOWN_TEXT_VALIDATOR_VERSION_STRING} finished with ${result.noticeList.length ? result.noticeList.length.toLocaleString() : \"zero\"} notice${result.noticeList.length === 1 ? '' : 's'}`);\r\n    else\r\n        addSuccessMessage(`No errors or warnings found by checkMarkdownText v${MARKDOWN_TEXT_VALIDATOR_VERSION_STRING}`)\r\n    // console.log(`  checkMarkdownText returning with ${result.successList.length.toLocaleString()} success(es), ${result.noticeList.length.toLocaleString()} notice(s).`);\r\n    if (textOrFileName.endsWith('walk.md'))\r\n        console.log(\"checkMarkdownText result is\", JSON.stringify(result));\r\n    return result;\r\n}\r\n// end of checkMarkdownText function\r\n","import { checkPlainText } from './plain-text-check';\r\n\r\n// const FILE_TEXT_VALIDATOR_VERSION_STRING = '0.3.0';\r\n\r\n\r\nexport function checkTextfileContents(languageCode, fileType, filename, fileText, optionalFileLocation, checkingOptions) {\r\n    // Does basic checks for small errors like mismatched punctuation pairs, etc.\r\n    //  (Used by ourBasicFileChecks() in checkUSFMText() in usfm-text-check.js)\r\n\r\n    // filename (str): Used for identification\r\n    // fileText (str): The field being checked\r\n    // optionalFileLocation (str): Used to inform where this field is located\r\n\r\n    // We assume that checking for compulsory fields is done elsewhere\r\n\r\n    // Returns a single notice list\r\n    //  The list contains objects with the following fields:\r\n    //      priority (compulsory): the priority number 0..999 (usually 800+ are errors, lower are warnings)\r\n    //      message (compulsory): the error description string\r\n    //      characterIndeX: the 0-based index for the position in the string\r\n    //      extract: a short extract of the string containing the error (or empty-string if irrelevant)\r\n    //  (Returned in this way for more intelligent processing at a higher level)\r\n    // console.log(`checkTextfileContents(${filename}, ${fileText.length.toLocaleString()} chars, '${optionalFileLocation}')`);\r\n    console.assert(languageCode !== undefined, \"checkTextfileContents: 'languageCode' parameter should be defined\");\r\n    console.assert(typeof languageCode === 'string', `checkTextfileContents: 'languageCode' parameter should be a string not a '${typeof languageCode}': ${languageCode}`);\r\n    console.assert(fileType !== undefined, \"checkTextfileContents: 'fileType' parameter should be defined\");\r\n    console.assert(typeof fileType === 'string', `checkTextfileContents: 'fileType' parameter should be a string not a '${typeof fileType}': ${fileType}`);\r\n    console.assert(fileType !== '', `checkTextfileContents: 'fileType' ${fileType} parameter should be not be an empty string`);\r\n    console.assert(fileType === 'markdown' || fileType === 'USFM' || fileType === 'YAML' || fileType === 'text', `checkTextfileContents: unrecognised 'fileType' parameter: '${fileType}'`);\r\n    console.assert(filename !== undefined, \"checkTextfileContents: 'filename' parameter should be defined\");\r\n    console.assert(typeof filename === 'string', `checkTextfileContents: 'filename' parameter should be a string not a '${typeof filename}': ${filename}`);\r\n    console.assert(fileText !== undefined, \"checkTextfileContents: 'fileText' parameter should be defined\");\r\n    console.assert(typeof fileText === 'string', `checkTextfileContents: 'fileText' parameter should be a string not a '${typeof fileText}': ${fileText}`);\r\n    console.assert(checkingOptions !== undefined, \"checkTextfileContents: 'checkingOptions' parameter should be defined\");\r\n\r\n    let result = { noticeList: [] };\r\n\r\n    function addNotice(noticeObject) {\r\n        // console.log(`dBTC Notice: (priority=${noticeObject.priority}) ${noticeObject.message}${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : \"\"}${noticeObject.extract ? ` ${noticeObject.extract}` : \"\"}${noticeObject.location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"dBTCs addNotice: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `dBTCs addNotice: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"dBTCs addNotice: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `dBTCs addNotice: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(characterIndex !== undefined, \"dBTCs addNotice: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `dBTCs addNotice: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract !== undefined, \"dBTCs addNotice: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `dBTCs addNotice: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"dBTCs addNotice: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `dBTCs addNotice: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n        if (noticeObject.debugChain) noticeObject.debugChain = `checkTextfileContents(${languageCode}, ${fileType}, ${filename}) ${noticeObject.debugChain}`;\r\n        result.noticeList.push(noticeObject);\r\n    }\r\n\r\n    function ourCheckPlainText(textType, textFilename, plainText, givenLocation, checkingOptions) {\r\n        /**\r\n        * @description - checks the given text field and processes the returned results\r\n        * @param {String} plainText - the actual text of the field being checked\r\n        * @param {String} givenLocation - description of where the field is located\r\n        * @param {Object} checkingOptions - parameters that might affect the check\r\n        */\r\n        // Does basic checks for small errors like leading/trailing spaces, etc.\r\n\r\n        // We assume that checking for compulsory fields is done elsewhere\r\n\r\n        // Updates the global list of notices\r\n        // console.log(`cPT ourCheckPlainText(${fieldName}, (${fieldText.length}), ${fieldLocation}, )`);\r\n        // console.assert(textName !== undefined, \"cPT ourCheckPlainText: 'textName' parameter should be defined\");\r\n        // console.assert(typeof textName === 'string', `cPT ourCheckPlainText: 'fieldName' parameter should be a string not a '${typeof textName}'`);\r\n        console.assert(plainText !== undefined, \"cPT ourCheckPlainText: 'plainText' parameter should be defined\");\r\n        console.assert(typeof plainText === 'string', `cPT ourCheckPlainText: 'plainText' parameter should be a string not a '${typeof plainText}'`);\r\n        console.assert(checkingOptions !== undefined, \"cPT ourCheckPlainText: 'checkingOptions' parameter should be defined\");\r\n\r\n        const resultObject = checkPlainText(textType, textFilename, plainText, givenLocation, checkingOptions);\r\n\r\n        // Choose only ONE of the following\r\n        // This is the fast way of append the results from this field\r\n        // cptResult.noticeList = cptResult.noticeList.concat(resultObject.noticeList);\r\n        // If we need to put everything through addNotice9, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const noticeEntry of resultObject.noticeList)\r\n            addNotice({ ...noticeEntry, filename: textFilename });\r\n    }\r\n    // end of ourCheckTextField function\r\n\r\n\r\n    // Main code for checkTextfileContents()\r\n    if (!fileText) // Nothing to check\r\n        return result;\r\n\r\n    let ourLocation = optionalFileLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n    /*\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (bfcError) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n    // console.log(`Using supplied extractLength=${extractLength}`, `cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, `halfLengthPlus=${halfLengthPlus}`);\r\n    */\r\n\r\n    /*\r\n    let textType = 'raw';\r\n    const filenameLower = filename.toLowerCase();\r\n    if (filenameLower.endsWith('.usfm')) textType = 'USFM';\r\n    else if (filenameLower.endsWith('.md')) textType = 'markdown';\r\n    else if (filenameLower.endsWith('.yaml') || filenameLower.endsWith('.yml')) textType = 'YAML';\r\n    */\r\n    ourCheckPlainText(fileType, filename, fileText, ourLocation, checkingOptions);\r\n\r\n    //     // Simple check that there arent any\r\n    //     ix = fileText.indexOf('://');\r\n    //     if (ix === -1) ix = fileText.indexOf('http');\r\n    //     if (ix === -1) ix = fileText.indexOf('ftp');\r\n    //     // The following might have to be removed if text fields can contain email addresses\r\n    //     if (ix === -1) ix = fileText.indexOf('.org');\r\n    //     if (ix === -1) ix = fileText.indexOf('.com');\r\n    //     if (ix === -1) ix = fileText.indexOf('.info');\r\n    //     if (ix === -1) ix = fileText.indexOf('.bible');\r\n    //     if (ix >= 0) {\r\n    //         let extract = (ix>halfLength ? '' : '') + fileText.substring(ix-halfLength, ix+halfLengthPlus) + (ix+halfLengthPlus < fileText.length ? '' : '')\r\n    //         addNotice({765, \"Unexpected link\", ix,extract, ourAtString});\r\n    //     }\r\n    // }\r\n    return result;\r\n}\r\n// end of checkTextfileContents function\r\n","export * from './books/';\r\nexport * from './utilities';\r\nexport * from './getApi';\r\nexport * from './text-handling-functions';\r\n\r\nexport * from './annotation-row-check';\r\nexport * from './annotation-table-check';\r\nexport * from './field-text-check';\r\nexport * from './file-text-check';\r\nexport * from './markdown-text-check';\r\nexport * from './markdown-file-contents-check';\r\nexport * from './manifest-text-check';\r\nexport * from './plain-text-check';\r\nexport * from './tn-links-check';\r\nexport * from './tn-table-row-check';\r\nexport * from './tn-table-text-check';\r\nexport * from './usfm-text-check';\r\nexport * from './yaml-text-check';\r\n","export * from './books';\r\n","import { DEFAULT_EXTRACT_LENGTH, isWhitespace } from './text-handling-functions'\r\nimport * as books from './books/books';\r\nimport { checkTextField } from './field-text-check';\r\nimport { checkMarkdownText } from './markdown-text-check';\r\nimport { checkSupportReferenceInTA } from './ta-reference-check';\r\nimport { checkTNLinksToOutside } from './tn-links-check';\r\nimport { checkOriginalLanguageQuote } from './orig-quote-check';\r\n\r\n\r\n// const ANNOTATION_TABLE_ROW_VALIDATOR_VERSION_STRING = '0.6.4';\r\n\r\nconst NUM_EXPECTED_ANNOTATION_TSV_FIELDS = 7; // so expects 6 tabs per line\r\nconst EXPECTED_ANNOTATION_HEADING_LINE = 'Reference\\tID\\tTags\\tSupportReference\\tQuote\\tOccurrence\\tAnnotation';\r\n\r\nconst LC_ALPHABET = 'abcdefghijklmnopqrstuvwxyz';\r\nconst LC_ALPHABET_PLUS_DIGITS = 'abcdefghijklmnopqrstuvwxyz0123456789';\r\nconst LC_ALPHABET_PLUS_DIGITS_PLUS_HYPHEN = 'abcdefghijklmnopqrstuvwxyz0123456789-';\r\n\r\nconst TA_REGEX = new RegExp('\\\\[\\\\[rc://[^ /]+?/ta/man/[^ /]+?/([^ \\\\]]+?)\\\\]\\\\]', 'g');\r\n\r\n\r\n/**\r\n *\r\n * @description - Checks one TSV data row of translation notes (TN2)\r\n * @param {String} languageCode - the language code, e.g., 'en'\r\n * @param {String} annotationType - TN2, TQ2, TWL, SN, or SQ -- allows more specific checks\r\n * @param {String} line - the TSV line to be checked\r\n * @param {String} bookID - 3-character UPPERCASE USFM book identifier or 'OBS'\r\n * @param {String} givenC - chapter number or (for OBS) story number string\r\n * @param {String} givenV - verse number or (for OBS) frame number string\r\n * @param {String} givenRowLocation - description of where the line is located\r\n * @param {Object} checkingOptions - may contain extractLength parameter\r\n * @return {Object} - containing noticeList\r\n */\r\nexport async function checkAnnotationTSVDataRow(languageCode, annotationType, line, bookID, givenC, givenV, givenRowLocation, checkingOptions) {\r\n    /* This function is only for checking one data row\r\n          and the function doesnt assume that it has any previous context.\r\n\r\n        TN2, TQ2, TWL, SN, or SQ\r\n            being translation or study notes, questions, or word-links.\r\n\r\n        bookID is a three-character UPPERCASE USFM book identifier or 'OBS'\r\n            so givenC and givenV are usually chapter number and verse number\r\n                but can be story number and frame number for OBS.\r\n\r\n        Its designed to be able to quickly show errors for a single row being displayed/edited.\r\n\r\n        Returns an object containing the noticeList.\r\n    */\r\n    // console.log(`checkAnnotationTSVDataRow(${languageCode}, ${annotationType}, ${line}, ${bookID}, ${givenRowLocation}, ${JSON.stringify(checkingOptions)})`);\r\n    console.assert(languageCode !== undefined, \"checkAnnotationTSVDataRow: 'languageCode' parameter should be defined\");\r\n    console.assert(typeof languageCode === 'string', `checkAnnotationTSVDataRow: 'languageCode' parameter should be a string not a '${typeof languageCode}'`);\r\n    console.assert(line !== undefined, \"checkAnnotationTSVDataRow: 'line' parameter should be defined\");\r\n    console.assert(typeof line === 'string', `checkAnnotationTSVDataRow: 'line' parameter should be a string not a '${typeof line}'`);\r\n    console.assert(bookID !== undefined, \"checkAnnotationTSVDataRow: 'bookID' parameter should be defined\");\r\n    console.assert(typeof bookID === 'string', `checkAnnotationTSVDataRow: 'bookID' parameter should be a string not a '${typeof bookID}'`);\r\n    console.assert(bookID.length === 3, `checkAnnotationTSVDataRow: 'bookID' parameter should be three characters long not ${bookID.length}`);\r\n    console.assert(bookID.toUpperCase() === bookID, `checkAnnotationTSVDataRow: 'bookID' parameter should be UPPERCASE not '${bookID}'`);\r\n    console.assert(bookID === 'OBS' || books.isValidBookID(bookID), `checkAnnotationTSVDataRow: '${bookID}' is not a valid USFM book identifier`);\r\n    // console.assert(givenC !== undefined, \"checkAnnotationTSVDataRow: 'givenC' parameter should be defined\");\r\n    if (givenC) console.assert(typeof givenC === 'string', `checkAnnotationTSVDataRow: 'givenC' parameter should be a string not a '${typeof givenC}'`);\r\n    // console.assert(givenV !== undefined, \"checkAnnotationTSVDataRow: 'givenV' parameter should be defined\");\r\n    if (givenV) console.assert(typeof givenV === 'string', `checkAnnotationTSVDataRow: 'givenV' parameter should be a string not a '${typeof givenV}'`);\r\n    console.assert(givenRowLocation !== undefined, \"checkAnnotationTSVDataRow: 'givenRowLocation' parameter should be defined\");\r\n    console.assert(typeof givenRowLocation === 'string', `checkAnnotationTSVDataRow: 'givenRowLocation' parameter should be a string not a '${typeof givenRowLocation}'`);\r\n    console.assert(givenRowLocation.indexOf('true') === -1, \"checkAnnotationTSVDataRow: 'givenRowLocation' parameter should not be 'true'\");\r\n\r\n    let ourRowLocation = givenRowLocation;\r\n    if (ourRowLocation && ourRowLocation[0] !== ' ') ourRowLocation = ` ${ourRowLocation}`;\r\n\r\n    const linkCheckingOptions = { ...checkingOptions };\r\n    linkCheckingOptions.taRepoLanguageCode = languageCode;\r\n\r\n    let drResult = { noticeList: [] };\r\n\r\n    function addNoticePartial(noticeObject) {\r\n        /**\r\n        * @description - adds a new notice entry, adding bookID,C,V to the given fields\r\n        * @param {Number} priority - notice priority from 1 (lowest) to 999 (highest)\r\n        * @param {String} message - the text of the notice message\r\n        * @param {String} rowID - 4-character row ID field\r\n        * @param {Number} lineNumber - one-based line number\r\n        * @param {Number} characterIndex - zero-based index of where the issue occurs in the line\r\n        * @param {String} extract - short extract from the line centred on the problem (if available)\r\n        * @param {String} location - description of where the issue is located\r\n        */\r\n        // console.log(`checkAnnotationTSVDataRow addNoticePartial(priority=${noticeObject.priority}) ${noticeObject.message}, ${noticeObject.characterIndex}, ${noticeObject.extract}, ${noticeObject.location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"checkAnnotationTSVDataRow addNoticePartial: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `checkAnnotationTSVDataRow addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"checkAnnotationTSVDataRow addNoticePartial: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `checkAnnotationTSVDataRow addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(lineNumber !== undefined, \"checkAnnotationTSVDataRow addNoticePartial: 'lineNumber' parameter should be defined\");\r\n        // console.assert(typeof lineNumber === 'number', `checkAnnotationTSVDataRow addNoticePartial: 'lineNumber' parameter should be a number not a '${typeof lineNumber}': ${lineNumber}`);\r\n        // console.assert(characterIndex !== undefined, \"checkAnnotationTSVDataRow addNoticePartial: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `checkAnnotationTSVDataRow addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract !== undefined, \"checkAnnotationTSVDataRow addNoticePartial: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `checkAnnotationTSVDataRow addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"checkAnnotationTSVDataRow addNoticePartial: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `checkAnnotationTSVDataRow addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n\r\n        // Also uses the given bookID,C,V, parameters from the main function call\r\n        // noticeObject.debugChain = noticeObject.debugChain ? `checkAnnotationTSVDataRow ${noticeObject.debugChain}` : `checkAnnotationTSVDataRow(${annotationType})`;\r\n        drResult.noticeList.push({ ...noticeObject, bookID, C: givenC, V: givenV });\r\n    }\r\n\r\n    async function ourMarkdownTextChecks(rowID, fieldName, fieldText, allowedLinks, rowLocation, checkingOptions) {\r\n        /**\r\n        * @description - checks the given markdown field and processes the returned results\r\n        * @param {String} rowID - 4-character row ID field\r\n        * @param {String} fieldName - name of the field being checked\r\n        * @param {String} fieldText - the actual text of the field being checked\r\n        * @param {} allowedLinks - true if links are allowed in the field, otherwise false\r\n        * @param {String} rowLocation - description of where the line is located\r\n        * @param {Object} checkingOptions - parameters that might affect the check\r\n        */\r\n        // Does markdown checks for small errors like leading/trailing spaces, etc.\r\n\r\n        // We assume that checking for compulsory fields is done elsewhere\r\n\r\n        // Updates the global list of notices\r\n\r\n        // We dont currently use the allowedLinks parameter\r\n\r\n        // console.log(`checkAnnotationTSVDataRow ourCheckTextField(${fieldName}, (${fieldText.length}), ${allowedLinks}, ${rowLocation}, )`);\r\n        console.assert(rowID !== undefined, \"checkAnnotationTSVDataRow ourMarkdownTextChecks: 'rowID' parameter should be defined\");\r\n        console.assert(typeof rowID === 'string', `checkAnnotationTSVDataRow ourMarkdownTextChecks: 'rowID' parameter should be a string not a '${typeof rowID}'`);\r\n        // console.assert(fieldName !== undefined, \"checkAnnotationTSVDataRow ourMarkdownTextChecks: 'fieldName' parameter should be defined\");\r\n        // console.assert(typeof fieldName === 'string', `checkAnnotationTSVDataRow ourMarkdownTextChecks: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);\r\n        console.assert(fieldName === 'Annotation', \"checkAnnotationTSVDataRow ourMarkdownTextChecks: Only run this check on Annotations\")\r\n        console.assert(fieldText !== undefined, \"checkAnnotationTSVDataRow ourMarkdownTextChecks: 'fieldText' parameter should be defined\");\r\n        console.assert(typeof fieldText === 'string', `checkAnnotationTSVDataRow ourMarkdownTextChecks: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);\r\n        console.assert(allowedLinks === true || allowedLinks === false, \"checkAnnotationTSVDataRow ourMarkdownTextChecks: allowedLinks parameter must be either true or false\");\r\n        console.assert(rowLocation !== undefined, \"checkAnnotationTSVDataRow ourMarkdownTextChecks: 'rowLocation' parameter should be defined\");\r\n        console.assert(typeof rowLocation === 'string', `checkAnnotationTSVDataRow ourMarkdownTextChecks: 'rowLocation' parameter should be a string not a '${typeof rowLocation}'`);\r\n        console.assert(rowLocation.indexOf(fieldName) < 0, `checkAnnotationTSVDataRow ourMarkdownTextChecks: 'rowLocation' parameter should be not contain fieldName=${fieldName}`);\r\n\r\n        const omtcResultObject = await checkMarkdownText(languageCode, fieldName, fieldText, rowLocation, checkingOptions);\r\n\r\n        // Choose only ONE of the following\r\n        // This is the fast way of append the results from this field\r\n        // result.noticeList = result.noticeList.concat(cmtResultObject.noticeList);\r\n        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const noticeEntry of omtcResultObject.noticeList) {\r\n            // console.assert(Object.keys(noticeEntry).length === 5, `TL ourMarkdownTextChecks notice length=${Object.keys(noticeEntry).length}`);\r\n            // NOTE: Ellipses in Annotation have the normal meaning\r\n            //          not like the specialised meaning in the Quote snippet fields\r\n            if (noticeEntry.priority !== 178 && noticeEntry.priority !== 179 // unexpected space after ellipse, ellipse after space\r\n                && !noticeEntry.message.startsWith(\"Unexpected  character after space\") // 191\r\n            )\r\n                addNoticePartial({ ...noticeEntry, rowID, fieldName });\r\n        }\r\n        return omtcResultObject.suggestion; // There may or may not be one!\r\n    }\r\n    // end of ourMarkdownTextChecks function\r\n\r\n    function ourCheckTextField(rowID, fieldName, fieldText, allowedLinks, rowLocation, checkingOptions) {\r\n        /**\r\n        * @description - checks the given text field and processes the returned results\r\n        * @param {String} rowID - 4-character row ID field\r\n        * @param {String} fieldName - name of the field being checked\r\n        * @param {String} fieldText - the actual text of the field being checked\r\n        * @param {boolean} allowedLinks - true if links are allowed in the field, otherwise false\r\n        * @param {String} rowLocation - description of where the line is located\r\n        * @param {Object} checkingOptions - parameters that might affect the check\r\n        */\r\n        // Does basic checks for small errors like leading/trailing spaces, etc.\r\n\r\n        // We assume that checking for compulsory fields is done elsewhere\r\n\r\n        // Updates the global list of notices\r\n\r\n        // console.log(`checkAnnotationTSVDataRow ourCheckTextField(${fieldName}, (${fieldText.length}), ${allowedLinks}, ${rowLocation}, )`);\r\n        console.assert(rowID !== undefined, \"checkAnnotationTSVDataRow ourCheckTextField: 'rowID' parameter should be defined\");\r\n        console.assert(typeof rowID === 'string', `checkAnnotationTSVDataRow ourCheckTextField: 'rowID' parameter should be a string not a '${typeof rowID}'`);\r\n        console.assert(fieldName !== undefined, \"checkAnnotationTSVDataRow ourCheckTextField: 'fieldName' parameter should be defined\");\r\n        console.assert(typeof fieldName === 'string', `checkAnnotationTSVDataRow ourCheckTextField: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);\r\n        console.assert(fieldText !== undefined, \"checkAnnotationTSVDataRow ourCheckTextField: 'fieldText' parameter should be defined\");\r\n        console.assert(typeof fieldText === 'string', `checkAnnotationTSVDataRow ourCheckTextField: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);\r\n        console.assert(allowedLinks === true || allowedLinks === false, \"checkAnnotationTSVDataRow ourCheckTextField: allowedLinks parameter must be either true or false\");\r\n        console.assert(rowLocation !== undefined, \"checkAnnotationTSVDataRow ourCheckTextField: 'rowLocation' parameter should be defined\");\r\n        console.assert(typeof rowLocation === 'string', `checkAnnotationTSVDataRow ourCheckTextField: 'rowLocation' parameter should be a string not a '${typeof rowLocation}'`);\r\n        console.assert(rowLocation.indexOf(fieldName) < 0, `checkAnnotationTSVDataRow ourCheckTextField: 'rowLocation' parameter should be not contain fieldName=${fieldName}`);\r\n\r\n        const fieldType = fieldName === 'Annotation' ? 'markdown' : 'raw';\r\n        const octfResultObject = checkTextField(fieldType, fieldName, fieldText, allowedLinks, rowLocation, checkingOptions);\r\n\r\n        // Choose only ONE of the following\r\n        // This is the fast way of append the results from this field\r\n        // result.noticeList = result.noticeList.concat(dbtcResultObject.noticeList);\r\n        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const noticeEntry of octfResultObject.noticeList) {\r\n            // console.assert(Object.keys(noticeEntry).length === 5, `TL ourCheckTextField notice length=${Object.keys(noticeEntry).length}`);\r\n            addNoticePartial({ ...noticeEntry, rowID, fieldName });\r\n        }\r\n        return octfResultObject.suggestion; // There may or may not be one!\r\n    }\r\n    // end of ourCheckTextField function\r\n\r\n    async function ourCheckSupportReferenceInTA(rowID, fieldName, taLinkText, rowLocation, checkingOptions) {\r\n        // Checks that the TA reference can be found\r\n\r\n        // Updates the global list of notices\r\n\r\n        // console.log(`checkAnnotationTSVDataRow ourCheckSupportReferenceInTA(${fieldName}, (${taLinkText.length}) '${taLinkText}', ${rowLocation}, )`);\r\n        console.assert(rowID !== undefined, \"checkAnnotationTSVDataRow ourCheckSupportReferenceInTA: 'rowID' parameter should be defined\");\r\n        console.assert(typeof rowID === 'string', `checkAnnotationTSVDataRow ourCheckSupportReferenceInTA: 'rowID' parameter should be a string not a '${typeof rowID}'`);\r\n        console.assert(fieldName !== undefined, \"checkAnnotationTSVDataRow ourCheckSupportReferenceInTA: 'fieldName' parameter should be defined\");\r\n        console.assert(typeof fieldName === 'string', `checkAnnotationTSVDataRow ourCheckSupportReferenceInTA: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);\r\n        console.assert(taLinkText !== undefined, \"checkAnnotationTSVDataRow ourCheckSupportReferenceInTA: 'taLinkText' parameter should be defined\");\r\n        console.assert(typeof taLinkText === 'string', `checkAnnotationTSVDataRow ourCheckSupportReferenceInTA: 'taLinkText' parameter should be a string not a '${typeof taLinkText}'`);\r\n        console.assert(rowLocation.indexOf(fieldName) < 0, `checkAnnotationTSVDataRow ourCheckSupportReferenceInTA: 'rowLocation' parameter should be not contain fieldName=${fieldName}`);\r\n\r\n        const coqResultObject = await checkSupportReferenceInTA(fieldName, taLinkText, rowLocation, { ...checkingOptions, taRepoLanguageCode: languageCode, expectFullLink: true });\r\n\r\n        // Choose only ONE of the following\r\n        // This is the fast way of append the results from this field\r\n        // result.noticeList = result.noticeList.concat(coqResultObject.noticeList);\r\n        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const noticeEntry of coqResultObject.noticeList) {\r\n            // console.assert(Object.keys(noticeEntry).length === 5, `TL ourCheckSupportReferenceInTA notice length=${Object.keys(noticeEntry).length}`);\r\n            addNoticePartial({ ...noticeEntry, rowID, fieldName });\r\n        }\r\n    }\r\n    // end of ourCheckSupportReferenceInTA function\r\n\r\n\r\n    async function ourCheckTNOriginalLanguageQuote(rowID, fieldName, fieldText, occurrence, rowLocation, checkingOptions) {\r\n        // Checks that the Hebrew/Greek quote can be found in the original texts\r\n\r\n        // Uses the bookID,C,V values from the main function call\r\n\r\n        // Updates the global list of notices\r\n\r\n        // console.log(`checkAnnotationTSVDataRow ourCheckTNOriginalLanguageQuote(${fieldName}, (${fieldText.length}) '${fieldText}', ${rowLocation}, )`);\r\n        console.assert(rowID !== undefined, \"checkAnnotationTSVDataRow ourCheckTNOriginalLanguageQuote: 'rowID' parameter should be defined\");\r\n        console.assert(typeof rowID === 'string', `checkAnnotationTSVDataRow ourCheckTNOriginalLanguageQuote: 'rowID' parameter should be a string not a '${typeof rowID}'`);\r\n        console.assert(fieldName !== undefined, \"checkAnnotationTSVDataRow ourCheckTNOriginalLanguageQuote: 'fieldName' parameter should be defined\");\r\n        console.assert(typeof fieldName === 'string', `checkAnnotationTSVDataRow ourCheckTNOriginalLanguageQuote: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);\r\n        console.assert(fieldText !== undefined, \"checkAnnotationTSVDataRow ourCheckTNOriginalLanguageQuote: 'fieldText' parameter should be defined\");\r\n        console.assert(typeof fieldText === 'string', `checkAnnotationTSVDataRow ourCheckTNOriginalLanguageQuote: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);\r\n        console.assert(occurrence !== undefined, \"checkAnnotationTSVDataRow ourCheckTNOriginalLanguageQuote: 'occurrence' parameter should be defined\");\r\n        console.assert(typeof occurrence === 'string', `checkAnnotationTSVDataRow ourCheckTNOriginalLanguageQuote: 'occurrence' parameter should be a string not a '${typeof occurrence}'`);\r\n        console.assert(rowLocation.indexOf(fieldName) < 0, `checkAnnotationTSVDataRow ourCheckTNOriginalLanguageQuote: 'rowLocation' parameter should be not contain fieldName=${fieldName}`);\r\n\r\n        const coqResultObject = await checkOriginalLanguageQuote(languageCode, fieldName, fieldText, occurrence, bookID, givenC, givenV, rowLocation, checkingOptions);\r\n\r\n        // Choose only ONE of the following\r\n        // This is the fast way of append the results from this field\r\n        // result.noticeList = result.noticeList.concat(coqResultObject.noticeList);\r\n        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const noticeEntry of coqResultObject.noticeList) {\r\n            // console.assert(Object.keys(noticeEntry).length === 5, `TL ourCheckTNOriginalLanguageQuote notice length=${Object.keys(noticeEntry).length}`);\r\n            addNoticePartial({ ...noticeEntry, rowID, fieldName });\r\n        }\r\n    }\r\n    // end of ourCheckTNOriginalLanguageQuote function\r\n\r\n\r\n    async function ourCheckTNLinksToOutside(rowID, fieldName, taLinkText, rowLocation, checkingOptions) {\r\n        // Checks that the TA/TW/Bible reference can be found\r\n\r\n        // Updates the global list of notices\r\n\r\n        // console.log(`checkAnnotationTSVDataRow ourCheckTNLinksToOutside(${rowID}, ${fieldName}, (${taLinkText.length}) '${taLinkText}', ${rowLocation}, )`);\r\n        console.assert(rowID !== undefined, \"checkAnnotationTSVDataRow ourCheckTNLinksToOutside: 'rowID' parameter should be defined\");\r\n        console.assert(typeof rowID === 'string', `checkAnnotationTSVDataRow ourCheckTNLinksToOutside: 'rowID' parameter should be a string not a '${typeof rowID}'`);\r\n        console.assert(fieldName !== undefined, \"checkAnnotationTSVDataRow ourCheckTNLinksToOutside: 'fieldName' parameter should be defined\");\r\n        console.assert(typeof fieldName === 'string', `checkAnnotationTSVDataRow ourCheckTNLinksToOutside: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);\r\n        console.assert(fieldName === 'Annotation', `checkAnnotationTSVDataRow ourCheckTNLinksToOutside: 'fieldName' parameter should be 'Annotation' not '${fieldName}'`);\r\n        console.assert(taLinkText !== undefined, \"checkAnnotationTSVDataRow ourCheckTNLinksToOutside: 'taLinkText' parameter should be defined\");\r\n        console.assert(typeof taLinkText === 'string', `checkAnnotationTSVDataRow ourCheckTNLinksToOutside: 'taLinkText' parameter should be a string not a '${typeof taLinkText}'`);\r\n\r\n        const coqResultObject = await checkTNLinksToOutside(bookID, givenC, givenV, fieldName, taLinkText, rowLocation, { ...checkingOptions, defaultLanguageCode: languageCode });\r\n        // console.log(\"coqResultObject\", JSON.stringify(coqResultObject));\r\n\r\n        // Choose only ONE of the following\r\n        // This is the fast way of append the results from this field\r\n        // result.noticeList = result.noticeList.concat(coqResultObject.noticeList);\r\n        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const coqNoticeEntry of coqResultObject.noticeList) {\r\n            if (coqNoticeEntry.extra) // it must be an indirect check on a TA or TW article from a TN2 check\r\n                drResult.noticeList.push(coqNoticeEntry); // Just copy the complete notice as is\r\n            else // For our direct checks, we add the repoCode as an extra value\r\n                addNoticePartial({ ...coqNoticeEntry, rowID, fieldName });\r\n        }\r\n        // The following is needed coz we might be checking the linked TA and/or TW articles\r\n        if (coqResultObject.checkedFileCount && coqResultObject.checkedFileCount > 0)\r\n            if (typeof drResult.checkedFileCount === 'number') drResult.checkedFileCount += coqResultObject.checkedFileCount;\r\n            else drResult.checkedFileCount = coqResultObject.checkedFileCount;\r\n        if (coqResultObject.checkedFilesizes && coqResultObject.checkedFilesizes > 0)\r\n            if (typeof drResult.checkedFilesizes === 'number') drResult.checkedFilesizes += coqResultObject.checkedFilesizes;\r\n            else drResult.checkedFilesizes = coqResultObject.checkedFilesizes;\r\n        if (coqResultObject.checkedRepoNames && coqResultObject.checkedRepoNames.length > 0)\r\n            for (const checkedRepoName of coqResultObject.checkedRepoNames)\r\n                try { if (drResult.checkedRepoNames.indexOf(checkedRepoName) < 0) drResult.checkedRepoNames.push(checkedRepoName); }\r\n                catch { drResult.checkedRepoNames = [checkedRepoName]; }\r\n        if (coqResultObject.checkedFilenameExtensions && coqResultObject.checkedFilenameExtensions.length > 0)\r\n            for (const checkedFilenameExtension of coqResultObject.checkedFilenameExtensions)\r\n                try { if (drResult.checkedFilenameExtensions.indexOf(checkedFilenameExtension) < 0) drResult.checkedFilenameExtensions.push(checkedFilenameExtension); }\r\n                catch { drResult.checkedFilenameExtensions = [checkedFilenameExtension]; }\r\n        // if (drResult.checkedFilenameExtensions) console.log(\"drResult\", JSON.stringify(drResult));\r\n    }\r\n    // end of ourCheckTNLinksToOutside function\r\n\r\n\r\n    // Main code for checkAnnotationTSVDataRow function\r\n    if (line === EXPECTED_ANNOTATION_HEADING_LINE) // Assume it must be ok\r\n        return drResult; // We cant detect if its in the wrong place\r\n\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (tlcELerror) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n    // console.log(`Using supplied extractLength=${extractLength}`, `cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    // const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    // const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n    const lowercaseBookID = bookID.toLowerCase();\r\n    let numChaptersThisBook;\r\n    if (bookID === 'OBS')\r\n        numChaptersThisBook = 50; // There's 50 Open Bible Stories\r\n    else {\r\n        console.assert(lowercaseBookID !== 'obs', \"Shouldnt happen in annotation-row-check\");\r\n        try {\r\n            numChaptersThisBook = books.chaptersInBook(lowercaseBookID).length;\r\n        } catch (tlcNCerror) {\r\n            addNoticePartial({ priority: 979, message: \"Invalid book identifier passed to checkAnnotationTSVDataRow\", location: ` '${bookID}' in first parameter: ${tlcNCerror}` });\r\n        }\r\n    }\r\n    const haveGoodBookID = numChaptersThisBook !== undefined;\r\n\r\n    let fields = line.split('\\t');\r\n    let RIDSuggestion, SRSuggestion, QSuggestion, OSuggestion, ASuggestion;\r\n    if (fields.length === NUM_EXPECTED_ANNOTATION_TSV_FIELDS) {\r\n        const [reference, rowID, tags, supportReference, quote, occurrence, annotation] = fields;\r\n        // let withString = ` with '${rowID}'${inString}`;\r\n        // let CV_withString = ` ${C}:${V}${withString}`;\r\n        // let atString = ` at ${B} ${C}:${V} (${rowID})${inString}`;\r\n\r\n        // Check the fields one-by-one\r\n        const [C, V] = reference.split(':');\r\n        let numVersesThisChapter, haveGoodChapterNumber;\r\n        if (C.length) {\r\n            if (C !== givenC)\r\n                addNoticePartial({ priority: 976, message: \"Wrong chapter number\", details: `expected '${givenC}'`, fieldName: 'Reference', rowID, extract: C, location: ourRowLocation });\r\n            if (C === 'front') { }\r\n            else if (/^\\d+$/.test(C)) {\r\n                let intC = Number(C);\r\n                if (intC === 0) {\r\n                    addNoticePartial({ priority: 824, message: `Invalid zero chapter number`, extract: C, rowID, fieldName: 'Reference', location: ourRowLocation });\r\n                    haveGoodChapterNumber = false;\r\n                }\r\n                // TODO: Does this next section need rewriting (see verse check below)???\r\n                else if (intC > numChaptersThisBook) {\r\n                    addNoticePartial({ priority: 823, message: `Invalid large chapter number`, extract: C, rowID, fieldName: 'Reference', location: ourRowLocation });\r\n                    haveGoodChapterNumber = false;\r\n                }\r\n                if (lowercaseBookID === 'obs')\r\n                    numVersesThisChapter = 99; // Set to maximum expected number of frames\r\n                else {\r\n                    try {\r\n                        numVersesThisChapter = books.versesInChapter(lowercaseBookID, intC);\r\n                        haveGoodChapterNumber = true;\r\n                    } catch (tlcNVerror) {\r\n                        if (!haveGoodBookID)\r\n                            // addNoticePartial({priority:500, \"Invalid chapter number\", rowLocation);\r\n                            // else\r\n                            addNoticePartial({ priority: 822, message: \"Unable to check chapter number\", extract: C, rowID, fieldName: 'Reference', location: ourRowLocation });\r\n                        haveGoodChapterNumber = false;\r\n                    }\r\n                }\r\n            }\r\n            else\r\n                addNoticePartial({ priority: 821, message: \"Bad chapter number\", extract: C, rowID, fieldName: 'Reference', location: ourRowLocation });\r\n        }\r\n        else\r\n            addNoticePartial({ priority: 820, message: \"Missing chapter number\", rowID, fieldName: 'Reference', location: ` ?:${V}${ourRowLocation}` });\r\n\r\n        if (V.length) {\r\n            if (V !== givenV)\r\n                addNoticePartial({ priority: 975, message: \"Wrong verse number\", details: `expected '${givenV}'`, rowID, fieldName: 'Reference', extract: V, location: ourRowLocation });\r\n            if (V === 'intro') { }\r\n            else if (/^\\d+$/.test(V)) {\r\n                let intV = Number(V);\r\n                if (intV === 0)\r\n                    addNoticePartial({ priority: 814, message: \"Invalid zero verse number\", rowID, fieldName: 'Reference', extract: V, location: ourRowLocation });\r\n                else {\r\n                    if (haveGoodChapterNumber) {\r\n                        if (intV > numVersesThisChapter)\r\n                            addNoticePartial({ priority: 813, message: \"Invalid large verse number\", rowID, fieldName: 'Reference', extract: V, location: ourRowLocation });\r\n                    } else\r\n                        addNoticePartial({ priority: 812, message: \"Unable to check verse number\", rowID, fieldName: 'Reference', location: ourRowLocation });\r\n                }\r\n            }\r\n            else\r\n                addNoticePartial({ priority: 811, message: \"Bad verse number\", rowID, fieldName: 'Reference', location: ` '${V}'${ourRowLocation}` });\r\n        }\r\n        else\r\n            addNoticePartial({ priority: 810, message: \"Missing verse number\", rowID, fieldName: 'Reference', location: ` after ${C}:?${ourRowLocation}` });\r\n\r\n        if (!rowID.length)\r\n            addNoticePartial({ priority: 779, message: \"Missing row ID field\", fieldName: 'Reference', location: ourRowLocation });\r\n        else {\r\n            if (rowID.length !== 4) {\r\n                addNoticePartial({ priority: 778, message: \"Row ID should be exactly 4 characters\", details: `not ${rowID.length}`, rowID, fieldName: 'ID', extract: rowID, location: ourRowLocation });\r\n                if (rowID.length > 4) RIDSuggestion = rowID.substring(0, 5);\r\n                else { // must be < 4\r\n                    RIDSuggestion = rowID;\r\n                    while (RIDSuggestion.length < 4) RIDSuggestion += LC_ALPHABET_PLUS_DIGITS[Math.floor(Math.random() * LC_ALPHABET_PLUS_DIGITS.length)];;\r\n                }\r\n            } else if (LC_ALPHABET.indexOf(rowID[0]) < 0)\r\n                addNoticePartial({ priority: 176, message: \"Row ID should start with a lowercase letter\", characterIndex: 0, rowID, fieldName: 'ID', extract: rowID, location: ourRowLocation });\r\n            else if (LC_ALPHABET_PLUS_DIGITS.indexOf(rowID[3]) < 0)\r\n                addNoticePartial({ priority: 175, message: \"Row ID should end with a lowercase letter or digit\", characterIndeX: 3, rowID, fieldName: 'ID', extract: rowID, location: ourRowLocation });\r\n            else if (LC_ALPHABET_PLUS_DIGITS_PLUS_HYPHEN.indexOf(rowID[1]) < 0)\r\n                addNoticePartial({ priority: 174, message: \"Row ID characters should only be lowercase letters, digits, or hypen\", fieldName: 'ID', characterIndex: 1, rowID, extract: rowID, location: ourRowLocation });\r\n            else if (LC_ALPHABET_PLUS_DIGITS_PLUS_HYPHEN.indexOf(rowID[2]) < 0)\r\n                addNoticePartial({ priority: 173, message: \"Row ID characters should only be lowercase letters, digits, or hypen\", fieldName: 'ID', characterIndex: 2, rowID, extract: rowID, location: ourRowLocation });\r\n        }\r\n\r\n        if (tags.length)\r\n            ;\r\n\r\n        if (supportReference.length) { // need to check TN2 against TA\r\n            if (isWhitespace(supportReference))\r\n                addNoticePartial({ priority: 373, message: \"Field is only whitespace\", fieldName: 'SupportReference', rowID, location: ourRowLocation });\r\n            else if (annotationType === 'TN2') { // More than just whitespace\r\n                const supportReferenceArticlePart = supportReference.replace('rc://*/ta/man/translate/', '');\r\n                // console.log(\"supportReferenceArticlePart\", supportReferenceArticlePart);\r\n                if (!supportReferenceArticlePart.startsWith('figs-')\r\n                    && !supportReferenceArticlePart.startsWith('grammar-')\r\n                    && !supportReferenceArticlePart.startsWith('translate-')\r\n                    && !supportReferenceArticlePart.startsWith('writing-')\r\n                    && supportReferenceArticlePart !== 'guidelines-sonofgodprinciples')\r\n                    addNoticePartial({ priority: 788, message: \"Only 'Just-In-Time Training' TA articles allowed here\", fieldName: 'SupportReference', extract: supportReference, rowID, location: ourRowLocation });\r\n                SRSuggestion = ourCheckTextField(rowID, 'SupportReference', supportReference, true, ourRowLocation, checkingOptions);\r\n                if (checkingOptions?.disableAllLinkFetchingFlag !== true)\r\n                    await ourCheckSupportReferenceInTA(rowID, 'SupportReference', supportReference, ourRowLocation, checkingOptions);\r\n                if (annotation.indexOf(supportReference) < 0)\r\n                    addNoticePartial({ priority: 787, message: \"Link to TA should also be in Annotation\", fieldName: 'SupportReference', extract: supportReference, rowID, location: ourRowLocation });\r\n            }\r\n            if (supportReference.indexOf('\\u200B') >= 0)\r\n                addNoticePartial({ priority: 374, message: \"Field contains zero-width space(s)\", fieldName: 'SupportReference', rowID, location: ourRowLocation });\r\n        }\r\n        // // TODO: Check if this is really required????\r\n        // else if (/^\\d+$/.test(C) && /^\\d+$/.test(V)) // C:V are both digits\r\n        //     addNoticePartial({ priority: 877, message: \"Missing SupportReference field\", fieldName: 'SupportReference', rowID, location: ourRowLocation });\r\n\r\n        if (quote.length) { // need to check UTN against UHB and UGNT\r\n            QSuggestion = ourCheckTextField(rowID, 'Quote', quote, false, ourRowLocation, checkingOptions);\r\n            if (occurrence.length)\r\n                await ourCheckTNOriginalLanguageQuote(rowID, 'Quote', quote, occurrence, ourRowLocation, checkingOptions);\r\n            else\r\n                addNoticePartial({ priority: 750, message: \"Missing occurrence field when we have an original quote\", fieldName: 'Occurrence', rowID, location: ourRowLocation });\r\n        }\r\n        else // TODO: Find more details about when these fields are really compulsory (and when they're not, e.g., for 'intro') ???\r\n            if (annotationType === 'TN2' && V !== 'intro' && occurrence !== '0')\r\n                addNoticePartial({ priority: 919, message: \"Missing Quote field\", fieldName: 'Quote', rowID, location: ourRowLocation });\r\n\r\n        if (occurrence.length) { // This should usually be a digit\r\n            if (occurrence === '0') { // zero means that it doesnt occur\r\n                if (quote.length) {\r\n                    addNoticePartial({ priority: 751, message: \"Invalid zero occurrence field when we have an original quote\", fieldName: 'Occurrence', rowID, extract: occurrence, location: ourRowLocation });\r\n                    OSuggestion = '1';\r\n                }\r\n                // if (V !== 'intro')\r\n                //     addNoticePartial({priority:500, message:\"Invalid zero occurrence field\", rowID, location:rowLocation);\r\n            }\r\n            else if (occurrence === '-1') // TODO check the special conditions when this can occur???\r\n                ;\r\n            else if ('1234567'.indexOf(occurrence) < 0) { // its not one of these integers\r\n                addNoticePartial({ priority: 792, message: `Invalid occurrence field`, fieldName: 'Occurrence', rowID, extract: occurrence, location: ourRowLocation });\r\n                OSuggestion = '1';\r\n            }\r\n        }\r\n        else if (quote.length) {\r\n            addNoticePartial({ priority: 791, message: `Missing occurrence field`, fieldName: 'Occurrence', rowID, location: ourRowLocation });\r\n            OSuggestion = '1';\r\n        }\r\n\r\n        if (annotation.length) {\r\n            if (annotation.indexOf('\\u200B') >= 0)\r\n                addNoticePartial({ priority: 374, message: \"Field contains zero-width space(s)\", fieldName: 'Annotation', rowID, location: ourRowLocation });\r\n            if (isWhitespace(annotation))\r\n                addNoticePartial({ priority: 373, message: \"Field is only whitespace\", fieldName: 'Annotation', rowID, location: ourRowLocation });\r\n            else { // More than just whitespace\r\n                ASuggestion = await ourMarkdownTextChecks(rowID, 'Annotation', annotation, true, ourRowLocation, checkingOptions);\r\n                await ourCheckTNLinksToOutside(rowID, 'Annotation', annotation, ourRowLocation, linkCheckingOptions);\r\n                let regexResultArray;\r\n                // eslint-disable-next-line no-cond-assign\r\n                while (regexResultArray = TA_REGEX.exec(annotation)) {\r\n                    // console.log(\"Got TA Regex in Annotation\", JSON.stringify(regexResultArray));\r\n                    const adjustedLink = regexResultArray[0].substring(2, regexResultArray[0].length - 2)\r\n                    if (supportReference !== adjustedLink && V !== 'intro') {\r\n                        const details = supportReference ? `(SR='${supportReference}')` : \"(empty SR field)\"\r\n                        addNoticePartial({ priority: 786, message: \"Link to TA should also be in SupportReference\", details, rowID, fieldName: 'Annotation', extract: adjustedLink, location: ourRowLocation });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else // TODO: Find out if these fields are really compulsory (and when they're not, e.g., for 'intro') ???\r\n            if (annotationType === 'TN2')\r\n                addNoticePartial({ priority: 274, message: \"Missing Annotation field\", fieldName: 'Annotation', rowID, location: ourRowLocation });\r\n\r\n        // 7 [reference, rowID, tags, supportReference, quote, occurrence, annotation]\r\n        const suggestion = `${reference}\\t${RIDSuggestion === undefined ? rowID : RIDSuggestion}\\t${tags}\\t${SRSuggestion === undefined ? supportReference : SRSuggestion}\\t${QSuggestion === undefined ? quote : QSuggestion}\\t${OSuggestion === undefined ? occurrence : OSuggestion}\\t${ASuggestion === undefined ? annotation : ASuggestion}`;\r\n        if (suggestion !== line) {\r\n            // console.log(`Had annotation ${line}`);\r\n            // console.log(`Sug annotation ${suggestion}`);\r\n            drResult.suggestion = suggestion;\r\n        }\r\n\r\n    } else { // wrong number of fields in the row\r\n        // Have a go at getting some of the first fields out of the row\r\n        let rowID = '????';\r\n        try { rowID = fields[1]; } catch { }\r\n        addNoticePartial({ priority: 984, message: `Found wrong number of TSV fields (expected ${NUM_EXPECTED_ANNOTATION_TSV_FIELDS})`, details: `Found ${fields.length} field${fields.length === 1 ? '' : 's'}`, rowID, location: ourRowLocation });\r\n    }\r\n\r\n    // console.log(`  checkAnnotationTSVDataRow returning with ${drResult.noticeList.length.toLocaleString()} notice(s).`);\r\n    // console.log(\"checkAnnotationTSVDataRow result is\", JSON.stringify(drResult));\r\n    return drResult; // object with noticeList and possibly suggestion only\r\n}\r\n// end of checkAnnotationTSVDataRow function\r\n","import { cachedGetFile } from '../core/getApi';\r\n// import { consoleLogObject } from '../core/utilities';\r\n\r\n\r\n// const TA_REFERENCE_VALIDATOR_VERSION_STRING = '0.3.1';\r\n\r\n\r\nexport async function checkSupportReferenceInTA(fieldName, fieldText, givenLocation, checkingOptions) {\r\n    // This is for the case of the full SupportReference field being the article link\r\n    //  which is assumed to be in the translate part of the TA manual.\r\n\r\n    // We fetch the TA link from Door43 to test that its really there\r\n    //  -- you can control this with:\r\n    //      checkingOptions?.taRepoUsername\r\n    //      checkingOptions?.taRepoBranch (or tag)\r\n    //      checkingOptions?.taRepoLanguageCode\r\n    //      checkingOptions?.taRepoSectionName\r\n    //      checkingOptions?.expectFullLink (bool)\r\n\r\n    // console.log(`checkSupportReferenceInTA v${TA_REFERENCE_VALIDATOR_VERSION_STRING} (${fieldName}, (${fieldText.length}) '${fieldText}', ${givenLocation}, )`);\r\n    console.assert(fieldName !== undefined, \"checkSupportReferenceInTA: 'fieldText' parameter should be defined\");\r\n    console.assert(typeof fieldName === 'string', `checkSupportReferenceInTA: 'fieldText' parameter should be a string not a '${typeof fieldName}'`);\r\n    console.assert(fieldText !== undefined, \"checkSupportReferenceInTA: 'fieldText' parameter should be defined\");\r\n    console.assert(typeof fieldText === 'string', `checkSupportReferenceInTA: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);\r\n    console.assert(givenLocation !== undefined, \"checkSupportReferenceInTA: 'fieldText' parameter should be defined\");\r\n    console.assert(typeof givenLocation === 'string', `checkSupportReferenceInTA: 'fieldText' parameter should be a string not a '${typeof givenLocation}'`);\r\n    console.assert(fieldName === 'SupportReference', `Unexpected checkSupportReferenceInTA fieldName='${fieldName}'`); // so far\r\n    console.assert(givenLocation.indexOf(fieldName) < 0, `checkSupportReferenceInTA: 'givenLocation' parameter should be not contain fieldName=${fieldName}`);\r\n\r\n    console.assert(fieldName === 'SupportReference');\r\n\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n    const ctarResult = { noticeList: [] };\r\n\r\n    function addNoticePartial(noticeObject) {\r\n        // console.log(`checkSupportReferenceInTA Notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : \"\"}${extract ? ` ${extract}` : \"\"}${location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"cTAref addNoticePartial: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `cTAref addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"cTAref addNoticePartial: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `cTAref addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(characterIndex !== undefined, \"cTAref addNoticePartial: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cTAref addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract !== undefined, \"cTAref addNoticePartial: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cTAref addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"cTAref addNoticePartial: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `cTAref addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n        ctarResult.noticeList.push({ ...noticeObject, fieldName });\r\n    }\r\n\r\n\r\n    // Main code for checkSupportReferenceInTA\r\n    /*\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (trcELerror) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n        // console.log(`Using supplied extractLength=${extractLength}`, \"cf. default=\"+DEFAULT_EXTRACT_LENGTH);\r\n    const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, \"halfLengthPlus=\"+halfLengthPlus);\r\n    */\r\n\r\n    let taRepoUsername;\r\n    try {\r\n        taRepoUsername = checkingOptions?.taRepoUsername;\r\n    } catch (trcUNerror) { }\r\n    if (!taRepoUsername) taRepoUsername = 'Door43-Catalog'; // or unfoldingWord ???\r\n    let taRepoBranch;\r\n    try {\r\n        taRepoBranch = checkingOptions?.taRepoBranch;\r\n    } catch (trcBRerror) { }\r\n    if (!taRepoBranch) taRepoBranch = 'master';\r\n    let taRepoLanguageCode;\r\n    try {\r\n        taRepoLanguageCode = checkingOptions?.taRepoLanguageCode;\r\n    } catch (trcLCerror) { }\r\n    if (!taRepoLanguageCode) taRepoLanguageCode = 'en';\r\n    let taRepoSectionName;\r\n    try {\r\n        taRepoSectionName = checkingOptions?.taRepoSectionName;\r\n    } catch (trcSNerror) { }\r\n    if (!taRepoSectionName) taRepoSectionName = 'translate';\r\n    const taRepoName = `${taRepoLanguageCode}_ta`;\r\n    let filepath;\r\n    if (checkingOptions?.expectFullLink) {\r\n        // console.log(\"checkSupportReferenceInTA expect full link\")\r\n        if (!fieldText.startsWith('rc://*/'))\r\n            addNoticePartial({ priority: 879, message: `Badly formatted Resource Container link`, extract: fieldText, location: `${ourLocation} ${filepath}` });\r\n        filepath = `${fieldText.replace('rc://*/ta/man/', '')}/01.md`; // Other files are title.md, sub-title.md\r\n    }\r\n    else filepath = `${taRepoSectionName}/${fieldText}/01.md`; // Other files are title.md, sub-title.md\r\n    // console.log(\"checkSupportReferenceInTA filepath\", filepath);\r\n\r\n    // console.log(`Need to check against ${taRepoName}`);\r\n    let taFileContent; // Not really used here -- just to show that we got something valid\r\n    try {\r\n        const getFile_ = (checkingOptions && checkingOptions?.getFile) ? checkingOptions?.getFile : cachedGetFile;\r\n        taFileContent = await getFile_({ username: taRepoUsername, repository: taRepoName, path: filepath, branch: taRepoBranch });\r\n        // console.log(\"Fetched fileContent for\", taRepoName, filepath, typeof fileContent, fileContent.length);\r\n        if (!taFileContent)\r\n            addNoticePartial({ priority: 889, message: `Unable to find TA link`, extract: fieldText, location: `${ourLocation} ${filepath}` });\r\n        else if (taFileContent.length < 10)\r\n            addNoticePartial({ priority: 887, message: `Linked TA article seems empty`, extract: fieldText, location: `${ourLocation} ${filepath}` });\r\n    } catch (trcGCerror) {\r\n        // console.error(\"checkSupportReferenceInTA() failed to load\", taRepoUsername, taRepoName, filepath, taRepoBranch, trcGCerror.message);\r\n        addNoticePartial({ priority: 888, message: `Error loading TA link`, extract: fieldText, location: `${ourLocation} ${filepath}: ${trcGCerror}` });\r\n    }\r\n\r\n    // console.log(`checkSupportReferenceInTA is returning ${JSON.stringify(ctarResult)}`);\r\n    return ctarResult;\r\n}\r\n// end of checkSupportReferenceInTA function\r\n","import * as books from '../core/books/books';\r\nimport { DEFAULT_EXTRACT_LENGTH } from './text-handling-functions'\r\nimport { cachedGetFile } from '../core/getApi';\r\nimport { ourParseInt } from './utilities';\r\n\r\n\r\n// const QUOTE_VALIDATOR_VERSION_STRING = '0.7.6';\r\n\r\n\r\nexport async function checkOriginalLanguageQuote(languageCode, fieldName, fieldText, occurrenceString, bookID, C, V, givenLocation, checkingOptions) {\r\n    // Checks that the Hebrew/Greek quote can be found in the original texts\r\n\r\n    // bookID is a three-character UPPERCASE USFM book identifier or 'OBS'.\r\n\r\n    // Note that the original language verse text can be passed in as\r\n    //      checkingOptions?.originalLanguageVerseText.\r\n    // Alternatively, we can fetch it from Door43 -- you can control this with:\r\n    //      checkingOptions?.originalLanguageRepoUsername\r\n    //      (UHB or UGNT will be used for the repo name)\r\n    //      checkingOptions?.originalLanguageRepoBranch (or tag)\r\n\r\n    // console.log(`checkOriginalLanguageQuote v${QUOTE_VALIDATOR_VERSION_STRING} (${fieldName}, (${fieldText.length}) '${fieldText}', ${occurrenceString}, ${bookID} ${C}:${V} ${givenLocation}, )`);\r\n    console.assert(languageCode !== undefined, \"checkOriginalLanguageQuote: 'languageCode' parameter should be defined\");\r\n    console.assert(typeof languageCode === 'string', `checkOriginalLanguageQuote: 'languageCode' parameter should be a string not a '${typeof languageCode}'`);\r\n    console.assert(fieldName !== undefined, \"checkOriginalLanguageQuote: 'fieldName' parameter should be defined\");\r\n    console.assert(typeof fieldName === 'string', `checkOriginalLanguageQuote: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);\r\n    console.assert(fieldText !== undefined, \"checkOriginalLanguageQuote: 'fieldText' parameter should be defined\");\r\n    console.assert(typeof fieldText === 'string', `checkOriginalLanguageQuote: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);\r\n    console.assert(fieldText.length >= 1, `checkOriginalLanguageQuote: 'fieldText' parameter should have text not ${fieldText.length} characters`);\r\n    console.assert(occurrenceString !== undefined, \"checkOriginalLanguageQuote: 'occurrenceString' parameter should be defined\");\r\n    console.assert(typeof occurrenceString === 'string', `checkOriginalLanguageQuote: 'occurrenceString' parameter should be a string not a '${typeof occurrenceString}'`);\r\n    console.assert(bookID !== undefined, \"checkOriginalLanguageQuote: 'bookID' parameter should be defined\");\r\n    console.assert(typeof bookID === 'string', `checkOriginalLanguageQuote: 'bookID' parameter should be a string not a '${typeof bookID}'`);\r\n    console.assert(bookID.length === 3, `checkOriginalLanguageQuote: 'bookID' parameter should be three characters long not ${bookID.length}`);\r\n    console.assert(bookID.toUpperCase() === bookID, `checkOriginalLanguageQuote: 'bookID' parameter should be UPPERCASE not '${bookID}'`);\r\n    console.assert(bookID === 'OBS' || books.isValidBookID(bookID), `checkOriginalLanguageQuote: '${bookID}' is not a valid USFM book identifier`);\r\n    console.assert(C !== undefined, \"checkOriginalLanguageQuote: 'C' parameter should be defined\");\r\n    console.assert(typeof C === 'string', `checkOriginalLanguageQuote: 'C' parameter should be a string not a '${typeof C}'`);\r\n    console.assert(V !== undefined, \"checkOriginalLanguageQuote: 'V' parameter should be defined\");\r\n    console.assert(typeof V === 'string', `checkOriginalLanguageQuote: 'V' parameter should be a string not a '${typeof V}'`);\r\n    console.assert(givenLocation !== undefined, \"checkOriginalLanguageQuote: 'givenLocation' parameter should be defined\");\r\n    console.assert(typeof givenLocation === 'string', `checkOriginalLanguageQuote: 'givenLocation' parameter should be a string not a '${typeof givenLocation}'`);\r\n\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n    const colqResult = { noticeList: [] };\r\n\r\n    function addNotice(noticeObject) {\r\n        // console.log(`checkOriginalLanguageQuote Notice: (priority=${noticeObject.priority}) ${noticeObject.message}${characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : \"\"}${noticeObject.extract ? ` ${noticeObject.extract}` : \"\"}${noticeObject.location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"cOLQ addNotice: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `cOLQ addNotice: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"cOLQ addNotice: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `cOLQ addNotice: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(characterIndex !== undefined, \"cOLQ addNotice: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cOLQ addNotice: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract !== undefined, \"cOLQ addNotice: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cOLQ addNotice: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"cOLQ addNotice: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `cOLQ addNotice: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n        colqResult.noticeList.push(noticeObject);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} bookID -- USFM book ID or 'OBS'\r\n     * @param {string} C -- chapter or story number\r\n     * @param {string} V -- verse or frame number\r\n     * @param {Object} checkingOptions\r\n     */\r\n    async function getOriginalPassage(bookID, C, V, checkingOptions) {\r\n        // TODO: Cache these ???\r\n\r\n        // console.log(`getOriginalPassage(${bookID}, ${C}, ${V})`);\r\n        let username;\r\n        try {\r\n            username = checkingOptions?.originalLanguageRepoUsername;\r\n        } catch (qcoError) { }\r\n        if (!username) username = languageCode === 'en' ? 'unfoldingWord' : 'Door43-Catalog'; // ??? !!!\r\n        let branch;\r\n        try {\r\n            branch = checkingOptions?.originalLanguageRepoBranch;\r\n        } catch (qcunError) { }\r\n        if (!branch) branch = 'master';\r\n        const getFile_ = (checkingOptions && checkingOptions?.getFile) ? checkingOptions?.getFile : cachedGetFile;\r\n\r\n        let verseText = '';\r\n        if (bookID === 'OBS') {\r\n            let originalMarkdown;\r\n            const OBSRepoName = `${languageCode}_obs`;\r\n            const adjC = C.length === 2 ? C : '0' + C;\r\n            const adjV = V.length === 2 ? V : '0' + V;\r\n            const OBSPathname = `content/${adjC}.md`;\r\n            try {\r\n                originalMarkdown = await getFile_({ username, repository: OBSRepoName, path: OBSPathname, branch });\r\n                // console.log(\"Fetched fileContent for\", OBSRepoName, OBSPathname, typeof originalMarkdown, originalMarkdown.length);\r\n            } catch (gcUHBerror) {\r\n                console.error(`getOriginalPassage(${bookID}, ${C}:${V}, ${JSON.stringify(checkingOptions)}) failed to load UHB`, username, languageCode, OBSPathname, branch, gcUHBerror.message);\r\n                addNotice({ priority: 601, message: \"Unable to load\", details: `username=${username} error=${gcUHBerror}`, OBSPathname, location: ourLocation, extra: OBSRepoName });\r\n            }\r\n            if (!originalMarkdown) return '';\r\n\r\n            let gotIt = false;\r\n            const searchString = `-${adjC}-${adjV}.`;\r\n            // NOTE: Bible references get appended to the last frame text (but I dont think it does any harm)\r\n            for (const line of originalMarkdown.split('\\n')) {\r\n                if (!line) continue;\r\n                if (line.indexOf(searchString) > 0) { gotIt = true; continue; }\r\n                if (gotIt)\r\n                    if (line.indexOf('[OBS Image]') > 0) // This is the next frame\r\n                        break;\r\n                    else\r\n                        verseText += line;\r\n            }\r\n        } else { // not OBS, so a USFM Bible book\r\n            const bookNumberAndName = books.usfmNumberName(bookID);\r\n            const whichTestament = books.testament(bookID); // returns 'old' or 'new'\r\n            const originalLanguageRepoLanguageCode = whichTestament === 'old' ? 'hbo' : 'el-x-koine';\r\n            const originalLanguageRepoCode = whichTestament === 'old' ? 'UHB' : 'UGNT';\r\n            const originalLanguageRepoName = `${originalLanguageRepoLanguageCode}_${originalLanguageRepoCode.toLowerCase()}`;\r\n            const filename = `${bookNumberAndName}.usfm`;\r\n\r\n            let originalUSFM;\r\n            // console.log(`Need to check against ${originalLanguageRepoCode}`);\r\n            if (originalLanguageRepoCode === 'UHB') {\r\n                try {\r\n                    originalUSFM = await getFile_({ username, repository: originalLanguageRepoName, path: filename, branch });\r\n                    // console.log(\"Fetched fileContent for\", repoName, filename, typeof originalUSFM, originalUSFM.length);\r\n                } catch (gcUHBerror) {\r\n                    console.error(`getOriginalPassage(${bookID}, ${C}:${V}, ${JSON.stringify(checkingOptions)}) failed to load UHB`, username, originalLanguageRepoCode, filename, branch, gcUHBerror.message);\r\n                    addNotice({ priority: 601, message: \"Unable to load\", details: `username=${username} error=${gcUHBerror}`, filename, location: ourLocation, extra: originalLanguageRepoName });\r\n                }\r\n            } else if (originalLanguageRepoCode === 'UGNT') {\r\n                try {\r\n                    originalUSFM = await getFile_({ username, repository: originalLanguageRepoName, path: filename, branch });\r\n                    // console.log(\"Fetched fileContent for\", repoName, filename, typeof originalUSFM, originalUSFM.length);\r\n                } catch (gcUGNTerror) {\r\n                    console.error(`getOriginalPassage(${bookID}, ${C}:${V}, ${JSON.stringify(checkingOptions)}) failed to load UGNT`, username, originalLanguageRepoCode, filename, branch, gcUGNTerror.message);\r\n                    addNotice({ priority: 601, message: \"Unable to load\", details: `username=${username} error=${gcUGNTerror}`, filename, location: ourLocation, extra: originalLanguageRepoName });\r\n                }\r\n            }\r\n            if (!originalUSFM) return '';\r\n\r\n\r\n            // Do global fixes\r\n            originalUSFM = originalUSFM.replace(/\\\\k-e\\\\\\*/g, ''); // Remove \\k-e self-closed milestones\r\n            originalUSFM = originalUSFM.replace(/\\\\k-s.+?\\\\\\*/g, ''); // Remove \\k-s self-closed milestones\r\n\r\n\r\n            // Now find the desired C:V\r\n            let foundChapter = false, foundVerse = false;\r\n            for (let bookLine of originalUSFM.split('\\n')) {\r\n                // console.log(\"bookLine\", bookLine);\r\n                if (!foundChapter && bookLine === `\\\\c ${C}`) {\r\n                    foundChapter = true;\r\n                    continue;\r\n                }\r\n                if (foundChapter && !foundVerse && bookLine.startsWith(`\\\\v ${V}`)) {\r\n                    foundVerse = true;\r\n                    bookLine = bookLine.substring(3 + V.length); // Delete verse number so below bit doesnt fail\r\n                }\r\n                if (foundVerse) {\r\n                    if (bookLine.startsWith('\\\\v ') || bookLine.startsWith('\\\\c '))\r\n                        break; // Dont go into the next verse or chapter\r\n                    verseText += (bookLine.startsWith('\\\\f ') ? '' : ' ') + bookLine;\r\n                }\r\n            }\r\n            verseText = verseText.replace(/\\\\p/g, '').trim().replace(/ {2}/g, ' ')\r\n            // console.log(`Got verse text1: '${verseText}'`);\r\n\r\n            // Remove \\w fields (just leaving the actual Bible text words)\r\n            let ixW = verseText.indexOf('\\\\w ')\r\n            while (ixW !== -1) {\r\n                const ixEnd = verseText.indexOf('\\\\w*', ixW)\r\n                if (ixEnd !== -1) {\r\n                    const field = verseText.substring(ixW + 3, ixEnd);\r\n                    const bits = field.split('|');\r\n                    const adjusted_field = bits[0];\r\n                    verseText = verseText.substring(0, ixW) + adjusted_field + verseText.substring(ixEnd + 3);\r\n                } else {\r\n                    console.log(`Missing \\\\w* in ${bookID} ${C}:${V} verseText: '${verseText}'`);\r\n                    verseText = verseText.replace(/\\\\w /g, '', 1); // Attempt to limp on\r\n                }\r\n                ixW = verseText.indexOf('\\\\w ', ixW + 1); // Might be another one\r\n            }\r\n            // console.log(`Got verse text2: '${verseText}'`);\r\n\r\n            // Remove footnotes\r\n            verseText = verseText.replace(/\\\\f (.+?)\\\\f\\*/g, '');\r\n            // Remove alternative versifications\r\n            verseText = verseText.replace(/\\\\va (.+?)\\\\va\\*/g, '');\r\n            // console.log(`Got verse text3: '${verseText}'`);\r\n\r\n            // Final clean-up (shouldnt be necessary, but just in case)\r\n            verseText = verseText.replace(/ {2}/g, ' ');\r\n            console.assert(verseText.indexOf('\\\\w') === -1, `getOriginalPassage: Should be no \\\\w in ${bookID} ${C}:${V} '${verseText}'`);\r\n            console.assert(verseText.indexOf('\\\\k') === -1, `getOriginalPassage: Should be no \\\\k in ${bookID} ${C}:${V} '${verseText}'`);\r\n            console.assert(verseText.indexOf('x-') === -1, `getOriginalPassage: Should be no x- in ${bookID} ${C}:${V} '${verseText}'`);\r\n            console.assert(verseText.indexOf('\\\\f') === -1, `getOriginalPassage: Should be no \\\\f in ${bookID} ${C}:${V} '${verseText}'`);\r\n            console.assert(verseText.indexOf('\\\\x') === -1, `getOriginalPassage: Should be no \\\\x in ${bookID} ${C}:${V} '${verseText}'`);\r\n        }\r\n\r\n        // console.log(`  getOriginalPassage(${bookID} ${C}:${V}) is returning '${verseText}'`);\r\n        return verseText;\r\n    }\r\n    // end of getOriginalPassage function\r\n\r\n\r\n    // Main code for checkOriginalLanguageQuote\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (gcELerror) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n    // console.log(`Using supplied extractLength=${extractLength}`, `cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n    let occurrence = 1;\r\n    try { occurrence = ourParseInt(occurrenceString); } catch { } // errors in this field are noted elsewhere\r\n\r\n    // if fieldText.lstrip() !== fieldText:\r\n    //     addNotice({priority:0, message:`Unexpected whitespace at start of {TNid} '{fieldText}'\")\r\n    // if fieldText.rstrip() !== fieldText:\r\n    //     addNotice({priority:0, message:`Unexpected whitespace at end of {TNid} '{fieldText}'\")\r\n    // fieldText = fieldText.strip() # so we dont get consequential errors\r\n\r\n    let characterIndex;\r\n    if ((characterIndex = fieldText.indexOf('...')) >= 0) {\r\n        // console.log(`Bad ellipse characters in '${fieldText}'`);\r\n        const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '');\r\n        addNotice({ priority: 159, message: \"Should use proper ellipse character (not periods)\", characterIndex, extract, location: ourLocation });\r\n    }\r\n\r\n    let quoteBits;\r\n    if (fieldText.indexOf('') >= 0) {\r\n        quoteBits = fieldText.split('');\r\n        if ((characterIndex = fieldText.indexOf(' ')) >= 0 || (characterIndex = fieldText.indexOf(' ')) >= 0) {\r\n            // console.log(`Unexpected space(s) beside ellipse in '${fieldText}'`);\r\n            const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '');\r\n            addNotice({ priority: 158, message: \"Unexpected space(s) beside ellipse character\", characterIndex, extract, location: ourLocation });\r\n        }\r\n    } else if (fieldText.indexOf('') >= 0) {\r\n        quoteBits = fieldText.split('');\r\n        if ((characterIndex = fieldText.indexOf(' ')) >= 0 || (characterIndex = fieldText.indexOf(' ')) >= 0) {\r\n            // console.log(`Unexpected space(s) beside ellipse in '${fieldText}'`);\r\n            const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '');\r\n            addNotice({ priority: 157, message: \"Unexpected space(s) beside  divider character\", characterIndex, extract, location: ourLocation });\r\n        }\r\n    } else if (fieldText.indexOf('...') >= 0) { // Yes, we still actually allow this\r\n        quoteBits = fieldText.split('...');\r\n        if ((characterIndex = fieldText.indexOf(' ...')) >= 0 || (characterIndex = fieldText.indexOf('... ')) >= 0) {\r\n            // console.log(`Unexpected space(s) beside ellipse characters in '${fieldText}'`);\r\n            const extract = (characterIndex > halfLength ? '' : '') + fieldText.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < fieldText.length ? '' : '');\r\n            addNotice({ priority: 156, message: \"Unexpected space(s) beside ellipse characters\", characterIndex, extract, location: ourLocation });\r\n        }\r\n    }\r\n    // console.log(`Got quoteBits=${quoteBits}`);\r\n\r\n    // Find the verse text in the original language\r\n    let verseText;\r\n    try {\r\n        verseText = checkingOptions?.originalLanguageVerseText;\r\n    } catch (gcVTerror) { }\r\n    if (!verseText) {// not supplied, so then we need to get it ourselves\r\n        if (checkingOptions?.disableAllLinkFetchingFlag)\r\n            return colqResult; // nothing else we can do here\r\n        else {\r\n            verseText = await getOriginalPassage(bookID, C, V, checkingOptions);\r\n            if (!verseText) {\r\n                addNotice({ priority: 851, message: bookID === 'OBS' ? \"Unable to load OBS story text\" : \"Unable to load original language verse text\", location: ourLocation });\r\n                return colqResult; // nothing else we can do here\r\n            }\r\n        }\r\n    }\r\n\r\n    // Now check if the quote can be found in the verse text\r\n    if (quoteBits) { // it had an ellipsis\r\n        // console.assert(occurrence === 1, `Oh -- can get '${fieldText}' with occurrence=${occurrence} in ${bookID} ${C}:${V}`);\r\n        if (occurrence !== 1) {\r\n            addNotice({ priority: 50, message: \"Is this quote/occurrence correct???\", details: `Occurrence=${occurrence}`, extract: quoteBits, location: ourLocation });\r\n        }\r\n        const numQuoteBits = quoteBits.length;\r\n        if (numQuoteBits >= 2) {\r\n            for (let bitIndex = 0; bitIndex < numQuoteBits; bitIndex++) {\r\n                if (verseText.indexOf(quoteBits[bitIndex]) < 0) { // this is what we really want to catch\r\n                    // If the quote has multiple parts, create a description of the current part\r\n                    let partDescription;\r\n                    if (numQuoteBits === 1) partDescription = '';\r\n                    else if (bitIndex === 0) partDescription = 'beginning';\r\n                    else if (bitIndex === numQuoteBits - 1) partDescription = 'end';\r\n                    else partDescription = `middle${numQuoteBits > 3 ? bitIndex : ''}`;\r\n                    // console.log(`721 Unable to find '${fieldText}' ${numQuoteBits === 1? '': `'${quoteBits[bitIndex]}' `}${partDescription? '('+partDescription+') ':''}in '${verseText}'`);\r\n                    const extract = `${quoteBits[bitIndex]}' ${partDescription ? '(' + partDescription + ')' : ''}`;\r\n                    addNotice({ priority: 721, message: \"Unable to find original language quote in verse text\", extract, location: ourLocation });\r\n                }\r\n            }\r\n        } else // < 2\r\n            addNotice({ priority: 375, message: \"Ellipsis without surrounding snippet\", location: ourLocation });\r\n    } else { // Only a single quote (no ellipsis)\r\n        if (verseText.indexOf(fieldText) >= 0) {\r\n            if (occurrence > 1) {\r\n                // console.log(`checkOriginalLanguageQuote is checking for ${occurrence} occurrences of ${fieldText}`);\r\n                if (verseText.split(fieldText).length <= occurrence) { // There's not enough of them\r\n                    const extract = fieldText.substring(0, halfLength) + (fieldText.length > 2 * halfLength ? '' : '') + fieldText.substring(fieldText.length - halfLength, fieldText.length);\r\n                    addNotice({ priority: 917, message: \"Unable to find duplicate original language quote in verse text\", details: `occurrence=${occurrenceString}, passage ${verseText}`, extract, location: ourLocation });\r\n                }\r\n            } else { // We only need to check for one occurrence\r\n                // Double check that it doesnt start/stop in the middle of a word\r\n                // console.log(`Here with fieldText=${fieldText} and verseText=${verseText}`);\r\n                let remainingBits = verseText.split(fieldText);\r\n                // console.log(`remaingBits=${JSON.stringify(remainingBits)}`);\r\n                if (remainingBits.length > 2) // Join the extra bits back up\r\n                    remainingBits = [remainingBits[0], remainingBits.slice(1).join('')];\r\n                console.assert(remainingBits.length === 2, `remaining bits are ${remainingBits.length}`);\r\n                // Note: There's some Hebrew (RTL) characters at the beginning of the following regex\r\n                // Note: Straight quotes are included here (even though unwanted) as other code warns about them\r\n                if (fieldText.slice(0) !== ' ' && remainingBits[0] && remainingBits[0].slice(-1).search(/[^A-Za-z\\s*[(\"']/) !== -1) {\r\n                    // const badChar = remainingBits[0].slice(-1);\r\n                    // const badCharString = ` by '{badChar}' {unicodedata.name(badChar)}={hex(ord(badChar))}`;\r\n                    // console.log(`Seems '${fieldText}' might not start at the beginning of a wordits preceded ${badCharString} in '${verseText}'`);\r\n                    const extract = `(${remainingBits[0].slice(-1)}=D${remainingBits[0].slice(-1).charCodeAt()}/H${remainingBits[0].slice(-1).charCodeAt().toString(16)})` + fieldText.substring(0, extractLength - 3) + (fieldText.length > extractLength - 3 ? '' : '');\r\n                    addNotice({ priority: 620, message: \"Seems original language quote might not start at the beginning of a word\", details: `passage ${verseText}`, characterIndex: 0, extract, location: ourLocation });\r\n                }\r\n                // Note: There's some Hebrew (RTL) characters at the beginning of the following regex\r\n                if (fieldText.slice(-1) !== ' ' && remainingBits[1] && remainingBits[1][0].search(/[^A-Za-z\\s.,:;?!)]/) !== -1) {\r\n                    // const badChar = remainingBits[1][0];\r\n                    // const badCharString = ` by '${badChar}' {unicodedata.name(badChar)}={hex(ord(badChar))}`;\r\n                    // console.log(`Seems '${fieldText}' might not finish at the end of a wordits followed ${badCharString} in '${verseText}'`);\r\n                    const extract = (fieldText.length > extractLength - 3 ? '' : '') + fieldText.substring(fieldText.length - extractLength + 3, fieldText.length) + `(${remainingBits[1][0]}=D${remainingBits[1].charCodeAt(0)}/H${remainingBits[1].charCodeAt(0).toString(16)})`;\r\n                    addNotice({ priority: 621, message: \"Seems original language quote might not finish at the end of a word\", details: `passage ${verseText}`, characterIndex: fieldText.length, extract, location: ourLocation });\r\n                }\r\n            }\r\n        } else { // cant find the given text\r\n            // console.log(`Unable to find '${fieldText}' in '${verseText}'`);\r\n            const noBreakSpaceText = fieldText.indexOf('\\u00A0') >= 0 ? \"quote which contains No-Break Space shown as ''\" : \"\";\r\n            if (noBreakSpaceText) fieldText = fieldText.replace(/\\u00A0/g, '');\r\n            // console.log(`722 fieldText='${fieldText}'${extraText}`);\r\n            // console.log(`722 verseText='${verseText}'`);\r\n            if (fieldText[0] === '\\u2060') { // Word joiner\r\n                const extract = fieldText.substring(0, extractLength) + fieldText.length > extractLength ? '' : '';\r\n                addNotice({ priority: 916, message: \"Unable to find original language quote in verse text\", details: \"quote which starts with 'word joiner'\" + (noBreakSpaceText ? ' ' + noBreakSpaceText : ''), extract, location: ourLocation });\r\n            } else if (fieldText.endsWith('\\u2060')) { // Word joiner\r\n                const extract = fieldText.length > extractLength ? '' : '' + fieldText.substring(fieldText.length - extractLength, fieldText.length);\r\n                addNotice({ priority: 916, message: \"Unable to find original language quote in verse text\", details: \"quote which ends with 'word joiner'\" + (noBreakSpaceText ? ' ' + noBreakSpaceText : ''), extract, location: ourLocation });\r\n            } else if (fieldText[0] === '\\u200B') { // Zero-width space\r\n                const extract = fieldText.substring(0, extractLength) + fieldText.length > extractLength ? '' : '';\r\n                addNotice({ priority: 916, message: \"Unable to find original language quote in verse text\", details: \"quote which starts with 'zero-width space'\" + (noBreakSpaceText ? ' ' + noBreakSpaceText : ''), extract, location: ourLocation });\r\n            } else if (fieldText.endsWith('\\u200B')) { // Zero-width space\r\n                const extract = fieldText.length > extractLength ? '' : '' + fieldText.substring(fieldText.length - extractLength, fieldText.length);\r\n                addNotice({ priority: 916, message: \"Unable to find original language quote in verse text\", details: \"quote which ends with 'zero-width space'\" + (noBreakSpaceText ? ' ' + noBreakSpaceText : ''), extract, location: ourLocation });\r\n            } else if (fieldText[0] === '\\u200D') { // Zero-width joiner\r\n                const extract = fieldText.substring(0, extractLength) + fieldText.length > extractLength ? '' : '';\r\n                addNotice({ priority: 916, message: \"Unable to find original language quote in verse text\", details: \"quote which starts with 'zero-width joiner'\" + (noBreakSpaceText ? ' ' + noBreakSpaceText : ''), extract, location: ourLocation });\r\n            } else if (fieldText.endsWith('\\u200D')) { // Zero-width joiner\r\n                const extract = fieldText.length > extractLength ? '' : '' + fieldText.substring(fieldText.length - extractLength, fieldText.length);\r\n                addNotice({ priority: 916, message: \"Unable to find original language quote in verse text\", details: \"quote which ends with 'zero-width joiner'\" + (noBreakSpaceText ? ' ' + noBreakSpaceText : ''), extract, location: ourLocation });\r\n            } else {\r\n                const extract = fieldText.substring(0, halfLength) + (fieldText.length > 2 * halfLength ? '' : '') + fieldText.substring(fieldText.length - halfLength, fieldText.length);\r\n                addNotice({ priority: 916, message: \"Unable to find original language quote in verse text\", details: noBreakSpaceText ? noBreakSpaceText : `passage ${verseText}`, extract, location: ourLocation });\r\n            }\r\n        }\r\n    }\r\n\r\n    // console.log(`checkOriginalLanguageQuote is returning ${ JSON.stringify(colqResult) }`);\r\n    return colqResult;\r\n}\r\n// end of checkOriginalLanguageQuote function\r\n","import { DEFAULT_EXTRACT_LENGTH, MATCHED_PUNCTUATION_PAIRS, PAIRED_PUNCTUATION_OPENERS, PAIRED_PUNCTUATION_CLOSERS, isWhitespace, countOccurrences } from './text-handling-functions'\r\nimport { checkTextField } from './field-text-check';\r\nimport { removeDisabledNotices } from './disabled-notices';\r\n\r\n\r\nconst PLAIN_TEXT_VALIDATOR_VERSION_STRING = '0.3.11';\r\n\r\n\r\n/**\r\n *\r\n * @param {string} textType 'markdown', 'USFM', 'YAML', 'text', or 'raw'\r\n * @param {string} textName\r\n * @param {string} plainText -- text to be checked\r\n * @param {string} givenLocation\r\n * @param {Object} checkingOptions\r\n */\r\nexport function checkPlainText(textType, textName, plainText, givenLocation, checkingOptions) {\r\n    /* This function is optimised for checking the entire text, i.e., all lines.\r\n        It is used in checkFileContents() in book-package-check.js\r\n\r\n     Returns a result object containing a successList and a noticeList\r\n     */\r\n    // console.log(`checkPlainText(${textName}, (${plainText.length} chars), ${givenLocation}, ${JSON.stringify(checkingOptions)})`);\r\n    console.assert(textType !== undefined, \"checkPlainText: 'textType' parameter should be defined\");\r\n    console.assert(typeof textType === 'string', `checkPlainText: 'textType' parameter should be a string not a '${typeof textType}': ${textType}`);\r\n    console.assert(textType === 'markdown' || textType === 'USFM' || textType === 'YAML' || textType === 'text' || textType === 'raw', `checkPlainText: unrecognised 'textType' parameter: '${textType}'`);\r\n    console.assert(textName !== undefined, \"checkPlainText: 'textName' parameter should be defined\");\r\n    console.assert(typeof textName === 'string', `checkPlainText: 'textName' parameter should be a string not a '${typeof textName}': ${textName}`);\r\n    console.assert(plainText !== undefined, \"checkPlainText: 'plainText' parameter should be defined\");\r\n    console.assert(typeof plainText === 'string', `checkPlainText: 'plainText' parameter should be a string not a '${typeof plainText}': ${plainText}`);\r\n    console.assert(checkingOptions !== undefined, \"checkPlainText: 'checkingOptions' parameter should be defined\");\r\n\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (ptcError) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n    // console.log(`Using supplied extractLength=${extractLength}`, `cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n    const cptResult = { successList: [], noticeList: [] };\r\n\r\n    function addSuccessMessage(successString) {\r\n        // console.log(`checkPlainText success: ${successString}`);\r\n        cptResult.successList.push(successString);\r\n    }\r\n    function addNotice(noticeObject) {\r\n        // bookID is a three-character UPPERCASE USFM book identifier or 'OBS'.\r\n        // console.log(`checkPlainText notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : \"\"}${extract ? ` ${extract}` : \"\"}${location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"cPT addNotice: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `cPT addNotice: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"cPT addNotice: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `cPT addNotice: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cPT addNotice: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract!==undefined, \"cPT addNotice: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cPT addNotice: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"cPT addNotice: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `cPT addNotice: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n\r\n        // noticeObject.debugChain = noticeObject.debugChain ? `checkPlainText(${textType}, ${textName}) ${noticeObject.debugChain}` : `checkPlainText(${textType}, ${textName})`;\r\n        cptResult.noticeList.push(noticeObject);\r\n    }\r\n\r\n    function ourCheckTextField(lineNumber, fieldText, allowedLinks, optionalFieldLocation, checkingOptions) {\r\n        /**\r\n        * @description - checks the given text field and processes the returned results\r\n        * @param {String} fieldName - name of the field being checked\r\n        * @param {String} fieldText - the actual text of the field being checked\r\n        * @param {boolean} allowedLinks - true if links are allowed in the field, otherwise false\r\n        * @param {String} optionalFieldLocation - description of where the field is located\r\n        * @param {Object} checkingOptions - parameters that might affect the check\r\n        */\r\n        // Does basic checks for small errors like leading/trailing spaces, etc.\r\n\r\n        // We assume that checking for compulsory fields is done elsewhere\r\n\r\n        // Updates the global list of notices\r\n        // console.log(`cPT ourCheckTextField(${fieldName}, (${fieldText.length}), ${allowedLinks}, ${fieldLocation}, )`);\r\n        console.assert(lineNumber !== undefined, \"cPT ourCheckTextField: 'lineNumber' parameter should be defined\");\r\n        console.assert(typeof lineNumber === 'number', `cPT ourCheckTextField: 'fieldName' parameter should be a number not a '${typeof lineNumber}'`);\r\n        console.assert(fieldText !== undefined, \"cPT ourCheckTextField: 'fieldText' parameter should be defined\");\r\n        console.assert(typeof fieldText === 'string', `cPT ourCheckTextField: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);\r\n        console.assert(allowedLinks === true || allowedLinks === false, \"cPT ourCheckTextField: allowedLinks parameter must be either true or false\");\r\n        console.assert(optionalFieldLocation !== undefined, \"cPT ourCheckTextField: 'optionalFieldLocation' parameter should be defined\");\r\n        console.assert(typeof optionalFieldLocation === 'string', `cPT ourCheckTextField: 'optionalFieldLocation' parameter should be a string not a '${typeof optionalFieldLocation}'`);\r\n\r\n        const resultObject = checkTextField(textType, '', fieldText, allowedLinks, optionalFieldLocation, checkingOptions);\r\n\r\n        // Choose only ONE of the following\r\n        // This is the fast way of append the results from this field\r\n        // cptResult.noticeList = cptResult.noticeList.concat(resultObject.noticeList);\r\n        // If we need to put everything through addNotice, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const noticeEntry of resultObject.noticeList)\r\n            addNotice({ ...noticeEntry, lineNumber });\r\n    }\r\n    // end of ourCheckTextField function\r\n\r\n    function checkPlainLineContents(lineNumber, lineText, lineLocation) {\r\n\r\n        // console.log(`checkPlainLineContents for '${lineName}', '${lineText}' at${lineLocation}`);\r\n        let thisText = lineText.trimStart(); // So we dont get \"leading space\" AND \"doubled spaces\" errors\r\n\r\n        if (thisText)\r\n            // Allow links as thats more general\r\n            ourCheckTextField(lineNumber, thisText, true, lineLocation, checkingOptions);\r\n    }\r\n    // end of checkPlainLineContents function\r\n\r\n\r\n    // Main code for checkPlainText function\r\n    if (isWhitespace(plainText)) {\r\n        addNotice({ priority: 638, message: \"Only found whitespace\", location: ourLocation });\r\n        return cptResult;\r\n    }\r\n\r\n    let characterIndex;\r\n    if ((characterIndex = plainText.indexOf('<<<<<<<')) >= 0) {\r\n        const iy = characterIndex + halfLength; // Want extract to focus more on what follows\r\n        const extract = (iy > halfLength ? '' : '') + plainText.substring(iy - halfLength, iy + halfLengthPlus).replace(/ /g, '') + (iy + halfLengthPlus < plainText.length ? '' : '')\r\n        addNotice({ priority: 993, message: \"Unresolved GIT conflict\", characterIndex, extract, location: ourLocation });\r\n    } else if ((characterIndex = plainText.indexOf('=======')) >= 0) {\r\n        const iy = characterIndex + halfLength; // Want extract to focus more on what follows\r\n        const extract = (iy > halfLength ? '' : '') + plainText.substring(iy - halfLength, iy + halfLengthPlus).replace(/ /g, '') + (iy + halfLengthPlus < plainText.length ? '' : '')\r\n        addNotice({ priority: 992, message: \"Unresolved GIT conflict\", characterIndex, extract, location: ourLocation });\r\n    } else if ((characterIndex = plainText.indexOf('>>>>>>>>')) >= 0) {\r\n        const iy = characterIndex + halfLength; // Want extract to focus more on what follows\r\n        const extract = (iy > halfLength ? '' : '') + plainText.substring(iy - halfLength, iy + halfLengthPlus).replace(/ /g, '') + (iy + halfLengthPlus < plainText.length ? '' : '')\r\n        addNotice({ priority: 991, message: \"Unresolved GIT conflict\", characterIndex, extract, location: ourLocation });\r\n    }\r\n\r\n    if (plainText[0] === '\\n') {\r\n        characterIndex = 0;\r\n        const extract = (plainText.length > extractLength ? '' : '') + plainText.slice(-extractLength).replace(/ /g, '').replace(/\\n/g, '\\\\n')\r\n        addNotice({ priority: 539, message: \"File starts with empty line\", characterIndex, extract, location: ourLocation });\r\n    }\r\n    if (!plainText.endsWith('\\n') && !textName.endsWith('title.md')) {\r\n        characterIndex = plainText.length - 1;\r\n        const extract = (plainText.length > extractLength ? '' : '') + plainText.slice(-extractLength).replace(/ /g, '').replace(/\\n/g, '\\\\n')\r\n        addNotice({ priority: 538, message: \"File ends without newline character\", characterIndex, extract, location: ourLocation });\r\n    }\r\n    else if (plainText.endsWith('\\n\\n')) {\r\n        characterIndex = plainText.length - 2;\r\n        const extract = (plainText.length > extractLength ? '' : '') + plainText.slice(-extractLength).replace(/ /g, '').replace(/\\n/g, '\\\\n')\r\n        addNotice({ priority: 138, message: \"File ends with additional blank line(s)\", characterIndex, extract, location: ourLocation });\r\n    }\r\n\r\n    const lines = plainText.split('\\n');\r\n    // console.log(`  '${location}' has ${lines.length.toLocaleString()} total lines`);\r\n    //  checking nested markers (so that we can give the line number in the notice)\r\n    // let headerLevel = 0;\r\n    // let lastNumLeadingSpaces = 0;\r\n    // let lastLineContents;\r\n    // While checking individual lines,\r\n    const openMarkers = [];\r\n    for (let n = 1; n <= lines.length; n++) {\r\n\r\n        const line = lines[n - 1];\r\n        if (line) {\r\n            if (textType === 'text' || textType === 'raw') // other file-types do these checks themselves\r\n                checkPlainLineContents(n, line, ourLocation);\r\n\r\n            // Check for nested brackets and quotes, etc.\r\n            for (let characterIndex = 0; characterIndex < line.length; characterIndex++) {\r\n                const char = line[characterIndex];\r\n                let closeCharacterIndex;\r\n                if (PAIRED_PUNCTUATION_OPENERS.indexOf(char) >= 0) {\r\n                    // console.log(`Saving ${openMarkers.length} '${char}' ${n} ${x}`);\r\n                    openMarkers.push({ char, n, x: characterIndex });\r\n                } else if ((closeCharacterIndex = PAIRED_PUNCTUATION_CLOSERS.indexOf(char)) >= 0) {\r\n                    // console.log(`Found '${char}' ${n} ${x}`);\r\n                    // console.log(`Which: ${which} '${openers.charAt(which)}'`)\r\n                    if (openMarkers.length) {\r\n                        const [lastEntry] = openMarkers.slice(-1);\r\n                        // console.log(`  Recovered lastEntry=${JSON.stringify(lastEntry)}`);\r\n                        // console.log(`  Comparing found '${char}' with (${which}) '${openers.charAt(which)}' from '${lastEntry.char}'`);\r\n                        if (lastEntry.char === PAIRED_PUNCTUATION_OPENERS.charAt(closeCharacterIndex)) {\r\n                            // console.log(`  Matched '${char}' with  '${openers.charAt(which)}' ${n} ${x}`);\r\n                            openMarkers.pop();\r\n                        } else // something is still open and this isnt a match -- might just be consequential error\r\n                            if (char !== '' // Closing single quote is also used as apostrophe in English\r\n                                && (textType !== 'markdown' || char !== '>' || characterIndex > 4)) { // Markdown uses > or >> or > > or > > > for block indents so ignore these -- might just be consequential error\r\n                                const extract = (characterIndex > halfLength ? '' : '') + line.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/ /g, '') + (characterIndex + halfLengthPlus < line.length ? '' : '')\r\n                                const details = `'${lastEntry.char}' opened on line ${lastEntry.n} character ${lastEntry.x + 1}`;\r\n                                addNotice({ priority: 777, message: `Bad punctuation nesting: ${char} closing character doesnt match`, details, lineNumber: n, characterIndex, extract, location: ourLocation });\r\n                                // console.log(`  ERROR 777: mismatched characters: ${details}`);\r\n                            }\r\n                    } else // Closed something unexpectedly without an opener\r\n                        if (char !== '' // Closing single quote is also used as apostrophe in English\r\n                            && (textType !== 'markdown' || char !== '>')) { // Markdown uses > for block indents so ignore these\r\n                            const extract = (characterIndex > halfLength ? '' : '') + line.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/ /g, '') + (characterIndex + halfLengthPlus < line.length ? '' : '')\r\n                            addNotice({ priority: 774, message: `Unexpected ${char} closing character (no matching opener)`, lineNumber: n, characterIndex, extract, location: ourLocation });\r\n                            // console.log(`  ERROR 774: closed with nothing open: ${char}`);\r\n                        }\r\n                }\r\n\r\n            }\r\n        } else {\r\n            // This is a blank line\r\n        }\r\n\r\n        // lastLineContents = line;\r\n    }\r\n    //  At the end of the text -- check for left-over opening characters (unclosed)\r\n    if (openMarkers.length) {\r\n        const [{ char, n, x }] = openMarkers.slice(-1);\r\n        const line = lines[n - 1];\r\n        const extract = (x > halfLength ? '' : '') + line.substring(x - halfLength, x + halfLengthPlus).replace(/ /g, '') + (x + halfLengthPlus < line.length ? '' : '')\r\n        const details = openMarkers.length > 1 ? `${openMarkers.length} unclosed set${openMarkers.length === 1 ? '' : 's'}` : null;\r\n        addNotice({ priority: 768, message: `At end of text with unclosed ${char} opening character`, details, lineNumber: n, characterIndex: x, extract, location: ourLocation });\r\n    }\r\n\r\n    // TODO: Is this a duplicate of the above section about nesting?\r\n    // Check matched pairs in the entire file\r\n    for (const punctSet of MATCHED_PUNCTUATION_PAIRS) {\r\n        // Cant check '' coz they might be used as apostrophe\r\n        const leftChar = punctSet[0], rightChar = punctSet[1];\r\n        const leftCount = countOccurrences(plainText, leftChar),\r\n            rightCount = countOccurrences(plainText, rightChar);\r\n        if (leftCount !== rightCount\r\n            && (rightChar !== '' || leftCount > rightCount) // Closing single quote is also used as apostrophe in English\r\n            && (textType !== 'markdown' || rightChar !== '>')) // markdown uses > as a block quote character\r\n            // NOTE: These are lower priority than similar checks in a field\r\n            //          since they occur only within the entire file\r\n            addNotice({ priority: leftChar === '' ? 162 : 462, message: `Mismatched ${leftChar}${rightChar} characters`, details: `left=${leftCount.toLocaleString()}, right=${rightCount.toLocaleString()}`, location: ourLocation });\r\n    }\r\n\r\n    if (!checkingOptions?.suppressNoticeDisablingFlag) {\r\n        // console.log(`checkPlainText: calling removeDisabledNotices(${cptResult.noticeList.length}) having ${JSON.stringify(checkingOptions)}`);\r\n        cptResult.noticeList = removeDisabledNotices(cptResult.noticeList);\r\n    }\r\n\r\n    addSuccessMessage(`Checked all ${lines.length.toLocaleString()} line${lines.length === 1 ? '' : 's'}${ourLocation}.`);\r\n    if (cptResult.noticeList)\r\n        addSuccessMessage(`checkPlainText v${PLAIN_TEXT_VALIDATOR_VERSION_STRING} finished with ${cptResult.noticeList.length ? cptResult.noticeList.length.toLocaleString() : \"zero\"} notice${cptResult.noticeList.length === 1 ? '' : 's'}`);\r\n    else\r\n        addSuccessMessage(`No errors or warnings found by checkPlainText v${PLAIN_TEXT_VALIDATOR_VERSION_STRING}`)\r\n    // console.log(`  checkPlainText returning with ${result.successList.length.toLocaleString()} success(es), ${result.noticeList.length.toLocaleString()} notice(s).`);\r\n    // console.log(\"checkPlainText result is\", JSON.stringify(result));\r\n    return cptResult;\r\n}\r\n// end of checkPlainText function\r\n","import { DEFAULT_EXTRACT_LENGTH } from './text-handling-functions'\r\nimport yaml from 'yaml';\r\nimport { checkTextField } from './field-text-check';\r\nimport { checkTextfileContents } from './file-text-check';\r\nimport { removeDisabledNotices } from './disabled-notices';\r\n\r\nconst YAML_VALIDATOR_VERSION_STRING = '0.4.2';\r\n\r\n\r\nexport function checkYAMLText(languageCode, textName, YAMLText, givenLocation, checkingOptions) {\r\n    /* This function is optimised for checking the entire file, i.e., all lines.\r\n\r\n     Returns a result object containing a successList and a noticeList,\r\n        as well as the parsed YAML for further checking.\r\n\r\n     */\r\n    // console.log(`checkYAMLText(${textName}, ${YAMLText.length}, ${givenLocation})`);\r\n    console.assert(languageCode !== undefined, \"checkYAMLText: 'languageCode' parameter should be defined\");\r\n    console.assert(typeof languageCode === 'string', `checkYAMLText: 'languageCode' parameter should be a string not a '${typeof languageCode}': ${languageCode}`);\r\n    console.assert(textName !== undefined, \"checkYAMLText: 'textName' parameter should be defined\");\r\n    console.assert(typeof textName === 'string', `checkYAMLText: 'textName' parameter should be a string not a '${typeof textName}': ${textName}`);\r\n    console.assert(YAMLText !== undefined, \"checkYAMLText: 'YAMLText' parameter should be defined\");\r\n    console.assert(typeof YAMLText === 'string', `checkYAMLText: 'YAMLText' parameter should be a string not a '${typeof YAMLText}': ${YAMLText}`);\r\n    console.assert(givenLocation !== undefined, \"checkYAMLText: 'optionalFieldLocation' parameter should be defined\");\r\n    console.assert(typeof givenLocation === 'string', `checkYAMLText: 'optionalFieldLocation' parameter should be a string not a '${typeof givenLocation}': ${givenLocation}`);\r\n    console.assert(givenLocation.indexOf('true') === -1, `checkYAMLText: 'optionalFieldLocation' parameter should not be '${givenLocation}'`);\r\n    console.assert(checkingOptions !== undefined, \"checkYAMLText: 'checkingOptions' parameter should be defined\");\r\n    if (checkingOptions !== undefined)\r\n        console.assert(typeof checkingOptions === 'object', `checkYAMLText: 'checkingOptions' parameter should be an object not a '${typeof checkingOptions}': ${JSON.stringify(checkingOptions)}`);\r\n\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n    // if (textName) ourLocation = ` in ${textName}${ourLocation}`;\r\n\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (ytcError) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n    // console.log(`Using supplied extractLength=${extractLength}`, `cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    // const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    // const halfLengthPlus = Math.floor((extractLength+1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n    const cytResult = { successList: [], noticeList: [] };\r\n\r\n    function addSuccessMessage(successString) {\r\n        // console.log(`checkYAMLText success: ${successString}`);\r\n        cytResult.successList.push(successString);\r\n    }\r\n    function addNotice(noticeObject) {\r\n        // console.log(`checkYAMLText Notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : \"\"}${extract ? ` ${extract}` : \"\"}${location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"cYt addNotice: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `cManT addNotice: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"cYt addNotice: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `cManT addNotice: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(characterIndex!==undefined, \"cYt addNotice: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cManT addNotice: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract!==undefined, \"cYt addNotice: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cManT addNotice: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"cYt addNotice: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `cYt addNotice: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n        if (noticeObject.debugChain) noticeObject.debugChain = `checkYAMLText ${noticeObject.debugChain}`;\r\n        cytResult.noticeList.push(noticeObject);\r\n    }\r\n\r\n    function ourCheckTextField(lineNumber, fieldText, allowedLinks, optionalFieldLocation, checkingOptions) {\r\n        /**\r\n        * @description - checks the given text field and processes the returned results\r\n        * @param {String} fieldName - name of the field being checked\r\n        * @param {String} fieldText - the actual text of the field being checked\r\n        * @param {boolean} allowedLinks - true if links are allowed in the field, otherwise false\r\n        * @param {String} optionalFieldLocation - description of where the field is located\r\n        * @param {Object} checkingOptions - parameters that might affect the check\r\n        */\r\n        // Does basic checks for small errors like leading/trailing spaces, etc.\r\n\r\n        // We assume that checking for compulsory fields is done elsewhere\r\n\r\n        // Updates the global list of notices\r\n        // console.log(`cYt ourCheckTextField(${fieldName}, (${fieldText.length}), ${allowedLinks}, ${fieldLocation}, )`);\r\n        console.assert(fieldText !== undefined, \"cYt ourCheckTextField: 'fieldText' parameter should be defined\");\r\n        console.assert(typeof fieldText === 'string', `cYt ourCheckTextField: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);\r\n        console.assert(allowedLinks === true || allowedLinks === false, \"cYt ourCheckTextField: allowedLinks parameter must be either true or false\");\r\n        console.assert(optionalFieldLocation !== undefined, \"cYt ourCheckTextField: 'optionalFieldLocation' parameter should be defined\");\r\n        console.assert(typeof optionalFieldLocation === 'string', `cYt ourCheckTextField: 'optionalFieldLocation' parameter should be a string not a '${typeof optionalFieldLocation}'`);\r\n\r\n        const resultObject = checkTextField('YAML', '', fieldText, allowedLinks, optionalFieldLocation, checkingOptions);\r\n\r\n        // Concat is faster if we dont need to process each notice individually\r\n        // cytResult.noticeList = cytResult.noticeList.concat(resultObject.noticeList);\r\n        // // Process noticeList line by line\r\n        // //  suppressing undesired errors\r\n        for (const noticeEntry of resultObject.noticeList)\r\n            addNotice({ ...noticeEntry, lineNumber });\r\n    }\r\n    // end of ourCheckTextField function\r\n\r\n    function checkYAMLLineContents(lineNumber, lineText, lineLocation) {\r\n\r\n        // console.log(`checkYAMLLineContents for '${lineNumber} ${lineText}' at${lineLocation}`);\r\n        let thisText = lineText\r\n\r\n        // Remove leading spaces\r\n        thisText = thisText.replace(/^ +/g, '')\r\n        // console.log(`After removing leading spaces have '${thisText}'`);\r\n\r\n        // Remove leading hyphens\r\n        thisText = thisText.replace(/^-/g, '')\r\n        // console.log(`After removing hyphens have '${thisText}'`);\r\n\r\n        // Remove leading spaces again now\r\n        thisText = thisText.replace(/^ +/g, '')\r\n        // console.log(`After removing more leading spaces have '${thisText}'`);\r\n\r\n        const allowedLinksInLine = thisText.startsWith('url:') || thisText.startsWith('chapter_url:') || thisText.startsWith('rc:');\r\n        if (thisText)\r\n            ourCheckTextField(lineNumber, thisText, allowedLinksInLine, lineLocation, checkingOptions);\r\n    }\r\n    // end of checkYAMLLine function\r\n\r\n\r\n    function ourBasicFileChecks(filename, fileText, fileLocation, checkingOptions) {\r\n        // Does basic checks for small errors like leading/trailing spaces, etc.\r\n\r\n        // We assume that checking for compulsory fields is done elsewhere\r\n\r\n        // Updates the global list of notices\r\n        console.assert(filename !== undefined, \"cYT ourBasicFileChecks: 'filename' parameter should be defined\");\r\n        console.assert(typeof filename === 'string', `cYT ourBasicFileChecks: 'filename' parameter should be a string not a '${typeof filename}'`);\r\n        console.assert(fileText !== undefined, \"cYT ourBasicFileChecks: 'fileText' parameter should be defined\");\r\n        console.assert(typeof fileText === 'string', `cYT ourBasicFileChecks: 'fileText' parameter should be a string not a '${typeof fileText}'`);\r\n        console.assert(checkingOptions !== undefined, \"cYT ourBasicFileChecks: 'checkingOptions' parameter should be defined\");\r\n\r\n        const resultObject = checkTextfileContents(languageCode, 'YAML', filename, fileText, fileLocation, checkingOptions);\r\n\r\n        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const noticeEntry of resultObject.noticeList) {\r\n            console.assert(Object.keys(noticeEntry).length >= 5, `USFM ourBasicFileChecks notice length=${Object.keys(noticeEntry).length}`);\r\n            addNotice(noticeEntry);\r\n        }\r\n    }\r\n    // end of ourBasicFileChecks function\r\n\r\n\r\n    // Main code for checkYAMLText function\r\n    const lines = YAMLText.split('\\n');\r\n    // console.log(`  '${location}' has ${lines.length.toLocaleString()} total lines`);\r\n    let formData;\r\n    try {\r\n        formData = yaml.parse(YAMLText);\r\n        // console.log(\"yaml.parse(YAMLText) got formData\", JSON.stringify(formData));\r\n    }\r\n    catch (yamlError) {\r\n        // console.error(`yaml parse error: ${yamlError.message}`);\r\n        addNotice({ priority: 920, message: yamlError.message, location: ourLocation })\r\n    }\r\n    // Add the parsed YAML to our result\r\n    cytResult.formData = formData;\r\n\r\n    // let lastNumLeadingSpaces = 0;\r\n    // let lastLineContents;\r\n    for (let n = 1; n <= lines.length; n++) {\r\n\r\n        const line = lines[n - 1];\r\n        // let numLeadingSpaces;\r\n        // if (line) {\r\n        //     numLeadingSpaces = line.match(/^ */)[0].length;\r\n        // console.log(`Got numLeadingSpaces=${numLeadingSpaces} for ${line}${atString}`);\r\n        //     if (numLeadingSpaces && lastNumLeadingSpaces && numLeadingSpaces!=lastNumLeadingSpaces)\r\n        //         addNotice({472, \"Nesting seems confused\", 0, '', atString);\r\n\r\n        checkYAMLLineContents(n, line, ourLocation);\r\n        // } else {\r\n        //     // This is a blank line\r\n        //     numLeadingSpaces = 0;\r\n        // }\r\n\r\n        // lastLineContents = line;\r\n        // lastNumLeadingSpaces = numLeadingSpaces;\r\n    }\r\n\r\n    // Do basic file checks\r\n    ourBasicFileChecks(textName, YAMLText, givenLocation, checkingOptions);\r\n\r\n    if (!checkingOptions?.suppressNoticeDisablingFlag) {\r\n        // console.log(`checkYAMLText: calling removeDisabledNotices(${cytResult.noticeList.length}) having ${JSON.stringify(checkingOptions)}`);\r\n        cytResult.noticeList = removeDisabledNotices(cytResult.noticeList);\r\n    }\r\n\r\n    addSuccessMessage(`Checked all ${lines.length.toLocaleString()} line${lines.length === 1 ? '' : 's'}${ourLocation}.`);\r\n    if (cytResult.noticeList)\r\n        addSuccessMessage(`checkYAMLText v${YAML_VALIDATOR_VERSION_STRING} finished with ${cytResult.noticeList.length ? cytResult.noticeList.length.toLocaleString() : \"zero\"} notice${cytResult.noticeList.length === 1 ? '' : 's'}`);\r\n    else\r\n        addSuccessMessage(`No errors or warnings found by checkYAMLText v${YAML_VALIDATOR_VERSION_STRING}`)\r\n    // console.log(`  checkYAMLText returning with ${cytResult.successList.length.toLocaleString()} success(es), ${cytResult.noticeList.length.toLocaleString()} notice(s).`);\r\n    // console.log(\"checkYAMLText result is\", JSON.stringify(result));\r\n    return cytResult;\r\n}\r\n// end of checkYAMLText function\r\n","import { DEFAULT_EXTRACT_LENGTH, isWhitespace } from './text-handling-functions'\r\nimport * as books from './books/books';\r\nimport { checkTextField } from './field-text-check';\r\nimport { checkMarkdownText } from './markdown-text-check';\r\nimport { checkSupportReferenceInTA } from './ta-reference-check';\r\nimport { checkTNLinksToOutside } from './tn-links-check';\r\nimport { checkOriginalLanguageQuote } from './orig-quote-check';\r\n\r\n\r\n// const TN_TABLE_ROW_VALIDATOR_VERSION_STRING = '0.6.4';\r\n\r\nconst NUM_EXPECTED_TN_TSV_FIELDS = 9; // so expects 8 tabs per line\r\nconst EXPECTED_TN_HEADING_LINE = 'Book\\tChapter\\tVerse\\tID\\tSupportReference\\tOrigQuote\\tOccurrence\\tGLQuote\\tOccurrenceNote';\r\n\r\nconst LC_ALPHABET = 'abcdefghijklmnopqrstuvwxyz';\r\nconst LC_ALPHABET_PLUS_DIGITS = 'abcdefghijklmnopqrstuvwxyz0123456789';\r\nconst LC_ALPHABET_PLUS_DIGITS_PLUS_HYPHEN = 'abcdefghijklmnopqrstuvwxyz0123456789-';\r\n\r\nconst TA_REGEX = new RegExp('\\\\[\\\\[rc://[^ /]+?/ta/man/[^ /]+?/([^ \\\\]]+?)\\\\]\\\\]', 'g');\r\n\r\n\r\n/**\r\n *\r\n * @description - Checks one TSV data row of translation notes (TN2)\r\n * @param {String} languageCode - the language code, e.g., 'en'\r\n * @param {String} annotationType - TN2, TQ2, TWL, SN, or SQ -- allows more specific checks\r\n * @param {String} line - the TSV line to be checked\r\n * @param {String} bookID - 3-character UPPERCASE USFM book identifier or 'OBS'\r\n * @param {String} givenC - chapter number or (for OBS) story number string\r\n * @param {String} givenV - verse number or (for OBS) frame number string\r\n * @param {String} givenRowLocation - description of where the line is located\r\n * @param {Object} checkingOptions - may contain extractLength parameter\r\n * @return {Object} - containing noticeList\r\n */\r\nexport async function checkTN_TSVDataRow(languageCode, line, bookID, givenC, givenV, givenRowLocation, checkingOptions) {\r\n    /* This function is only for checking one data row\r\n          and the function doesnt assume that it has any previous context.\r\n\r\n        Its designed to be able to quickly show errors for a single row being displayed/edited.\r\n\r\n        Returns an object containing the noticeList.\r\n    */\r\n    // console.log(`checkTN_TSVDataRow(${languageCode}, ${line}, ${bookID}, ${givenRowLocation}, ${JSON.stringify(checkingOptions)})`);\r\n    console.assert(languageCode !== undefined, \"checkTN_TSVDataRow: 'languageCode' parameter should be defined\");\r\n    console.assert(typeof languageCode === 'string', `checkTN_TSVDataRow: 'languageCode' parameter should be a string not a '${typeof languageCode}'`);\r\n    console.assert(line !== undefined, \"checkTN_TSVDataRow: 'line' parameter should be defined\");\r\n    console.assert(typeof line === 'string', `checkTN_TSVDataRow: 'line' parameter should be a string not a '${typeof line}'`);\r\n    console.assert(bookID !== undefined, \"checkTN_TSVDataRow: 'bookID' parameter should be defined\");\r\n    console.assert(typeof bookID === 'string', `checkTN_TSVDataRow: 'bookID' parameter should be a string not a '${typeof bookID}'`);\r\n    console.assert(bookID.length === 3, `checkTN_TSVDataRow: 'bookID' parameter should be three characters long not ${bookID.length}`);\r\n    console.assert(bookID.toUpperCase() === bookID, `checkTN_TSVDataRow: 'bookID' parameter should be UPPERCASE not '${bookID}'`);\r\n    console.assert(books.isValidBookID(bookID), `checkTN_TSVDataRow: '${bookID}' is not a valid USFM book identifier`);\r\n    // console.assert(givenC !== undefined, \"checkTN_TSVDataRow: 'givenC' parameter should be defined\");\r\n    if (givenC) console.assert(typeof givenC === 'string', `checkTN_TSVDataRow: 'givenC' parameter should be a string not a '${typeof givenC}'`);\r\n    // console.assert(givenV !== undefined, \"checkTN_TSVDataRow: 'givenV' parameter should be defined\");\r\n    if (givenV) console.assert(typeof givenV === 'string', `checkTN_TSVDataRow: 'givenV' parameter should be a string not a '${typeof givenV}'`);\r\n    console.assert(givenRowLocation !== undefined, \"checkTN_TSVDataRow: 'givenRowLocation' parameter should be defined\");\r\n    console.assert(typeof givenRowLocation === 'string', `checkTN_TSVDataRow: 'givenRowLocation' parameter should be a string not a '${typeof givenRowLocation}'`);\r\n\r\n    let ourRowLocation = givenRowLocation;\r\n    if (ourRowLocation && ourRowLocation[0] !== ' ') ourRowLocation = ` ${ourRowLocation}`;\r\n\r\n    const linkCheckingOptions = { ...checkingOptions };\r\n    linkCheckingOptions.taRepoLanguageCode = languageCode;\r\n\r\n    let drResult = { noticeList: [] };\r\n\r\n    function addNoticePartial(noticeObject) {\r\n        /**\r\n        * @description - adds a new notice entry, adding bookID,C,V to the given fields\r\n        * @param {Number} priority - notice priority from 1 (lowest) to 999 (highest)\r\n        * @param {String} message - the text of the notice message\r\n        * @param {String} rowID - 4-character row ID field\r\n        * @param {Number} lineNumber - one-based line number\r\n        * @param {Number} characterIndex - zero-based index of where the issue occurs in the line\r\n        * @param {String} extract - short extract from the line centred on the problem (if available)\r\n        * @param {String} location - description of where the issue is located\r\n        */\r\n        // console.log(`checkTN_TSVDataRow addNoticePartial(priority=${noticeObject.priority}) ${noticeObject.message}, ${noticeObject.characterIndex}, ${noticeObject.extract}, ${noticeObject.location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"checkTN_TSVDataRow addNoticePartial: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `checkTN_TSVDataRow addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"checkTN_TSVDataRow addNoticePartial: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `checkTN_TSVDataRow addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(lineNumber !== undefined, \"checkTN_TSVDataRow addNoticePartial: 'lineNumber' parameter should be defined\");\r\n        // console.assert(typeof lineNumber === 'number', `checkTN_TSVDataRow addNoticePartial: 'lineNumber' parameter should be a number not a '${typeof lineNumber}': ${lineNumber}`);\r\n        // console.assert(characterIndex !== undefined, \"checkTN_TSVDataRow addNoticePartial: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `checkTN_TSVDataRow addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract !== undefined, \"checkTN_TSVDataRow addNoticePartial: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `checkTN_TSVDataRow addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"checkTN_TSVDataRow addNoticePartial: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `checkTN_TSVDataRow addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n        // noticeObject.debugChain = noticeObject.debugChain ? `checkTN_TSVDataRow ${noticeObject.debugChain}` : 'checkTN_TSVDataRow';\r\n        // Also uses the given bookID,C,V, parameters from the main function call\r\n        drResult.noticeList.push({ ...noticeObject, bookID, C: givenC, V: givenV });\r\n    }\r\n\r\n    async function ourMarkdownTextChecks(rowID, fieldName, fieldText, allowedLinks, rowLocation, checkingOptions) {\r\n        /**\r\n        * @description - checks the given markdown field and processes the returned results\r\n        * @param {String} rowID - 4-character row ID field\r\n        * @param {String} fieldName - name of the field being checked\r\n        * @param {String} fieldText - the actual text of the field being checked\r\n        * @param {} allowedLinks - true if links are allowed in the field, otherwise false\r\n        * @param {String} rowLocation - description of where the line is located\r\n        * @param {Object} checkingOptions - parameters that might affect the check\r\n        */\r\n        // Does markdown checks for small errors like leading/trailing spaces, etc.\r\n\r\n        // We assume that checking for compulsory fields is done elsewhere\r\n\r\n        // Updates the global list of notices\r\n\r\n        // We dont currently use the allowedLinks parameter\r\n\r\n        // console.log(`checkTN_TSVDataRow ourCheckTextField(${fieldName}, (${fieldText.length}), ${allowedLinks}, ${rowLocation}, )`);\r\n        console.assert(rowID !== undefined, \"checkTN_TSVDataRow ourMarkdownTextChecks: 'rowID' parameter should be defined\");\r\n        console.assert(typeof rowID === 'string', `checkTN_TSVDataRow ourMarkdownTextChecks: 'rowID' parameter should be a string not a '${typeof rowID}'`);\r\n        // console.assert(fieldName !== undefined, \"checkTN_TSVDataRow ourMarkdownTextChecks: 'fieldName' parameter should be defined\");\r\n        // console.assert(typeof fieldName === 'string', `checkTN_TSVDataRow ourMarkdownTextChecks: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);\r\n        console.assert(fieldName === 'OccurrenceNote', \"checkTN_TSVDataRow ourMarkdownTextChecks: Only run this check on OccurrenceNotes\")\r\n        console.assert(fieldText !== undefined, \"checkTN_TSVDataRow ourMarkdownTextChecks: 'fieldText' parameter should be defined\");\r\n        console.assert(typeof fieldText === 'string', `checkTN_TSVDataRow ourMarkdownTextChecks: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);\r\n        console.assert(allowedLinks === true || allowedLinks === false, \"checkTN_TSVDataRow ourMarkdownTextChecks: allowedLinks parameter must be either true or false\");\r\n        console.assert(rowLocation !== undefined, \"checkTN_TSVDataRow ourMarkdownTextChecks: 'rowLocation' parameter should be defined\");\r\n        console.assert(typeof rowLocation === 'string', `checkTN_TSVDataRow ourMarkdownTextChecks: 'rowLocation' parameter should be a string not a '${typeof rowLocation}'`);\r\n        console.assert(rowLocation.indexOf(fieldName) < 0, `checkTN_TSVDataRow ourMarkdownTextChecks: 'rowLocation' parameter should be not contain fieldName=${fieldName}`);\r\n\r\n        const omtcResultObject = await checkMarkdownText(languageCode, fieldName, fieldText, rowLocation, checkingOptions);\r\n\r\n        // Choose only ONE of the following\r\n        // This is the fast way of append the results from this field\r\n        // result.noticeList = result.noticeList.concat(cmtResultObject.noticeList);\r\n        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const noticeEntry of omtcResultObject.noticeList) {\r\n            // console.assert(Object.keys(noticeEntry).length === 5, `TL ourMarkdownTextChecks notice length=${Object.keys(noticeEntry).length}`);\r\n            // NOTE: Ellipses in OccurrenceNote have the normal meaning\r\n            //          not like the specialised meaning in the snippet fields OrigQuote and GLQuote\r\n            if (noticeEntry.priority !== 178 && noticeEntry.priority !== 179 // unexpected space after ellipse, ellipse after space\r\n                && !noticeEntry.message.startsWith(\"Unexpected  character after space\") // 191\r\n            )\r\n                addNoticePartial({ ...noticeEntry, rowID, fieldName });\r\n        }\r\n        return omtcResultObject.suggestion; // There may or may not be one!\r\n    }\r\n    // end of ourMarkdownTextChecks function\r\n\r\n    function ourCheckTextField(rowID, fieldName, fieldText, allowedLinks, rowLocation, checkingOptions) {\r\n        /**\r\n        * @description - checks the given text field and processes the returned results\r\n        * @param {String} rowID - 4-character row ID field\r\n        * @param {String} fieldName - name of the field being checked\r\n        * @param {String} fieldText - the actual text of the field being checked\r\n        * @param {boolean} allowedLinks - true if links are allowed in the field, otherwise false\r\n        * @param {String} rowLocation - description of where the line is located\r\n        * @param {Object} checkingOptions - parameters that might affect the check\r\n        */\r\n        // Does basic checks for small errors like leading/trailing spaces, etc.\r\n\r\n        // We assume that checking for compulsory fields is done elsewhere\r\n\r\n        // Updates the global list of notices\r\n\r\n        // console.log(`checkTN_TSVDataRow ourCheckTextField(${fieldName}, (${fieldText.length}), ${allowedLinks}, ${rowLocation}, )`);\r\n        console.assert(rowID !== undefined, \"checkTN_TSVDataRow ourCheckTextField: 'rowID' parameter should be defined\");\r\n        console.assert(typeof rowID === 'string', `checkTN_TSVDataRow ourCheckTextField: 'rowID' parameter should be a string not a '${typeof rowID}'`);\r\n        console.assert(fieldName !== undefined, \"checkTN_TSVDataRow ourCheckTextField: 'fieldName' parameter should be defined\");\r\n        console.assert(typeof fieldName === 'string', `checkTN_TSVDataRow ourCheckTextField: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);\r\n        console.assert(fieldText !== undefined, \"checkTN_TSVDataRow ourCheckTextField: 'fieldText' parameter should be defined\");\r\n        console.assert(typeof fieldText === 'string', `checkTN_TSVDataRow ourCheckTextField: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);\r\n        console.assert(allowedLinks === true || allowedLinks === false, \"checkTN_TSVDataRow ourCheckTextField: allowedLinks parameter must be either true or false\");\r\n        console.assert(rowLocation !== undefined, \"checkTN_TSVDataRow ourCheckTextField: 'rowLocation' parameter should be defined\");\r\n        console.assert(typeof rowLocation === 'string', `checkTN_TSVDataRow ourCheckTextField: 'rowLocation' parameter should be a string not a '${typeof rowLocation}'`);\r\n        console.assert(rowLocation.indexOf(fieldName) < 0, `checkTN_TSVDataRow ourCheckTextField: 'rowLocation' parameter should be not contain fieldName=${fieldName}`);\r\n\r\n        const fieldType = fieldName === 'OccurrenceNote' ? 'markdown' : 'raw';\r\n        const octfResultObject = checkTextField(fieldType, fieldName, fieldText, allowedLinks, rowLocation, checkingOptions);\r\n\r\n        // Choose only ONE of the following\r\n        // This is the fast way of append the results from this field\r\n        // result.noticeList = result.noticeList.concat(dbtcResultObject.noticeList);\r\n        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const noticeEntry of octfResultObject.noticeList) {\r\n            // console.assert(Object.keys(noticeEntry).length === 5, `TL ourCheckTextField notice length=${Object.keys(noticeEntry).length}`);\r\n            addNoticePartial({ ...noticeEntry, rowID, fieldName });\r\n        }\r\n        return octfResultObject.suggestion; // There may or may not be one!\r\n    }\r\n    // end of ourCheckTextField function\r\n\r\n    async function ourCheckSupportReferenceInTA(rowID, fieldName, taLinkText, rowLocation, checkingOptions) {\r\n        // Checks that the TA reference can be found\r\n\r\n        // Updates the global list of notices\r\n\r\n        // console.log(`checkTN_TSVDataRow ourCheckSupportReferenceInTA(${fieldName}, (${taLinkText.length}) '${taLinkText}', ${rowLocation}, )`);\r\n        console.assert(rowID !== undefined, \"checkTN_TSVDataRow ourCheckSupportReferenceInTA: 'rowID' parameter should be defined\");\r\n        console.assert(typeof rowID === 'string', `checkTN_TSVDataRow ourCheckSupportReferenceInTA: 'rowID' parameter should be a string not a '${typeof rowID}'`);\r\n        console.assert(fieldName !== undefined, \"checkTN_TSVDataRow ourCheckSupportReferenceInTA: 'fieldName' parameter should be defined\");\r\n        console.assert(typeof fieldName === 'string', `checkTN_TSVDataRow ourCheckSupportReferenceInTA: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);\r\n        console.assert(taLinkText !== undefined, \"checkTN_TSVDataRow ourCheckSupportReferenceInTA: 'taLinkText' parameter should be defined\");\r\n        console.assert(typeof taLinkText === 'string', `checkTN_TSVDataRow ourCheckSupportReferenceInTA: 'taLinkText' parameter should be a string not a '${typeof taLinkText}'`);\r\n        console.assert(rowLocation.indexOf(fieldName) < 0, `checkTN_TSVDataRow ourCheckSupportReferenceInTA: 'rowLocation' parameter should be not contain fieldName=${fieldName}`);\r\n\r\n        const coqResultObject = await checkSupportReferenceInTA(fieldName, taLinkText, rowLocation, { ...checkingOptions, taRepoLanguageCode: languageCode });\r\n\r\n        // Choose only ONE of the following\r\n        // This is the fast way of append the results from this field\r\n        // result.noticeList = result.noticeList.concat(coqResultObject.noticeList);\r\n        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const noticeEntry of coqResultObject.noticeList) {\r\n            // console.assert(Object.keys(noticeEntry).length === 5, `TL ourCheckSupportReferenceInTA notice length=${Object.keys(noticeEntry).length}`);\r\n            addNoticePartial({ ...noticeEntry, rowID, fieldName });\r\n        }\r\n    }\r\n    // end of ourCheckSupportReferenceInTA function\r\n\r\n\r\n    async function ourCheckTNOriginalLanguageQuote(rowID, fieldName, fieldText, occurrence, rowLocation, checkingOptions) {\r\n        // Checks that the Hebrew/Greek quote can be found in the original texts\r\n\r\n        // Uses the bookID,C,V values from the main function call\r\n\r\n        // Updates the global list of notices\r\n\r\n        // console.log(`checkTN_TSVDataRow ourCheckTNOriginalLanguageQuote(${fieldName}, (${fieldText.length}) '${fieldText}', ${rowLocation}, )`);\r\n        console.assert(rowID !== undefined, \"checkTN_TSVDataRow ourCheckTNOriginalLanguageQuote: 'rowID' parameter should be defined\");\r\n        console.assert(typeof rowID === 'string', `checkTN_TSVDataRow ourCheckTNOriginalLanguageQuote: 'rowID' parameter should be a string not a '${typeof rowID}'`);\r\n        console.assert(fieldName !== undefined, \"checkTN_TSVDataRow ourCheckTNOriginalLanguageQuote: 'fieldName' parameter should be defined\");\r\n        console.assert(typeof fieldName === 'string', `checkTN_TSVDataRow ourCheckTNOriginalLanguageQuote: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);\r\n        console.assert(fieldText !== undefined, \"checkTN_TSVDataRow ourCheckTNOriginalLanguageQuote: 'fieldText' parameter should be defined\");\r\n        console.assert(typeof fieldText === 'string', `checkTN_TSVDataRow ourCheckTNOriginalLanguageQuote: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);\r\n        console.assert(occurrence !== undefined, \"checkTN_TSVDataRow ourCheckTNOriginalLanguageQuote: 'occurrence' parameter should be defined\");\r\n        console.assert(typeof occurrence === 'string', `checkTN_TSVDataRow ourCheckTNOriginalLanguageQuote: 'occurrence' parameter should be a string not a '${typeof occurrence}'`);\r\n        console.assert(rowLocation.indexOf(fieldName) < 0, `checkTN_TSVDataRow ourCheckTNOriginalLanguageQuote: 'rowLocation' parameter should be not contain fieldName=${fieldName}`);\r\n\r\n        const coqResultObject = await checkOriginalLanguageQuote(languageCode, fieldName, fieldText, occurrence, bookID, givenC, givenV, rowLocation, checkingOptions);\r\n\r\n        // Choose only ONE of the following\r\n        // This is the fast way of append the results from this field\r\n        // result.noticeList = result.noticeList.concat(coqResultObject.noticeList);\r\n        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const noticeEntry of coqResultObject.noticeList) {\r\n            // console.assert(Object.keys(noticeEntry).length === 5, `TL ourCheckTNOriginalLanguageQuote notice length=${Object.keys(noticeEntry).length}`);\r\n            addNoticePartial({ ...noticeEntry, rowID, fieldName });\r\n        }\r\n    }\r\n    // end of ourCheckTNOriginalLanguageQuote function\r\n\r\n\r\n    async function ourCheckTNLinksToOutside(rowID, fieldName, taLinkText, rowLocation, checkingOptions) {\r\n        // Checks that the TA/TW/Bible reference can be found\r\n\r\n        // Updates the global list of notices\r\n\r\n        // console.log(`checkTN_TSVDataRow ourCheckTNLinksToOutside(${rowID}, ${fieldName}, (${taLinkText.length}) '${taLinkText}', ${rowLocation}, )`);\r\n        console.assert(rowID !== undefined, \"checkTN_TSVDataRow ourCheckTNLinksToOutside: 'rowID' parameter should be defined\");\r\n        console.assert(typeof rowID === 'string', `checkTN_TSVDataRow ourCheckTNLinksToOutside: 'rowID' parameter should be a string not a '${typeof rowID}'`);\r\n        console.assert(fieldName !== undefined, \"checkTN_TSVDataRow ourCheckTNLinksToOutside: 'fieldName' parameter should be defined\");\r\n        console.assert(typeof fieldName === 'string', `checkTN_TSVDataRow ourCheckTNLinksToOutside: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);\r\n        console.assert(fieldName === 'OccurrenceNote', `checkTN_TSVDataRow ourCheckTNLinksToOutside: 'fieldName' parameter should be 'OccurrenceNote' not '${fieldName}'`);\r\n        console.assert(taLinkText !== undefined, \"checkTN_TSVDataRow ourCheckTNLinksToOutside: 'taLinkText' parameter should be defined\");\r\n        console.assert(typeof taLinkText === 'string', `checkTN_TSVDataRow ourCheckTNLinksToOutside: 'taLinkText' parameter should be a string not a '${typeof taLinkText}'`);\r\n\r\n        const coqResultObject = await checkTNLinksToOutside(bookID, givenC, givenV, fieldName, taLinkText, rowLocation, { ...checkingOptions, defaultLanguageCode: languageCode });\r\n        // console.log(\"coqResultObject\", JSON.stringify(coqResultObject));\r\n\r\n        // Choose only ONE of the following\r\n        // This is the fast way of append the results from this field\r\n        // result.noticeList = result.noticeList.concat(coqResultObject.noticeList);\r\n        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const coqNoticeEntry of coqResultObject.noticeList) {\r\n            if (coqNoticeEntry.extra) // it must be an indirect check on a TA or TW article from a TN2 check\r\n                drResult.noticeList.push(coqNoticeEntry); // Just copy the complete notice as is\r\n            else // For our direct checks, we add the repoCode as an extra value\r\n                addNoticePartial({ ...coqNoticeEntry, rowID, fieldName });\r\n        }\r\n        // The following is needed coz we might be checking the linked TA and/or TW articles\r\n        if (coqResultObject.checkedFileCount && coqResultObject.checkedFileCount > 0)\r\n            if (typeof drResult.checkedFileCount === 'number') drResult.checkedFileCount += coqResultObject.checkedFileCount;\r\n            else drResult.checkedFileCount = coqResultObject.checkedFileCount;\r\n        if (coqResultObject.checkedFilesizes && coqResultObject.checkedFilesizes > 0)\r\n            if (typeof drResult.checkedFilesizes === 'number') drResult.checkedFilesizes += coqResultObject.checkedFilesizes;\r\n            else drResult.checkedFilesizes = coqResultObject.checkedFilesizes;\r\n        if (coqResultObject.checkedRepoNames && coqResultObject.checkedRepoNames.length > 0)\r\n            for (const checkedRepoName of coqResultObject.checkedRepoNames)\r\n                try { if (drResult.checkedRepoNames.indexOf(checkedRepoName) < 0) drResult.checkedRepoNames.push(checkedRepoName); }\r\n                catch { drResult.checkedRepoNames = [checkedRepoName]; }\r\n        if (coqResultObject.checkedFilenameExtensions && coqResultObject.checkedFilenameExtensions.length > 0)\r\n            for (const checkedFilenameExtension of coqResultObject.checkedFilenameExtensions)\r\n                try { if (drResult.checkedFilenameExtensions.indexOf(checkedFilenameExtension) < 0) drResult.checkedFilenameExtensions.push(checkedFilenameExtension); }\r\n                catch { drResult.checkedFilenameExtensions = [checkedFilenameExtension]; }\r\n        // if (drResult.checkedFilenameExtensions) console.log(\"drResult\", JSON.stringify(drResult));\r\n    }\r\n    // end of ourCheckTNLinksToOutside function\r\n\r\n\r\n    // Main code for checkTN_TSVDataRow function\r\n    if (line === EXPECTED_TN_HEADING_LINE) // Assume it must be ok\r\n        return drResult; // We cant detect if its in the wrong place\r\n\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (tlcELerror) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n    // console.log(`Using supplied extractLength=${extractLength}`, `cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    // const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    // const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n    const lowercaseBookID = bookID.toLowerCase();\r\n    let numChaptersThisBook;\r\n    try {\r\n        console.assert(lowercaseBookID !== 'obs', \"Shouldnt happen in tn_table-row-check\");\r\n        numChaptersThisBook = books.chaptersInBook(lowercaseBookID).length;\r\n    } catch (tlcNCerror) {\r\n        addNoticePartial({ priority: 979, message: \"Invalid book identifier passed to checkTN_TSVDataRow\", location: ` '${bookID}' in first parameter: ${tlcNCerror}` });\r\n    }\r\n    const haveGoodBookID = numChaptersThisBook !== undefined;\r\n\r\n    let fields = line.split('\\t');\r\n    let RIDSuggestion, SRSuggestion, GLQSuggestion, OQSuggestion, OSuggestion, ONSuggestion;\r\n    if (fields.length === NUM_EXPECTED_TN_TSV_FIELDS) {\r\n        const [B, C, V, rowID, supportReference, origQuote, occurrence, GLQuote, occurrenceNote] = fields;\r\n        // let withString = ` with '${rowID}'${inString}`;\r\n        // let CV_withString = ` ${C}:${V}${withString}`;\r\n        // let atString = ` at ${B} ${C}:${V} (${rowID})${inString}`;\r\n\r\n        // Check the fields one-by-one\r\n        if (B.length) {\r\n            if (B !== bookID)\r\n                addNoticePartial({ priority: 978, message: \"Wrong book identifier\", details: `expected '${bookID}'`, fieldName: 'Book', rowID, extract: B, location: ourRowLocation });\r\n        }\r\n        else\r\n            addNoticePartial({ priority: 977, message: \"Missing book identifier\", characterIndex: 0, rowID, location: ourRowLocation });\r\n\r\n        let numVersesThisChapter, haveGoodChapterNumber;\r\n        if (C.length) {\r\n            if (C !== givenC)\r\n                addNoticePartial({ priority: 976, message: \"Wrong chapter number\", details: `expected '${givenC}'`, fieldName: 'Chapter', rowID, extract: C, location: ourRowLocation });\r\n            if (C === 'front') { }\r\n            else if (/^\\d+$/.test(C)) {\r\n                let intC = Number(C);\r\n                if (intC === 0) {\r\n                    addNoticePartial({ priority: 824, message: `Invalid zero chapter number`, extract: C, rowID, fieldName: 'Chapter', location: ourRowLocation });\r\n                    haveGoodChapterNumber = false;\r\n                }\r\n                // TODO: Does this next section need rewriting (see verse check below)???\r\n                else if (intC > numChaptersThisBook) {\r\n                    addNoticePartial({ priority: 823, message: `Invalid large chapter number`, extract: C, rowID, fieldName: 'Chapter', location: ourRowLocation });\r\n                    haveGoodChapterNumber = false;\r\n                }\r\n                try {\r\n                    numVersesThisChapter = books.versesInChapter(lowercaseBookID, intC);\r\n                    haveGoodChapterNumber = true;\r\n                } catch (tlcNVerror) {\r\n                    if (!haveGoodBookID)\r\n                        // addNoticePartial({priority:500, \"Invalid chapter number\", rowLocation);\r\n                        // else\r\n                        addNoticePartial({ priority: 822, message: \"Unable to check chapter number\", extract: C, rowID, fieldName: 'Chapter', location: ourRowLocation });\r\n                    haveGoodChapterNumber = false;\r\n                }\r\n            }\r\n            else\r\n                addNoticePartial({ priority: 821, message: \"Bad chapter number\", extract: C, rowID, fieldName: 'Chapter', location: ourRowLocation });\r\n        }\r\n        else\r\n            addNoticePartial({ priority: 820, message: \"Missing chapter number\", rowID, fieldName: 'Chapter', location: ` ?:${V}${ourRowLocation}` });\r\n\r\n        if (V.length) {\r\n            if (V !== givenV)\r\n                addNoticePartial({ priority: 975, message: \"Wrong verse number\", details: `expected '${givenV}'`, rowID, fieldName: 'Verse', extract: V, location: ourRowLocation });\r\n            if (V === 'intro') { }\r\n            else if (/^\\d+$/.test(V)) {\r\n                let intV = Number(V);\r\n                if (intV === 0)\r\n                    addNoticePartial({ priority: 814, message: \"Invalid zero verse number\", rowID, fieldName: 'Verse', extract: V, location: ourRowLocation });\r\n                else {\r\n                    if (haveGoodChapterNumber) {\r\n                        if (intV > numVersesThisChapter)\r\n                            addNoticePartial({ priority: 813, message: \"Invalid large verse number\", rowID, fieldName: 'Verse', extract: V, location: ourRowLocation });\r\n                    } else\r\n                        addNoticePartial({ priority: 812, message: \"Unable to check verse number\", rowID, fieldName: 'Verse', location: ourRowLocation });\r\n                }\r\n            }\r\n            else\r\n                addNoticePartial({ priority: 811, message: \"Bad verse number\", rowID, fieldName: 'Verse', location: ` '${V}'${ourRowLocation}` });\r\n        }\r\n        else\r\n            addNoticePartial({ priority: 810, message: \"Missing verse number\", rowID, fieldName: 'Verse', location: ` after ${C}:?${ourRowLocation}` });\r\n\r\n        if (!rowID.length)\r\n            addNoticePartial({ priority: 779, message: \"Missing row ID field\", fieldName: 'Verse', location: ourRowLocation });\r\n        else {\r\n            if (rowID.length !== 4) {\r\n                addNoticePartial({ priority: 778, message: \"Row ID should be exactly 4 characters\", details: `not ${rowID.length}`, rowID, fieldName: 'ID', extract: rowID, location: ourRowLocation });\r\n                if (rowID.length > 4) RIDSuggestion = rowID.substring(0, 5);\r\n                else { // must be < 4\r\n                    RIDSuggestion = rowID;\r\n                    while (RIDSuggestion.length < 4) RIDSuggestion += LC_ALPHABET_PLUS_DIGITS[Math.floor(Math.random() * LC_ALPHABET_PLUS_DIGITS.length)];;\r\n                }\r\n            } else if (LC_ALPHABET.indexOf(rowID[0]) < 0)\r\n                addNoticePartial({ priority: 176, message: \"Row ID should start with a lowercase letter\", characterIndex: 0, rowID, fieldName: 'ID', extract: rowID, location: ourRowLocation });\r\n            else if (LC_ALPHABET_PLUS_DIGITS.indexOf(rowID[3]) < 0)\r\n                addNoticePartial({ priority: 175, message: \"Row ID should end with a lowercase letter or digit\", characterIndeX: 3, rowID, fieldName: 'ID', extract: rowID, location: ourRowLocation });\r\n            else if (LC_ALPHABET_PLUS_DIGITS_PLUS_HYPHEN.indexOf(rowID[1]) < 0)\r\n                addNoticePartial({ priority: 174, message: \"Row ID characters should only be lowercase letters, digits, or hypen\", fieldName: 'ID', characterIndex: 1, rowID, extract: rowID, location: ourRowLocation });\r\n            else if (LC_ALPHABET_PLUS_DIGITS_PLUS_HYPHEN.indexOf(rowID[2]) < 0)\r\n                addNoticePartial({ priority: 173, message: \"Row ID characters should only be lowercase letters, digits, or hypen\", fieldName: 'ID', characterIndex: 2, rowID, extract: rowID, location: ourRowLocation });\r\n        }\r\n\r\n        if (supportReference.length) { // need to check TN2 against TA\r\n            if (isWhitespace(supportReference))\r\n                addNoticePartial({ priority: 373, message: \"Field is only whitespace\", fieldName: 'SupportReference', rowID, location: ourRowLocation });\r\n            else { // More than just whitespace\r\n                if (!supportReference.startsWith('figs-')\r\n                    && !supportReference.startsWith('grammar-')\r\n                    && !supportReference.startsWith('translate-')\r\n                    && !supportReference.startsWith('writing-')\r\n                    && supportReference !== 'guidelines-sonofgodprinciples')\r\n                    addNoticePartial({ priority: 788, message: \"Only 'Just-In-Time Training' TA articles allowed here\", fieldName: 'SupportReference', extract: supportReference, rowID, location: ourRowLocation });\r\n                SRSuggestion = ourCheckTextField(rowID, 'SupportReference', supportReference, true, ourRowLocation, checkingOptions);\r\n                if (!checkingOptions?.disableAllLinkFetchingFlag)\r\n                    await ourCheckSupportReferenceInTA(rowID, 'SupportReference', supportReference, ourRowLocation, checkingOptions);\r\n                if (occurrenceNote.indexOf(supportReference) < 0) // The full link is NOT in the note!\r\n                    addNoticePartial({ priority: 787, message: \"Link to TA should also be in OccurrenceNote\", fieldName: 'SupportReference', extract: supportReference, rowID, location: ourRowLocation });\r\n            }\r\n            if (supportReference.indexOf('\\u200B') >= 0)\r\n                addNoticePartial({ priority: 374, message: \"Field contains zero-width space(s)\", fieldName: 'SupportReference', rowID, location: ourRowLocation });\r\n        }\r\n        // // TODO: Check if this is really required????\r\n        // else if (/^\\d+$/.test(C) && /^\\d+$/.test(V)) // C:V are both digits\r\n        //     addNoticePartial({ priority: 877, message: \"Missing SupportReference field\", fieldName: 'SupportReference', rowID, location: ourRowLocation });\r\n\r\n        if (origQuote.length) { // need to check UTN against UHB and UGNT\r\n            OQSuggestion = ourCheckTextField(rowID, 'OrigQuote', origQuote, false, ourRowLocation, checkingOptions);\r\n            if (occurrence.length)\r\n                await ourCheckTNOriginalLanguageQuote(rowID, 'OrigQuote', origQuote, occurrence, ourRowLocation, checkingOptions);\r\n            else\r\n                addNoticePartial({ priority: 750, message: \"Missing occurrence field when we have an original quote\", fieldName: 'Occurrence', rowID, location: ourRowLocation });\r\n        }\r\n        else // TODO: Find more details about when these fields are really compulsory (and when they're not, e.g., for 'intro') ???\r\n            if (V !== 'intro' && occurrence !== '0')\r\n                addNoticePartial({ priority: 919, message: \"Missing OrigQuote field\", fieldName: 'OrigQuote', rowID, location: ourRowLocation });\r\n\r\n        if (occurrence.length) { // This should usually be a digit\r\n            if (occurrence === '0') { // zero means that it doesnt occur\r\n                if (origQuote.length) {\r\n                    addNoticePartial({ priority: 751, message: \"Invalid zero occurrence field when we have an original quote\", fieldName: 'Occurrence', rowID, extract: occurrence, location: ourRowLocation });\r\n                    OSuggestion = '1';\r\n                }\r\n                // if (V !== 'intro')\r\n                //     addNoticePartial({priority:500, message:\"Invalid zero occurrence field\", rowID, location:rowLocation);\r\n            }\r\n            else if (occurrence === '-1') // TODO check the special conditions when this can occur???\r\n                ;\r\n            else if ('1234567'.indexOf(occurrence) < 0) { // its not one of these integers\r\n                addNoticePartial({ priority: 792, message: `Invalid occurrence field`, fieldName: 'Occurrence', rowID, extract: occurrence, location: ourRowLocation });\r\n                OSuggestion = '1';\r\n            }\r\n        }\r\n        else if (origQuote.length) {\r\n            addNoticePartial({ priority: 791, message: `Missing occurrence field`, fieldName: 'Occurrence', rowID, location: ourRowLocation });\r\n            OSuggestion = '1';\r\n        }\r\n\r\n        if (GLQuote.length) { // TODO: need to check UTN against ULT\r\n            if (GLQuote.indexOf('\\u200B') >= 0)\r\n                addNoticePartial({ priority: 374, message: \"Field contains zero-width space(s)\", fieldName: 'GLQuote', rowID, location: ourRowLocation });\r\n            if (isWhitespace(GLQuote))\r\n                addNoticePartial({ priority: 373, message: \"Field is only whitespace\", fieldName: 'GLQuote', rowID, location: ourRowLocation });\r\n            else // More than just whitespace\r\n                if (V !== 'intro')\r\n                    GLQSuggestion = ourCheckTextField(rowID, 'GLQuote', GLQuote, false, ourRowLocation, checkingOptions);\r\n        }\r\n        // else // TODO: Find out if these fields are really compulsory (and when they're not, e.g., for 'intro') ???\r\n        //     if (V !== 'intro')\r\n        //         addNoticePartial({ priority: 275, message: \"Missing GLQuote field\", rowID, location: ourRowLocation });\r\n\r\n        if (occurrenceNote.length) {\r\n            if (occurrenceNote.indexOf('\\u200B') >= 0)\r\n                addNoticePartial({ priority: 374, message: \"Field contains zero-width space(s)\", fieldName: 'OccurrenceNote', rowID, location: ourRowLocation });\r\n            if (isWhitespace(occurrenceNote))\r\n                addNoticePartial({ priority: 373, message: \"Field is only whitespace\", fieldName: 'OccurrenceNote', rowID, location: ourRowLocation });\r\n            else { // More than just whitespace\r\n                ONSuggestion = await ourMarkdownTextChecks(rowID, 'OccurrenceNote', occurrenceNote, true, ourRowLocation, checkingOptions);\r\n                await ourCheckTNLinksToOutside(rowID, 'OccurrenceNote', occurrenceNote, ourRowLocation, linkCheckingOptions);\r\n                let regexResultArray;\r\n                // eslint-disable-next-line no-cond-assign\r\n                while (regexResultArray = TA_REGEX.exec(occurrenceNote)) {\r\n                    // console.log(\"Got TA Regex in OccurrenceNote\", JSON.stringify(regexResultArray));\r\n                    if (supportReference !== regexResultArray[1] && V !== 'intro') {\r\n                        const details = supportReference ? `(SR='${supportReference}')` : \"(empty SR field)\"\r\n                        addNoticePartial({ priority: 786, message: \"Link to TA should also be in SupportReference\", details, rowID, fieldName: 'OccurrenceNote', extract: regexResultArray[1], location: ourRowLocation });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else // TODO: Find out if these fields are really compulsory (and when they're not, e.g., for 'intro') ???\r\n            addNoticePartial({ priority: 274, message: \"Missing OccurrenceNote field\", fieldName: 'OccurrenceNote', rowID, location: ourRowLocation });\r\n\r\n        // 9 [B, C, V, rowID, supportReference, origQuote, occurrence, GLQuote, occurrenceNote]\r\n        const suggestion = `${B}\\t${C}\\t${V}\\t${RIDSuggestion === undefined ? rowID : RIDSuggestion}\\t${SRSuggestion === undefined ? supportReference : SRSuggestion}\\t${OQSuggestion === undefined ? origQuote : OQSuggestion}\\t${OSuggestion === undefined ? occurrence : OSuggestion}\\t${GLQSuggestion === undefined ? GLQuote : GLQSuggestion}\\t${ONSuggestion === undefined ? occurrenceNote : ONSuggestion}`;\r\n        if (suggestion !== line) {\r\n            // console.log(`Had TN2 ${line}`);\r\n            // console.log(`Sug TN2 ${suggestion}`);\r\n            drResult.suggestion = suggestion;\r\n        }\r\n\r\n    } else { // wrong number of fields in the row\r\n        // Have a go at getting some of the first fields out of the row\r\n        let rowID = '????';\r\n        try { rowID = fields[3]; } catch { }\r\n        addNoticePartial({ priority: 984, message: `Found wrong number of TSV fields (expected ${NUM_EXPECTED_TN_TSV_FIELDS})`, details: `Found ${fields.length} field${fields.length === 1 ? '' : 's'}`, rowID, location: ourRowLocation });\r\n    }\r\n\r\n    // console.log(`  checkTN_TSVDataRow returning with ${drResult.noticeList.length.toLocaleString()} notice(s).`);\r\n    // console.log(\"checkTN_TSVDataRow result is\", JSON.stringify(drResult));\r\n    return drResult; // object with noticeList and possibly suggestion only\r\n}\r\n// end of checkTN_TSVDataRow function\r\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 428;","import * as books from './books/books';\r\nimport { DEFAULT_EXTRACT_LENGTH } from './text-handling-functions'\r\nimport { checkAnnotationTSVDataRow } from './annotation-row-check';\r\nimport { removeDisabledNotices } from './disabled-notices';\r\n\r\n\r\nconst ANNOTATION_TABLE_VALIDATOR_VERSION_STRING = '0.3.0';\r\n\r\nconst NUM_EXPECTED_ANNOTATION_TSV_FIELDS = 7; // so expects 6 tabs per line\r\nconst EXPECTED_TN_HEADING_LINE = 'Reference\\tID\\tTags\\tSupportReference\\tQuote\\tOccurrence\\tAnnotation';\r\n\r\n\r\nexport async function checkAnnotationRows(languageCode, annotationType, bookID, filename, tableText, givenLocation, checkingOptions) {\r\n    /* This function is optimised for checking the entire file, i.e., all rows.\r\n\r\n      It also has the advantage of being able to compare one row with the previous one.\r\n\r\n     bookID is a three-character UPPERCASE USFM book identifier or 'OBS'.\r\n\r\n     Returns a result object containing a successList and a noticeList\r\n     */\r\n    // console.log(`checkAnnotationRows(${languageCode}, ${annotationType}, ${bookID}, ${tableText.length}, ${givenLocation},${JSON.stringify(checkingOptions)})`);\r\n    console.assert(languageCode !== undefined, \"checkAnnotationRows: 'languageCode' parameter should be defined\");\r\n    console.assert(typeof languageCode === 'string', `checkAnnotationRows: 'languageCode' parameter should be a string not a '${typeof languageCode}'`);\r\n    console.assert(bookID !== undefined, \"checkAnnotationRows: 'bookID' parameter should be defined\");\r\n    console.assert(typeof bookID === 'string', `checkAnnotationRows: 'bookID' parameter should be a string not a '${typeof bookID}'`);\r\n    console.assert(bookID.length === 3, `checkAnnotationRows: 'bookID' parameter should be three characters long not ${bookID.length}`);\r\n    console.assert(bookID.toUpperCase() === bookID, `checkAnnotationRows: 'bookID' parameter should be UPPERCASE not '${bookID}'`);\r\n    console.assert(bookID === 'OBS' || books.isValidBookID(bookID), `checkAnnotationRows: '${bookID}' is not a valid USFM book identifier`);\r\n    console.assert(givenLocation !== undefined, \"checkAnnotationRows: 'givenLocation' parameter should be defined\");\r\n    console.assert(typeof givenLocation === 'string', `checkAnnotationRows: 'givenLocation' parameter should be a string not a '${typeof givenLocation}'`);\r\n\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n    const carResult = { successList: [], noticeList: [] };\r\n\r\n    function addSuccessMessage(successString) {\r\n        // console.log(`checkAnnotationRows success: ${successString}`);\r\n        carResult.successList.push(successString);\r\n    }\r\n    function addNoticePartial(noticeObject) {\r\n        // console.log(`checkAnnotationRows notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : \"\"}${extract ? ` ${extract}` : \"\"}${location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"ATSV addNoticePartial: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `TSV addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"ATSV addNoticePartial: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `TSV addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(C !== undefined, \"ATSV addNoticePartial: 'C' parameter should be defined\");\r\n        if (noticeObject.C) console.assert(typeof noticeObject.C === 'string', `TSV addNoticePartial: 'C' parameter should be a string not a '${typeof noticeObject.C}': ${noticeObject.C}`);\r\n        // console.assert(V !== undefined, \"ATSV addNoticePartial: 'V' parameter should be defined\");\r\n        if (noticeObject.V) console.assert(typeof noticeObject.V === 'string', `TSV addNoticePartial: 'V' parameter should be a string not a '${typeof noticeObject.V}': ${noticeObject.V}`);\r\n        // console.assert(characterIndex !== undefined, \"ATSV addNoticePartial: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `TSV addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract !== undefined, \"ATSV addNoticePartial: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `TSV addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"ATSV addNoticePartial: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `TSV addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n\r\n        if (noticeObject.debugChain) noticeObject.debugChain = `checkAnnotationRows ${noticeObject.debugChain}`;\r\n        carResult.noticeList.push({ ...noticeObject, bookID, filename });\r\n    }\r\n\r\n\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (ttcError) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n    // console.log(`Using supplied extractLength=${extractLength}`, `cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    // const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    // const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n    let lowercaseBookID = bookID.toLowerCase();\r\n    let numChaptersThisBook = 0;\r\n    if (bookID === 'OBS')\r\n        numChaptersThisBook = 50; // There's 50 Open Bible Stories\r\n    else {\r\n        console.assert(lowercaseBookID !== 'obs', \"Shouldnt happen in annotation-table-check\");\r\n        try {\r\n            numChaptersThisBook = books.chaptersInBook(lowercaseBookID).length;\r\n        }\r\n        catch {\r\n            if (!books.isValidBookID(bookID)) // must not be in FRT, BAK, etc.\r\n                addNoticePartial({ priority: 747, message: \"Bad function call: should be given a valid book abbreviation\", extract: bookID, location: ` (not '${bookID}')${ourLocation}` });\r\n        }\r\n    }\r\n\r\n    let lines = tableText.split('\\n');\r\n    // console.log(`  '${location}' has ${lines.length.toLocaleString()} total lines (expecting ${NUM_EXPECTED_TN_FIELDS} fields in each line)`);\r\n\r\n    let lastC = '', lastV = '';\r\n    let rowIDList = [], uniqueRowList = [];\r\n    let numVersesThisChapter = 0;\r\n    for (let n = 0; n < lines.length; n++) {\r\n        // console.log(`checkAnnotationRows checking line ${n}: ${JSON.stringify(lines[n])}`);\r\n        if (n === 0) {\r\n            if (lines[0] === EXPECTED_TN_HEADING_LINE)\r\n                addSuccessMessage(`Checked TSV header ${ourLocation}`);\r\n            else\r\n                addNoticePartial({ priority: 746, message: \"Bad TSV header\", lineNumber: n + 1, location: `${ourLocation}: '${lines[0]}'` });\r\n        }\r\n        else // not the header\r\n        {\r\n            let fields = lines[n].split('\\t');\r\n            if (fields.length === NUM_EXPECTED_ANNOTATION_TSV_FIELDS) {\r\n                // eslint-disable-next-line no-unused-vars\r\n                const [reference, rowID, tags, supportReference, quote, occurrence, annotation] = fields;\r\n                const [C, V] = reference.split(':')\r\n\r\n                // Use the row check to do most basic checks\r\n                const drResultObject = await checkAnnotationTSVDataRow(languageCode, annotationType, lines[n], bookID, C, V, ourLocation, checkingOptions);\r\n                // Choose only ONE of the following\r\n                // This is the fast way of append the results from this field\r\n                // result.noticeList = result.noticeList.concat(firstResult.noticeList);\r\n                // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n                //  process results line by line\r\n                for (const drNoticeEntry of drResultObject.noticeList)\r\n                    if (drNoticeEntry.extra) // it must be an indirect check on a TA or TW article from a TN2 check\r\n                        carResult.noticeList.push(drNoticeEntry); // Just copy the complete notice as is\r\n                    else\r\n                        addNoticePartial({ ...drNoticeEntry, lineNumber: n + 1 });\r\n                // The following is needed coz we might be checking the linked TA and/or TW articles\r\n                if (drResultObject.checkedFileCount && drResultObject.checkedFileCount > 0)\r\n                    if (typeof carResult.checkedFileCount === 'number') carResult.checkedFileCount += drResultObject.checkedFileCount;\r\n                    else carResult.checkedFileCount = drResultObject.checkedFileCount;\r\n                if (drResultObject.checkedFilesizes && drResultObject.checkedFilesizes > 0)\r\n                    if (typeof carResult.checkedFilesizes === 'number') carResult.checkedFilesizes += drResultObject.checkedFilesizes;\r\n                    else carResult.checkedFilesizes = drResultObject.checkedFilesizes;\r\n                if (drResultObject.checkedRepoNames && drResultObject.checkedRepoNames.length > 0)\r\n                    for (const checkedRepoName of drResultObject.checkedRepoNames)\r\n                        try { if (carResult.checkedRepoNames.indexOf(checkedRepoName) < 0) carResult.checkedRepoNames.push(checkedRepoName); }\r\n                        catch { carResult.checkedRepoNames = [checkedRepoName]; }\r\n                if (drResultObject.checkedFilenameExtensions && drResultObject.checkedFilenameExtensions.length > 0)\r\n                    for (const checkedFilenameExtension of drResultObject.checkedFilenameExtensions)\r\n                        try { if (carResult.checkedFilenameExtensions.indexOf(checkedFilenameExtension) < 0) carResult.checkedFilenameExtensions.push(checkedFilenameExtension); }\r\n                        catch { carResult.checkedFilenameExtensions = [checkedFilenameExtension]; }\r\n                // if (ttResult.checkedFilenameExtensions) console.log(\"ttResult\", JSON.stringify(ttResult));\r\n\r\n                // So here we only have to check against the previous and next fields for out-of-order problems and duplicate problems\r\n                if (C !== lastC || V !== lastV) {\r\n                    rowIDList = []; // ID's only need to be unique within each verse\r\n                    uniqueRowList = []; // Same for these\r\n                }\r\n\r\n                // TODO: Check if we need this at all (even though tC 3.0 cant display these \"duplicate\" notes)\r\n                // Check for duplicate notes\r\n                const uniqueID = C + V + supportReference + quote + occurrence; // This combination should not be repeated\r\n                // if (uniqueRowList.includes(uniqueID))\r\n                //     addNoticePartial({ priority: 880, C, V, message: `Duplicate note`, rowID, lineNumber: n + 1, location: ourLocation });\r\n                // if (uniqueRowList.includes(uniqueID))\r\n                //     addNoticePartial({ priority: 80, C, V, message: `Note: tC 3.0 wont display duplicate note`, rowID, lineNumber: n + 1, location: ourLocation });\r\n                uniqueRowList.push(uniqueID);\r\n\r\n                if (C) {\r\n                    if (C === 'front') { }\r\n                    else if (/^\\d+$/.test(C)) {\r\n                        let intC = Number(C);\r\n                        if (C !== lastC)\r\n                            if (lowercaseBookID === 'obs')\r\n                                numVersesThisChapter = 99; // Set to maximum expected number of frames\r\n                            else\r\n                                numVersesThisChapter = books.versesInChapter(lowercaseBookID, intC);\r\n                        if (intC === 0)\r\n                            addNoticePartial({ priority: 551, C, V, message: `Invalid zero chapter number`, rowID, lineNumber: n + 1, extract: C, location: ourLocation });\r\n                        if (intC > numChaptersThisBook)\r\n                            addNoticePartial({ priority: 737, C, V, message: \"Invalid large chapter number\", rowID, lineNumber: n + 1, extract: C, location: ourLocation });\r\n                        if (/^\\d+$/.test(lastC)) {\r\n                            let lastintC = Number(lastC);\r\n                            if (intC < lastintC)\r\n                                addNoticePartial({ priority: 736, C, V, message: \"Receding chapter number\", details: `'${C}' after '${lastC}'`, rowID, lineNumber: n + 1, location: ourLocation });\r\n                            else if (intC > lastintC + 1)\r\n                                addNoticePartial({ priority: 735, C, V, message: \"Advancing chapter number\", details: `'${C}' after '${lastC}'`.rowID, lineNumber: n + 1, location: ourLocation });\r\n                        }\r\n                    }\r\n                    else\r\n                        addNoticePartial({ priority: 734, C, V, message: \"Bad chapter number\", rowID, lineNumber: n + 1, location: ourLocation });\r\n                }\r\n                else\r\n                    addNoticePartial({ priority: 739, C, V, message: \"Missing chapter number\", rowID, lineNumber: n + 1, location: ` after ${lastC}:${V}${ourLocation}` });\r\n\r\n                if (V) {\r\n                    if (V === 'intro') { }\r\n                    else if (/^\\d+$/.test(V)) {\r\n                        let intV = Number(V);\r\n                        if (intV === 0)\r\n                            addNoticePartial({ priority: 552, C, V, message: \"Invalid zero verse number\", details: `for chapter ${C}`, rowID, lineNumber: n + 1, extract: V, location: ourLocation });\r\n                        if (intV > numVersesThisChapter)\r\n                            addNoticePartial({ priority: 734, C, V, message: \"Invalid large verse number\", details: `for chapter ${C}`, rowID, lineNumber: n + 1, extract: V, location: ourLocation });\r\n                        if (/^\\d+$/.test(lastV)) {\r\n                            let lastintV = Number(lastV);\r\n                            if (C === lastC && intV < lastintV)\r\n                                addNoticePartial({ priority: 733, C, V, message: \"Receding verse number\", details: `'${V}' after '${lastV} for chapter ${C}`, rowID, lineNumber: n + 1, extract: V, location: ourLocation });\r\n                            // else if (intV > lastintV + 1)\r\n                            //   addNoticePartial({priority:556, `Skipped verses with '${V}' verse number after '${lastV}'${withString}`);\r\n                        }\r\n                    }\r\n                    else\r\n                        addNoticePartial({ priority: 738, C, V, message: \"Bad verse number\", rowID, lineNumber: n + 1, location: ourLocation });\r\n\r\n                }\r\n                else\r\n                    addNoticePartial({ priority: 790, C, V, message: \"Missing verse number\", rowID, lineNumber: n + 1, location: ` after ${C}:${lastV}${ourLocation}` });\r\n\r\n                if (rowID) {\r\n                    if (rowIDList.includes(rowID))\r\n                        addNoticePartial({ priority: 729, C, V, message: `Duplicate '${rowID}' ID`, fieldName: 'ID', rowID, lineNumber: n + 1, location: ourLocation });\r\n                } else\r\n                    addNoticePartial({ priority: 730, C, V, message: \"Missing ID\", fieldName: 'ID', lineNumber: n + 1, location: ourLocation });\r\n\r\n\r\n                lastC = C; lastV = V;\r\n\r\n            } else // wrong number of fields in the row\r\n                // if (n === lines.length - 1) // its the last line\r\n                //     console.log(`  Line ${n}: Has ${fields.length} field(s) instead of ${NUM_EXPECTED_TN_FIELDS}: ${EXPECTED_TN_HEADING_LINE.replace(/\\t/g, ', ')}`);\r\n                // else\r\n                if (n !== lines.length - 1) { // its not the last line\r\n                    // Have a go at getting some of the first fields out of the line\r\n                    let reference = '?:?', C = '?', V = '?', rowID = '????';\r\n                    try { reference = fields[0]; } catch { }\r\n                    try { rowID = fields[1]; } catch { }\r\n                    try { [C, V] = reference.split(':'); } catch { }\r\n                    addNoticePartial({ priority: 988, message: `Wrong number of tabbed fields (expected ${NUM_EXPECTED_ANNOTATION_TSV_FIELDS})`, extract: `Found ${fields.length} field${fields.length === 1 ? '' : 's'}`, C, V, rowID, lineNumber: n + 1, location: ourLocation });\r\n                }\r\n        }\r\n    }\r\n\r\n    if (!checkingOptions?.suppressNoticeDisablingFlag) {\r\n        // console.log(`checkAnnotationRows: calling removeDisabledNotices(${carResult.noticeList.length}) having ${JSON.stringify(checkingOptions)}`);\r\n        carResult.noticeList = removeDisabledNotices(carResult.noticeList);\r\n    }\r\n\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 20)\r\n        && checkingOptions?.disableAllLinkFetchingFlag)\r\n        addNoticePartial({ priority: 20, message: \"Note that 'disableAllLinkFetchingFlag' was set so link targets were not checked\", location: ourLocation });\r\n\r\n    addSuccessMessage(`Checked all ${(lines.length - 1).toLocaleString()} data line${lines.length - 1 === 1 ? '' : 's'}${ourLocation}.`);\r\n    if (carResult.noticeList)\r\n        addSuccessMessage(`checkAnnotationRows v${ANNOTATION_TABLE_VALIDATOR_VERSION_STRING} finished with ${carResult.noticeList.length ? carResult.noticeList.length.toLocaleString() : \"zero\"} notice${carResult.noticeList.length === 1 ? '' : 's'}`);\r\n    else\r\n        addSuccessMessage(`No errors or warnings found by checkAnnotationRows v${ANNOTATION_TABLE_VALIDATOR_VERSION_STRING}`)\r\n    // console.log(`  checkAnnotationRows returning with ${result.successList.length.toLocaleString()} success(es), ${result.noticeList.length.toLocaleString()} notice(s).`);\r\n    // console.log(\"checkAnnotationRows result is\", JSON.stringify(carResult));\r\n    return carResult;\r\n}\r\n// end of checkAnnotationRows function\r\n","import { DEFAULT_EXTRACT_LENGTH } from './text-handling-functions'\r\nimport { checkMarkdownText } from './markdown-text-check';\r\nimport { checkTextfileContents } from './file-text-check';\r\n\r\n\r\nconst MARKDOWN_FILE_VALIDATOR_VERSION_STRING = '0.4.0';\r\n\r\n\r\n/**\r\n *\r\n * @param {string} languageCode\r\n * @param {string} markdownFilename -- used for identification\r\n * @param {string} markdownText -- the actual text to be checked\r\n * @param {string} givenLocation\r\n * @param {Object} checkingOptions\r\n */\r\nexport function checkMarkdownFileContents(languageCode, markdownFilename, markdownText, givenLocation, checkingOptions) {\r\n  /* This function is optimised for checking the entire markdown file, i.e., all lines.\r\n\r\n  Note: This function does not check that any link targets in the markdown are valid links.\r\n\r\n   Returns a result object containing a successList and a noticeList\r\n   */\r\n  // console.log(`checkMarkdownFileContents(${languageCode}, ${markdownFilename}, ${markdownText.length}, ${givenLocation})`);\r\n  console.assert(languageCode !== undefined, \"checkMarkdownFileContents: 'languageCode' parameter should be defined\");\r\n  console.assert(typeof languageCode === 'string', `checkMarkdownFileContents: 'languageCode' parameter should be a string not a '${typeof languageCode}': ${languageCode}`);\r\n  console.assert(markdownFilename !== undefined, \"checkMarkdownFileContents: 'markdownFilename' parameter should be defined\");\r\n  console.assert(typeof markdownFilename === 'string', `checkMarkdownFileContents: 'markdownFilename' parameter should be a string not a '${typeof markdownFilename}': ${markdownFilename}`);\r\n  console.assert(markdownText !== undefined, \"checkMarkdownFileContents: 'markdownText' parameter should be defined\");\r\n  console.assert(typeof markdownText === 'string', `checkMarkdownFileContents: 'markdownText' parameter should be a string not a '${typeof markdownText}': ${markdownText}`);\r\n  console.assert(givenLocation !== undefined, \"checkMarkdownFileContents: 'givenLocation' parameter should be defined\");\r\n  console.assert(typeof givenLocation === 'string', `checkMarkdownFileContents: 'givenLocation' parameter should be a string not a '${typeof givenLocation}': ${givenLocation}`);\r\n  console.assert(givenLocation.indexOf('true') === -1, `checkMarkdownFileContents: 'givenLocation' parameter should not be '${givenLocation}'`);\r\n  if (checkingOptions !== undefined)\r\n    console.assert(typeof checkingOptions === 'object', `checkMarkdownFileContents: 'checkingOptions' parameter should be an object not a '${typeof checkingOptions}': ${JSON.stringify(checkingOptions)}`);\r\n\r\n  let ourLocation = givenLocation;\r\n  if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n  let extractLength;\r\n  try {\r\n    extractLength = checkingOptions?.extractLength;\r\n  } catch (mdtcError) { }\r\n  if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n    extractLength = DEFAULT_EXTRACT_LENGTH;\r\n    // console.log(\"Using default extractLength=\" + extractLength);\r\n  }\r\n  // else\r\n  // console.log(\"Using supplied extractLength=\" + extractLength, `cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n  // const halfLength = Math.floor(extractLength / 2); // rounded down\r\n  // const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n  // console.log(\"Using halfLength=\" + halfLength, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n  const result = { successList: [], noticeList: [] };\r\n\r\n  function addSuccessMessage(successString) {\r\n    // console.log(\"checkMarkdownFileContents success: \" + successString);\r\n    result.successList.push(successString);\r\n  }\r\n  function addNoticePartial(noticeObject) {\r\n    // console.log(`checkMarkdownFileContents addNoticePartial: (priority=${noticeObject.priority}) ${noticeObject.message}${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : \"\"}${noticeObject.extract ? \" \" + extract : \"\"}${noticeObject.location}`);\r\n    console.assert(noticeObject.priority !== undefined, \"cMdT addNoticePartial: 'priority' parameter should be defined\");\r\n    console.assert(typeof noticeObject.priority === 'number', `cMdT addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n    console.assert(noticeObject.message !== undefined, \"cMdT addNoticePartial: 'message' parameter should be defined\");\r\n    console.assert(typeof noticeObject.message === 'string', `cMdT addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n    // console.assert(characterIndex !== undefined, \"cMdT addNoticePartial: 'characterIndex' parameter should be defined\");\r\n    if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cMdT addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n    // console.assert(extract !== undefined, \"cMdT addNoticePartial: 'extract' parameter should be defined\");\r\n    if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cMdT addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n    console.assert(noticeObject.location !== undefined, \"cMdT addNoticePartial: 'location' parameter should be defined\");\r\n    console.assert(typeof noticeObject.location === 'string', `cMdT addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n\r\n    if (noticeObject.debugChain) noticeObject.debugChain = `checkMarkdownFileContents ${noticeObject.debugChain}`;\r\n    result.noticeList.push({ ...noticeObject, filename: markdownFilename });\r\n  }\r\n  // end of addNoticePartial function\r\n\r\n  /**\r\n  * @description - checks the given text field and processes the returned results\r\n  * @param {String} markdownText - the actual text of the file being checked\r\n  * @param {boolean} allowedLinks - true if links are allowed in the field, otherwise false\r\n  * @param {String} optionalFieldLocation - description of where the field is located\r\n  * @param {Object} checkingOptions - parameters that might affect the check\r\n  */\r\n  async function ourCheckMarkdownText(markdownText, optionalFieldLocation, checkingOptions) {\r\n    // Does basic checks for small errors like leading/trailing spaces, etc.\r\n\r\n    // We assume that checking for compulsory fields is done elsewhere\r\n\r\n    // Updates the global list of notices\r\n    // console.log(`cMdT ourCheckMarkdownText(${fieldName}, (${fieldText.length}), ${allowedLinks}, ${optionalFieldLocation}, )`);\r\n    console.assert(markdownText !== undefined, \"cMdFC ourCheckMarkdownText: 'markdownText' parameter should be defined\");\r\n    console.assert(typeof markdownText === 'string', `cMdFC ourCheckMarkdownText: 'markdownText' parameter should be a string not a '${typeof markdownText}'`);\r\n    console.assert(optionalFieldLocation !== undefined, \"cMdFC ourCheckMarkdownText: 'optionalFieldLocation' parameter should be defined\");\r\n    console.assert(typeof optionalFieldLocation === 'string', `cMdFC ourCheckMarkdownText: 'optionalFieldLocation' parameter should be a string not a '${typeof optionalFieldLocation}'`);\r\n\r\n    const dbtcResultObject = await checkMarkdownText(languageCode, markdownFilename, markdownText, optionalFieldLocation, checkingOptions);\r\n\r\n    // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n    //  process results line by line\r\n    for (const noticeEntry of dbtcResultObject.noticeList)\r\n      addNoticePartial(noticeEntry);\r\n  }\r\n  // end of ourCheckMarkdownText function\r\n\r\n\r\n  /**\r\n  * @description - checks the given text field and processes the returned results\r\n  * @param {String} markdownText - the actual text of the file being checked\r\n  * @param {String} optionalFieldLocation - description of where the field is located\r\n  * @param {Object} checkingOptions - parameters that might affect the check\r\n  */\r\n  function ourFileTextCheck(markdownText, optionalFieldLocation, checkingOptions) {\r\n    // Does basic checks for small errors like leading/trailing spaces, etc.\r\n\r\n    // We assume that checking for compulsory fields is done elsewhere\r\n\r\n    // Updates the global list of notices\r\n    // console.log(`cMdT ourFileTextCheck(${fieldName}, (${fieldText.length}), ${allowedLinks}, ${optionalFieldLocation}, )`);\r\n    console.assert(markdownText !== undefined, \"cMdFC ourFileTextCheck: 'markdownText' parameter should be defined\");\r\n    console.assert(typeof markdownText === 'string', `cMdFC ourFileTextCheck: 'markdownText' parameter should be a string not a '${typeof markdownText}'`);\r\n    console.assert(checkingOptions !== undefined, \"cMdFC ourFileTextCheck: 'checkingOptions' parameter should be defined\");\r\n\r\n    const dbtcResultObject = checkTextfileContents(languageCode, 'markdown', markdownFilename, markdownText, optionalFieldLocation, checkingOptions);\r\n\r\n    // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n    //  process results line by line\r\n    for (const noticeEntry of dbtcResultObject.noticeList)\r\n      addNoticePartial(noticeEntry);\r\n  }\r\n  // end of ourFileTextCheck function\r\n\r\n\r\n  // Main code for checkMarkdownFileContents function\r\n  ourCheckMarkdownText(markdownText, givenLocation, checkingOptions);\r\n  ourFileTextCheck(markdownText, givenLocation, checkingOptions);\r\n\r\n  addSuccessMessage(`Checked markdown file: ${markdownFilename}`);\r\n  if (result.noticeList)\r\n    addSuccessMessage(`checkMarkdownFileContents v${MARKDOWN_FILE_VALIDATOR_VERSION_STRING} finished with ${result.noticeList.length ? result.noticeList.length.toLocaleString() : \"zero\"} notice${result.noticeList.length === 1 ? '' : 's'}`);\r\n  else\r\n    addSuccessMessage(`No errors or warnings found by checkMarkdownFileContents v${MARKDOWN_FILE_VALIDATOR_VERSION_STRING}`)\r\n  // console.log(`  checkMarkdownFileContents returning with ${result.successList.length.toLocaleString()} success(es), ${result.noticeList.length.toLocaleString()} notice(s).`);\r\n  if (markdownFilename.endsWith('walk.md'))\r\n    console.log(\"checkMarkdownFileContents result is\", JSON.stringify(result));\r\n  return result;\r\n}\r\n// end of checkMarkdownFileContents function\r\n","import { DEFAULT_EXTRACT_LENGTH } from './text-handling-functions'\r\nimport { checkYAMLText } from './yaml-text-check';\r\nimport { cachedGetFile } from './getApi';\r\nimport { BibleBookData } from './books/books'\r\nimport Ajv from 'ajv';\r\nimport { removeDisabledNotices } from './disabled-notices';\r\n\r\n\r\nconst MANIFEST_VALIDATOR_VERSION_STRING = '0.3.7';\r\n\r\n// Pasted in 2020-10-02 from https://raw.githubusercontent.com/unfoldingWord/dcs/master/options/schema/rc.schema.json\r\nconst MANIFEST_SCHEMA = {\r\n    \"$schema\": \"http://json-schema.org/draft-07/schema\",\r\n    \"$id\": \"https://resource-container.readthedocs.io/schema/rc.schema.json\",\r\n    \"$$target\": [\r\n        \"rc.schema.json#/definitions/languageTag\",\r\n        \"rc.schema.json#/definitions/localizedText\"\r\n    ],\r\n    \"title\": \"Root\",\r\n    \"type\": \"object\",\r\n    \"required\": [\r\n        \"dublin_core\",\r\n        \"checking\",\r\n        \"projects\"\r\n    ],\r\n    \"properties\": {\r\n        \"dublin_core\": {\r\n            \"$id\": \"#root/dublin_core\",\r\n            \"title\": \"Dublin_core\",\r\n            \"type\": \"object\",\r\n            \"required\": [\r\n                \"conformsto\",\r\n                \"contributor\",\r\n                \"creator\",\r\n                \"description\",\r\n                \"format\",\r\n                \"identifier\",\r\n                \"issued\",\r\n                \"language\",\r\n                \"modified\",\r\n                \"publisher\",\r\n                \"relation\",\r\n                \"rights\",\r\n                \"source\",\r\n                \"subject\",\r\n                \"title\",\r\n                \"type\",\r\n                \"version\"\r\n            ],\r\n            \"properties\": {\r\n                \"conformsto\": {\r\n                    \"$id\": \"#root/dublin_core/conformsto\",\r\n                    \"title\": \"Conformsto\",\r\n                    \"type\": \"string\",\r\n                    \"default\": \"rc0.2\",\r\n                    \"enum\": [\r\n                        \"rc0.2\"\r\n                    ]\r\n                },\r\n                \"contributor\": {\r\n                    \"$id\": \"#root/dublin_core/contributor\",\r\n                    \"title\": \"Contributor\",\r\n                    \"type\": \"array\",\r\n                    \"default\": [],\r\n                    \"items\": {\r\n                        \"$id\": \"#root/dublin_core/contributor/items\",\r\n                        \"title\": \"Items\",\r\n                        \"type\": \"string\",\r\n                        \"default\": \"\",\r\n                        \"examples\": [\r\n                            \"Alrick G. Headley, M.Div., Th.M.\"\r\n                        ]\r\n                    }\r\n                },\r\n                \"creator\": {\r\n                    \"$id\": \"#root/dublin_core/creator\",\r\n                    \"title\": \"Creator\",\r\n                    \"type\": \"string\",\r\n                    \"default\": \"\",\r\n                    \"examples\": [\r\n                        \"unfoldingWord\"\r\n                    ]\r\n                },\r\n                \"description\": {\r\n                    \"$id\": \"#root/dublin_core/description\",\r\n                    \"title\": \"Description\",\r\n                    \"type\": \"string\",\r\n                    \"default\": \"\",\r\n                    \"examples\": [\r\n                        \"An open-licensed update of the ASV, intended to provide a 'form-centric' understanding of the Bible. It increases the translator's understanding of the lexical and grammatical composition of the underlying text by adhering closely to the word order and structure of the originals.\"\r\n                    ]\r\n                },\r\n                \"format\": {\r\n                    \"$id\": \"#root/dublin_core/format\",\r\n                    \"$ref\": \"#/definitions/mimeType\",\r\n                    \"title\": \"Format\",\r\n                    \"default\": \"\"\r\n                },\r\n                \"identifier\": {\r\n                    \"$id\": \"#root/dublin_core/identifier\",\r\n                    \"title\": \"Identifier\",\r\n                    \"type\": \"string\",\r\n                    \"default\": \"\",\r\n                    \"examples\": [\r\n                        \"ult\"\r\n                    ],\r\n                    \"pattern\": \"^[a-z][a-z0-9-]\"\r\n                },\r\n                \"issued\": {\r\n                    \"$id\": \"#root/dublin_core/issued\",\r\n                    \"$ref\": \"#/definitions/timestamp\",\r\n                    \"title\": \"Issued\",\r\n                    \"type\": \"string\",\r\n                    \"default\": \"\",\r\n                    \"examples\": [\r\n                        \"2020-03-25\"\r\n                    ]\r\n                },\r\n                \"modified\": {\r\n                    \"$id\": \"#root/dublin_core/modified\",\r\n                    \"$ref\": \"#/definitions/timestamp\",\r\n                    \"title\": \"Modified\",\r\n                    \"type\": \"string\",\r\n                    \"default\": \"\",\r\n                    \"examples\": [\r\n                        \"2020-03-25\"\r\n                    ]\r\n                },\r\n                \"publisher\": {\r\n                    \"$id\": \"#root/dublin_core/publisher\",\r\n                    \"title\": \"Publisher\",\r\n                    \"type\": \"string\",\r\n                    \"default\": \"\",\r\n                    \"examples\": [\r\n                        \"unfoldingWord\"\r\n                    ]\r\n                },\r\n                \"language\": {\r\n                    \"$id\": \"#root/dublin_core/language\",\r\n                    \"title\": \"Language\",\r\n                    \"type\": \"object\",\r\n                    \"required\": [\r\n                        \"direction\",\r\n                        \"identifier\",\r\n                        \"title\"\r\n                    ],\r\n                    \"properties\": {\r\n                        \"identifier\": {\r\n                            \"$id\": \"#root/dublin_core/language/identifier\",\r\n                            \"$ref\": \"#/definitions/languageTag\",\r\n                            \"title\": \"Identifier\",\r\n                            \"examples\": [\"en\", \"hi\", \"es-419\"]\r\n                        },\r\n                        \"title\": {\r\n                            \"$id\": \"#root/dublin_core/language/title\",\r\n                            \"title\": \"Title\",\r\n                            \"type\": \"string\",\r\n                            \"default\": \"\"\r\n                        },\r\n                        \"direction\": {\r\n                            \"$id\": \"#root/dublin_core/language/direction\",\r\n                            \"title\": \"Direction\",\r\n                            \"type\": \"string\",\r\n                            \"default\": \"ltr\",\r\n                            \"enum\": [\"ltr\", \"rtl\"]\r\n                        }\r\n                    }\r\n                },\r\n                \"relation\": {\r\n                    \"$id\": \"#root/dublin_core/relation\",\r\n                    \"title\": \"Relation\",\r\n                    \"type\": \"array\",\r\n                    \"default\": [],\r\n                    \"items\": {\r\n                        \"$id\": \"#root/dublin_core/relation/items\",\r\n                        \"$ref\": \"#/definitions/relationItem\",\r\n                        \"title\": \"Items\",\r\n                        \"default\": \"\",\r\n                        \"examples\": [\r\n                            \"en/tw\"\r\n                        ]\r\n                    }\r\n                },\r\n                \"rights\": {\r\n                    \"$id\": \"#root/dublin_core/rights\",\r\n                    \"title\": \"Rights\",\r\n                    \"type\": \"string\",\r\n                    \"default\": \"CC BY-SA 4.0\",\r\n                    \"enum\": [\r\n                        \"CC BY 3.0\",\r\n                        \"CC BY-SA 3.0\",\r\n                        \"CC BY-SA 4.0\",\r\n                        \"Free Translate 2.0 International Public License\",\r\n                        \"Public Domain\"\r\n                    ]\r\n                },\r\n                \"source\": {\r\n                    \"$id\": \"#root/dublin_core/source\",\r\n                    \"title\": \"Source\",\r\n                    \"type\": \"array\",\r\n                    \"default\": [],\r\n                    \"items\": {\r\n                        \"$id\": \"#root/dublin_core/source/items\",\r\n                        \"title\": \"Items\",\r\n                        \"type\": \"object\",\r\n                        \"required\": [\r\n                            \"identifier\",\r\n                            \"language\",\r\n                            \"version\"\r\n                        ],\r\n                        \"properties\": {\r\n                            \"identifier\": {\r\n                                \"$id\": \"#root/dublin_core/source/items/identifier\",\r\n                                \"title\": \"Identifier\",\r\n                                \"type\": \"string\",\r\n                                \"default\": \"\",\r\n                                \"examples\": [\r\n                                    \"asv\"\r\n                                ],\r\n                                \"pattern\": \"^[a-z][a-z0-9-]\"\r\n                            },\r\n                            \"language\": {\r\n                                \"$id\": \"#root/dublin_core/source/items/language\",\r\n                                \"$ref\": \"#/definitions/languageTag\",\r\n                                \"title\": \"Language\",\r\n                                \"default\": \"\",\r\n                                \"examples\": [\r\n                                    \"en\"\r\n                                ]\r\n                            },\r\n                            \"version\": {\r\n                                \"$id\": \"#root/dublin_core/source/items/version\",\r\n                                \"title\": \"Version\",\r\n                                \"type\": \"string\",\r\n                                \"default\": \"\",\r\n                                \"examples\": [\r\n                                    \"1901\"\r\n                                ]\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                },\r\n                \"subject\": {\r\n                    \"$id\": \"#root/dublin_core/subject\",\r\n                    \"title\": \"Subject\",\r\n                    \"type\": \"string\",\r\n                    \"enum\": [\r\n                        \"Aligned Bible\",\r\n                        \"Bible\",\r\n                        \"Bible stories\",\r\n                        \"Greek New Testament\",\r\n                        \"Hebrew Old Testament\",\r\n                        \"OBS Study Notes\",\r\n                        \"OBS Study Questions\",\r\n                        \"OBS Translation Notes\",\r\n                        \"OBS Translation Questions\",\r\n                        \"Open Bible Stories\",\r\n                        \"Translation Academy\",\r\n                        \"Translation Notes\",\r\n                        \"Translation Questions\",\r\n                        \"Translation Words\",\r\n                        \"TSV Translation Notes\"\r\n                    ]\r\n                },\r\n                \"title\": {\r\n                    \"$id\": \"#root/dublin_core/title\",\r\n                    \"title\": \"Title\",\r\n                    \"type\": \"string\",\r\n                    \"default\": \"\",\r\n                    \"examples\": [\r\n                        \"unfoldingWord Literal Text\"\r\n                    ]\r\n                },\r\n                \"type\": {\r\n                    \"$id\": \"#root/dublin_core/type\",\r\n                    \"title\": \"Type\",\r\n                    \"type\": \"string\",\r\n                    \"default\": \"\",\r\n                    \"examples\": [\r\n                        \"bundle\"\r\n                    ],\r\n                    \"enum\": [\"book\", \"bundle\", \"dict\", \"help\", \"man\"]\r\n                },\r\n                \"version\": {\r\n                    \"$id\": \"#root/dublin_core/version\",\r\n                    \"title\": \"Version\",\r\n                    \"type\": \"string\",\r\n                    \"default\": \"\",\r\n                    \"examples\": [\r\n                        \"10\"\r\n                    ]\r\n                }\r\n            }\r\n        },\r\n        \"checking\": {\r\n            \"$id\": \"#root/checking\",\r\n            \"title\": \"Checking\",\r\n            \"type\": \"object\",\r\n            \"required\": [\r\n                \"checking_entity\",\r\n                \"checking_level\"\r\n            ],\r\n            \"properties\": {\r\n                \"checking_entity\": {\r\n                    \"$id\": \"#root/checking/checking_entity\",\r\n                    \"title\": \"Checking_entity\",\r\n                    \"type\": \"array\",\r\n                    \"default\": [],\r\n                    \"items\": {\r\n                        \"$id\": \"#root/checking/checking_entity/items\",\r\n                        \"title\": \"Items\",\r\n                        \"type\": \"string\",\r\n                        \"default\": \"\",\r\n                        \"examples\": [\r\n                            \"unfoldingWord\"\r\n                        ]\r\n                    }\r\n                },\r\n                \"checking_level\": {\r\n                    \"$id\": \"#root/checking/checking_level\",\r\n                    \"title\": \"Checking_level\",\r\n                    \"type\": [\"integer\", \"string\"],\r\n                    \"default\": \"1\",\r\n                    \"enum\": [\r\n                        \"1\",\r\n                        \"2\",\r\n                        \"3\"\r\n                    ]\r\n                }\r\n            }\r\n        },\r\n        \"projects\": {\r\n            \"$id\": \"#root/projects\",\r\n            \"title\": \"Projects\",\r\n            \"type\": \"array\",\r\n            \"default\": [],\r\n            \"items\": {\r\n                \"$id\": \"#root/projects/items\",\r\n                \"title\": \"Items\",\r\n                \"type\": \"object\",\r\n                \"required\": [\r\n                    \"title\",\r\n                    \"identifier\",\r\n                    \"path\"\r\n                ],\r\n                \"properties\": {\r\n                    \"title\": {\r\n                        \"$id\": \"#root/projects/items/title\",\r\n                        \"title\": \"Title\",\r\n                        \"type\": \"string\",\r\n                        \"default\": \"\",\r\n                        \"examples\": [\r\n                            \"Genesis\"\r\n                        ]\r\n                    },\r\n                    \"versification\": {\r\n                        \"$id\": \"#root/projects/items/versification\",\r\n                        \"title\": \"Versification\",\r\n                        \"type\": [\"string\", \"null\"],\r\n                        \"default\": null,\r\n                        \"examples\": [\r\n                            \"ufw\"\r\n                        ],\r\n                        \"enum\": [\"avd\", \"odx\", \"odx-hr\", \"other\", \"rsc\", \"ufw\", \"ufw-bn\", \"ufw-ml\", \"ufw-odx\", \"ufw-rev\", \"obs\", \"\", null]\r\n                    },\r\n                    \"identifier\": {\r\n                        \"$id\": \"#root/projects/items/identifier\",\r\n                        \"$ref\": \"#/definitions/projectIdentifier\",\r\n                        \"title\": \"Identifier\",\r\n                        \"default\": \"\"\r\n                    },\r\n                    \"sort\": {\r\n                        \"$id\": \"#root/projects/items/sort\",\r\n                        \"title\": \"Sort\",\r\n                        \"type\": \"integer\",\r\n                        \"default\": 0\r\n                    },\r\n                    \"path\": {\r\n                        \"$id\": \"#root/projects/items/path\",\r\n                        \"$ref\": \"#/definitions/path\",\r\n                        \"title\": \"Path\",\r\n                        \"examples\": [\r\n                            \"./01-GEN.usfm\"\r\n                        ]\r\n                    },\r\n                    \"categories\": {\r\n                        \"$id\": \"#root/projects/items/categories\",\r\n                        \"title\": \"Categories\",\r\n                        \"type\": [\"array\", \"null\"],\r\n                        \"default\": [],\r\n                        \"items\": {\r\n                            \"$id\": \"#root/projects/items/categories/items\",\r\n                            \"title\": \"Items\",\r\n                            \"type\": \"string\",\r\n                            \"enum\": [\r\n                                \"bible-ot\",\r\n                                \"bible-nt\",\r\n                                \"ta\"\r\n                            ]\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n    \"definitions\": {\r\n        \"languageTag\": {\r\n            \"type\": \"string\",\r\n            \"pattern\": \"^(((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((([A-Za-z]{2,3}(-([A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-([A-Za-z]{4}))?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-([0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(x(-[A-Za-z0-9]{1,8})+))?)|(x(-[A-Za-z0-9]{1,8})+))$\",\r\n            \"minLength\": 2,\r\n            \"description\": \"A valid IETF language tag as specified by BCP 47.\"\r\n        },\r\n        \"localizedText\": {\r\n            \"type\": \"object\",\r\n            \"additionalProperties\": {\r\n                \"$ref\": \"#/definitions/trimmedText\"\r\n            },\r\n            \"propertyNames\": {\r\n                \"$ref\": \"#/definitions/languageTag\"\r\n            },\r\n            \"minProperties\": 1,\r\n            \"description\": \"A textual string specified in one or multiple languages, indexed by IETF language tag.\"\r\n        },\r\n        \"mimeType\": {\r\n            \"type\": \"string\",\r\n            \"pattern\": \"^[\\\\-a-z0-9]+/[\\\\-a-z0-9+]+$\",\r\n            \"description\": \"An IANA media type (also known as MIME type)\"\r\n        },\r\n        \"path\": {\r\n            \"type\": \"string\",\r\n            \"pattern\": \"^[^\\\\/:?*\\\"><|]+(/[^\\\\/:?*\\\"><|]+)*$\",\r\n            \"description\": \"A file path, delimited by forward slashes.\"\r\n        },\r\n        \"projectIdentifier\": {\r\n            \"type\": \"string\",\r\n            \"enum\": [\r\n                \"gen\",\r\n                \"exo\",\r\n                \"lev\",\r\n                \"num\",\r\n                \"deu\",\r\n                \"jos\",\r\n                \"jdg\",\r\n                \"rut\",\r\n                \"1sa\",\r\n                \"2sa\",\r\n                \"1ki\",\r\n                \"2ki\",\r\n                \"1ch\",\r\n                \"2ch\",\r\n                \"ezr\",\r\n                \"neh\",\r\n                \"est\",\r\n                \"job\",\r\n                \"psa\",\r\n                \"pro\",\r\n                \"ecc\",\r\n                \"sng\",\r\n                \"isa\",\r\n                \"jer\",\r\n                \"lam\",\r\n                \"ezk\",\r\n                \"dan\",\r\n                \"hos\",\r\n                \"jol\",\r\n                \"amo\",\r\n                \"oba\",\r\n                \"jon\",\r\n                \"mic\",\r\n                \"nam\",\r\n                \"hab\",\r\n                \"zep\",\r\n                \"hag\",\r\n                \"zec\",\r\n                \"mal\",\r\n                \"mat\",\r\n                \"mrk\",\r\n                \"luk\",\r\n                \"jhn\",\r\n                \"act\",\r\n                \"rom\",\r\n                \"1co\",\r\n                \"2co\",\r\n                \"gal\",\r\n                \"eph\",\r\n                \"php\",\r\n                \"col\",\r\n                \"1th\",\r\n                \"2th\",\r\n                \"1ti\",\r\n                \"2ti\",\r\n                \"tit\",\r\n                \"phm\",\r\n                \"heb\",\r\n                \"jas\",\r\n                \"1pe\",\r\n                \"2pe\",\r\n                \"1jn\",\r\n                \"2jn\",\r\n                \"3jn\",\r\n                \"jud\",\r\n                \"rev\",\r\n                \"obs\",\r\n                \"intro\",\r\n                \"process\",\r\n                \"translate\",\r\n                \"checking\",\r\n                \"bible\"\r\n            ]\r\n        },\r\n        \"relationItem\": {\r\n            \"type\": \"string\",\r\n            \"pattern\": \"^(((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((([A-Za-z]{2,3}(-([A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-([A-Za-z]{4}))?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-([0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(x(-[A-Za-z0-9]{1,8})+))?)|(x(-[A-Za-z0-9]{1,8})+))/[a-z][a-z0-9-]*(\\\\?v=[0-9][a-z0-9\\\\._-]*)*$\",\r\n            \"minLength\": 4,\r\n            \"description\": \"A relation has valid IETF language tag as specified by BCP 47 and a valid resource, separated with a slash.\"\r\n        },\r\n        \"timestamp\": {\r\n            \"type\": \"string\",\r\n            \"pattern\": \"^[12][0-9]{3}(-[01][0-9](-[0123][0-9])?)?$\"\r\n        },\r\n        \"trimmedText\": {\r\n            \"type\": \"string\",\r\n            \"pattern\": \"^\\\\S(.*\\\\S)?$\",\r\n            \"description\": \"A string without surrounding whitespace characters.\"\r\n        },\r\n        \"url\": {\r\n            \"type\": \"string\",\r\n            \"pattern\": \"^((http(s)?|ftp)://)[^\\\\s$]+$\",\r\n            \"minLength\": 1,\r\n            \"description\": \"A valid **Uniform Resource Locator**.\",\r\n            \"examples\": [\"https://example.com\"]\r\n        }\r\n    }\r\n};\r\n\r\n\r\nconst ajv = new Ajv();\r\nconst validate = ajv.compile(MANIFEST_SCHEMA);\r\n\r\n\r\nexport async function checkManifestText(username, repoName, repoBranch, manifestText, givenLocation, checkingOptions) {\r\n    /* This function is optimised for checking the entire file, i.e., all lines.\r\n\r\n    See the specification at https://resource-container.readthedocs.io/en/latest/manifest.html.\r\n\r\n    Returns a result object containing a successList and a noticeList\r\n    */\r\n    // console.log(`checkManifestText(${username}, ${repoName}, ${repoBranch}, ${manifestText.length} chars, ${givenLocation}, ${JSON.stringify(checkingOptions)})`);\r\n    console.assert(username !== undefined, \"checkManifestText: 'username' parameter should be defined\");\r\n    console.assert(typeof username === 'string', `checkManifestText: 'username' parameter should be a string not a '${typeof username}': ${username}`);\r\n    console.assert(repoName !== undefined, \"checkManifestText: 'repoName' parameter should be defined\");\r\n    console.assert(typeof repoName === 'string', `checkManifestText: 'repoName' parameter should be a string not a '${typeof repoName}': ${repoName}`);\r\n    console.assert(repoBranch !== undefined, \"checkManifestText: 'repoBranch' parameter should be defined\");\r\n    console.assert(typeof repoBranch === 'string', `checkManifestText: 'repoBranch' parameter should be a string not a '${typeof repoBranch}': ${repoBranch}`);\r\n    console.assert(manifestText !== undefined, \"checkManifestText: 'manifestText' parameter should be defined\");\r\n    console.assert(typeof manifestText === 'string', `checkManifestText: 'manifestText' parameter should be a string not a '${typeof manifestText}': ${manifestText}`);\r\n    console.assert(givenLocation !== undefined, \"checkManifestText: 'optionalFieldLocation' parameter should be defined\");\r\n    console.assert(typeof givenLocation === 'string', `checkManifestText: 'optionalFieldLocation' parameter should be a string not a '${typeof givenLocation}': ${givenLocation}`);\r\n    console.assert(givenLocation.indexOf('true') === -1, `checkManifestText: 'optionalFieldLocation' parameter should not be '${givenLocation}'`);\r\n    console.assert(checkingOptions !== undefined, \"checkManifestText: 'checkingOptions' parameter should be defined\");\r\n    if (checkingOptions !== undefined)\r\n        console.assert(typeof checkingOptions === 'object', `checkManifestText: 'checkingOptions' parameter should be an object not a '${typeof checkingOptions}': ${JSON.stringify(checkingOptions)}`);\r\n\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (mfcError) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n    // console.log(`Using supplied extractLength=${extractLength}`, `cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    // const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    // const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n    const cmtResult = { successList: [], noticeList: [] };\r\n\r\n    function addSuccessMessage(successString) {\r\n        // console.log(`checkManifestText success: ${successString}`);\r\n        cmtResult.successList.push(successString);\r\n    }\r\n    function addNotice(noticeObject) {\r\n        // console.log(`checkManifestText Notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : \"\"}${extract ? ` ${extract}` : \"\"}${location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"cManT addNotice: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `cManT addNotice: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"cManT addNotice: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `cManT addNotice: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(characterIndex !== undefined, \"cManT addNotice: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cManT addNotice: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract !== undefined, \"cManT addNotice: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cManT addNotice: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"cManT addNotice: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `cManT addNotice: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n\r\n        if (repoName) noticeObject.repoName = repoName;\r\n        if (noticeObject.debugChain) noticeObject.debugChain = `checkManifestText ${noticeObject.debugChain}`;\r\n        cmtResult.noticeList.push(noticeObject);\r\n    }\r\n\r\n\r\n    function ourYAMLTextChecks(textName, manifestText, givenLocation, checkingOptions) {\r\n        // Does basic checks for small errors like leading/trailing spaces, etc.\r\n\r\n        // We assume that checking for compulsory fields is done elsewhere\r\n\r\n        // Updates the global list of notices\r\n        // console.log(`cManT ourYAMLTextChecks(${textName}, (${fieldText.length}), ${allowedLinks}, ${fieldLocation}, )`);\r\n        console.assert(textName !== undefined, \"cManT ourYAMLTextChecks: 'textName' parameter should be defined\");\r\n        console.assert(typeof textName === 'string', `cManT ourYAMLTextChecks: 'textName' parameter should be a string not a '${typeof textName}'`);\r\n        console.assert(manifestText !== undefined, \"cManT ourYAMLTextChecks: 'manifestText' parameter should be defined\");\r\n        console.assert(typeof manifestText === 'string', `cManT ourYAMLTextChecks: 'manifestText' parameter should be a string not a '${typeof manifestText}'`);\r\n        // console.assert( allowedLinks===true || allowedLinks===false, \"cManT ourYAMLTextChecks: allowedLinks parameter must be either true or false\");\r\n\r\n        const cYtResultObject = checkYAMLText('en', textName, manifestText, givenLocation, checkingOptions);\r\n\r\n        // Concat is faster if we dont need to process each notice individually\r\n        cmtResult.successList = cmtResult.successList.concat(cYtResultObject.successList);\r\n        cmtResult.noticeList = cmtResult.noticeList.concat(cYtResultObject.noticeList);\r\n        return cYtResultObject.formData;\r\n    }\r\n    // end of ourYAMLTextChecks function\r\n\r\n\r\n    // Main code for checkManifestText function\r\n    const formData = ourYAMLTextChecks(repoName, manifestText, ourLocation, checkingOptions);\r\n    if (formData) {\r\n        // console.log(\"formData\", JSON.stringify(formData));\r\n        const formDataKeys = Object.keys(formData);\r\n        // console.log(\"formData keys\", JSON.stringify(formDataKeys));\r\n\r\n        if (formDataKeys.indexOf('dublin_core') < 0)\r\n            addNotice({ priority: 928, message: \"'dublin_core' key is missing\", location: ourLocation });\r\n        if (formDataKeys.indexOf('projects') < 0)\r\n            addNotice({ priority: 929, message: \"'projects' key is missing\", location: ourLocation });\r\n        if (formDataKeys.indexOf('checking') < 0)\r\n            addNotice({ priority: 148, message: \"'checking' key is missing\", location: ourLocation });\r\n\r\n        // Check Dublin Core stuff\r\n        // const DublinCoreData = formData.dublin_core\r\n        // console.log(\"checkManifestText DublinCoreData\", JSON.stringify(DublinCoreData));\r\n\r\n        // TODO: We could add a lot more checking here\r\n        // for (const mainKey in formData) {\r\n        //     console.log(\"mainKey\", typeof mainKey, mainKey);\r\n        //     const mainSection = formData[mainKey];\r\n        //     console.log(\"mainSection\", typeof mainSection, JSON.stringify(mainSection));\r\n        //     for (const key2 in mainSection) {\r\n        //         console.log(mainKey, \"key2\", typeof key2, key2);\r\n        //         const section2 = mainSection[key2];\r\n        //         console.log(mainKey, \"section2\", typeof section2, JSON.stringify(section2));\r\n\r\n        //     }\r\n        // }\r\n\r\n        // Validate Resource Container manifest against the schema\r\n        //  using AJV from https://www.npmjs.com/package/ajv\r\n        const valid = validate(formData);\r\n        if (!valid) {\r\n            // console.log(\"checkManifestText validationResult\", valid, JSON.stringify(validate.errors));\r\n            // Here's a typical error entry:\r\n            //  {\"keyword\":\"pattern\",\r\n            //   \"dataPath\":\".dublin_core.source[0].identifier\",\r\n            //   \"schemaPath\":\"#/properties/dublin_core/properties/source/items/properties/identifier/pattern\",\r\n            //   \"params\":{\"pattern\":\"^[a-z][a-z0-9-]\"},\r\n            //   \"message\":\"should match pattern \\\"^[a-z][a-z0-9-]\\\"\"}\r\n            for (const errorObject of validate.errors) {\r\n                // console.log(\"checkManifestText schema validation errorObject\", JSON.stringify(errorObject));\r\n                // Cant give a lineNumber unfortunately\r\n                addNotice({ priority: 985, message: `Field does not match schema ${errorObject.keyword}`, details: errorObject.message, fieldName: errorObject.dataPath, location: ourLocation });\r\n            }\r\n        }\r\n\r\n        // Check the project files in the manifest actually exist\r\n        const getFile_ = (checkingOptions && checkingOptions?.getFile) ? checkingOptions?.getFile : cachedGetFile;\r\n        for (const projectEntry of formData['projects']) {\r\n            // console.log(`Manifest project: ${JSON.stringify(projectEntry)}`);\r\n            const projectKeys = Object.keys(projectEntry); // Expect title, versification, identifier, sort, path, categories\r\n            // console.log(\"Project keys\", JSON.stringify(projectKeys));\r\n            for (const keyName of ['identifier', 'path', 'sort'])\r\n                if (projectKeys.indexOf(keyName) === -1)\r\n                    addNotice({ priority: 939, message: \"Key is missing for project\", details: keyName, extract: JSON.stringify(projectEntry), location: ourLocation });\r\n\r\n            const projectFilepath = projectEntry['path'];\r\n            if (repoName\r\n                && projectFilepath !== './content' // Ignore this common folder path\r\n                && projectFilepath !== './bible' // Ignore this common folder path\r\n                && projectFilepath !== './intro' && projectFilepath !== './process' && projectFilepath !== './translate' && projectFilepath !== './checking' // Ignore these TA folder paths\r\n                && (!checkingOptions || checkingOptions?.disableAllLinkFetchingFlag !== true)) { // Try fetching the file maybe\r\n                let isBookFolder = false;\r\n                for (const thisBookID of Object.keys(BibleBookData))\r\n                    if (projectFilepath === `./${thisBookID}`) { isBookFolder = true; break; }\r\n                if (!isBookFolder) {\r\n                    let projectFileContent;\r\n                    try {\r\n                        projectFileContent = await getFile_({ username, repository: repoName, path: projectFilepath, branch: repoBranch });\r\n                        // console.log(\"Fetched manifest project fileContent for\", repoName, projectFilepath, typeof projectFileContent, projectFileContent.length);\r\n                        if (!projectFileContent)\r\n                            addNotice({ priority: 938, message: `Unable to find project file mentioned in manifest`, extract: projectFilepath, location: ourLocation });\r\n                        else if (projectFileContent.length < 10)\r\n                            addNotice({ priority: 937, message: `Linked project file seems empty`, extract: projectFilepath, location: ourLocation });\r\n                    } catch (trcGCerror) {\r\n                        addNotice({ priority: 936, message: `Error loading manifest project link`, details: trcGCerror, extract: projectFilepath, location: ourLocation });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!checkingOptions?.suppressNoticeDisablingFlag) {\r\n        // console.log(`checkManifestText: calling removeDisabledNotices(${cmtResult.noticeList.length}) having ${JSON.stringify(checkingOptions)}`);\r\n        cmtResult.noticeList = removeDisabledNotices(cmtResult.noticeList);\r\n    }\r\n\r\n    // addSuccessMessage(`Checked all ${lines.length.toLocaleString()} line${lines.length==1?'':'s'}${ourLocation}.`);\r\n    if (cmtResult.noticeList)\r\n        addSuccessMessage(`checkManifestText v${MANIFEST_VALIDATOR_VERSION_STRING} finished with ${cmtResult.noticeList.length ? cmtResult.noticeList.length.toLocaleString() : \"zero\"} notice${cmtResult.noticeList.length === 1 ? '' : 's'}`);\r\n    else\r\n        addSuccessMessage(`No errors or warnings found by checkManifestText v${MANIFEST_VALIDATOR_VERSION_STRING}`)\r\n    // console.log(`  checkManifestText returning with ${cmtResult.successList.length.toLocaleString()} success(es), ${cmtResult.noticeList.length.toLocaleString()} notice(s).`);\r\n    // console.log(\"checkManifestText result is\", JSON.stringify(cmtResult));\r\n    return cmtResult;\r\n}\r\n// end of checkManifestText function\r\n","import * as books from './books/books';\r\nimport { DEFAULT_EXTRACT_LENGTH } from './text-handling-functions'\r\nimport { checkTN_TSVDataRow } from './tn-table-row-check';\r\nimport { removeDisabledNotices } from './disabled-notices';\r\n\r\n\r\nconst TN_TABLE_TEXT_VALIDATOR_VERSION_STRING = '0.3.0';\r\n\r\nconst NUM_EXPECTED_TN_TSV_FIELDS = 9; // so expects 8 tabs per line\r\nconst EXPECTED_TN_HEADING_LINE = 'Book\\tChapter\\tVerse\\tID\\tSupportReference\\tOrigQuote\\tOccurrence\\tGLQuote\\tOccurrenceNote';\r\n\r\n\r\nexport async function checkTN_TSVText(languageCode, bookID, filename, tableText, givenLocation, checkingOptions) {\r\n    /* This function is optimised for checking the entire file, i.e., all rows.\r\n\r\n      It also has the advantage of being able to compare one row with the previous one.\r\n\r\n     bookID is a three-character UPPERCASE USFM book identifier or 'OBS'.\r\n\r\n     Returns a result object containing a successList and a noticeList\r\n     */\r\n    // console.log(`checkTN_TSVText(${bookID}, ${tableText.length}, ${location},${JSON.stringify(checkingOptions)})`);\r\n    console.assert(languageCode !== undefined, \"checkTN_TSVText: 'languageCode' parameter should be defined\");\r\n    console.assert(typeof languageCode === 'string', `checkTN_TSVText: 'languageCode' parameter should be a string not a '${typeof languageCode}'`);\r\n    console.assert(bookID !== undefined, \"checkTN_TSVText: 'bookID' parameter should be defined\");\r\n    console.assert(typeof bookID === 'string', `checkTN_TSVText: 'bookID' parameter should be a string not a '${typeof bookID}'`);\r\n    console.assert(bookID.length === 3, `checkTN_TSVText: 'bookID' parameter should be three characters long not ${bookID.length}`);\r\n    console.assert(bookID.toUpperCase() === bookID, `checkTN_TSVText: 'bookID' parameter should be UPPERCASE not '${bookID}'`);\r\n    console.assert(books.isValidBookID(bookID), `checkTN_TSVText: '${bookID}' is not a valid USFM book identifier`);\r\n    console.assert(givenLocation !== undefined, \"checkTN_TSVText: 'givenLocation' parameter should be defined\");\r\n    console.assert(typeof givenLocation === 'string', `checkTN_TSVText: 'givenLocation' parameter should be a string not a '${typeof givenLocation}'`);\r\n    console.assert(checkingOptions !== undefined, \"checkTN_TSVText: 'checkingOptions' parameter should be defined\");\r\n\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n    const ttResult = { successList: [], noticeList: [] };\r\n\r\n    function addSuccessMessage(successString) {\r\n        // console.log(`checkTN_TSVText success: ${successString}`);\r\n        ttResult.successList.push(successString);\r\n    }\r\n    function addNoticePartial(noticeObject) {\r\n        // console.log(`checkTN_TSVText notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : \"\"}${extract ? ` ${extract}` : \"\"}${location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"TSV addNoticePartial: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `TSV addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"TSV addNoticePartial: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `TSV addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(C !== undefined, \"TSV addNoticePartial: 'C' parameter should be defined\");\r\n        if (noticeObject.C) console.assert(typeof noticeObject.C === 'string', `TSV addNoticePartial: 'C' parameter should be a string not a '${typeof noticeObject.C}': ${noticeObject.C}`);\r\n        // console.assert(V !== undefined, \"TSV addNoticePartial: 'V' parameter should be defined\");\r\n        if (noticeObject.V) console.assert(typeof noticeObject.V === 'string', `TSV addNoticePartial: 'V' parameter should be a string not a '${typeof noticeObject.V}': ${noticeObject.V}`);\r\n        // console.assert(characterIndex !== undefined, \"TSV addNoticePartial: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `TSV addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract !== undefined, \"TSV addNoticePartial: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `TSV addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"TSV addNoticePartial: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `TSV addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n        if (noticeObject.debugChain) noticeObject.debugChain = `checkTN_TSVText ${noticeObject.debugChain}`;\r\n        ttResult.noticeList.push({ ...noticeObject, bookID, filename });\r\n    }\r\n\r\n\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (ttcError) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n    // console.log(`Using supplied extractLength=${extractLength}`, `cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    // const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    // const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n    let lowercaseBookID = bookID.toLowerCase();\r\n    let numChaptersThisBook = 0;\r\n    try {\r\n        console.assert(lowercaseBookID !== 'obs', \"Shouldnt happen in tn_table-text-check\");\r\n        numChaptersThisBook = books.chaptersInBook(lowercaseBookID).length;\r\n    }\r\n    catch {\r\n        if (!books.isValidBookID(bookID)) // must not be in FRT, BAK, etc.\r\n            addNoticePartial({ priority: 747, message: \"Bad function call: should be given a valid book abbreviation\", extract: bookID, location: ` (not '${bookID}')${ourLocation}` });\r\n    }\r\n\r\n    let lines = tableText.split('\\n');\r\n    // console.log(`  '${location}' has ${lines.length.toLocaleString()} total lines (expecting ${NUM_EXPECTED_TN_FIELDS} fields in each line)`);\r\n\r\n    let lastB = '', lastC = '', lastV = '';\r\n    let rowIDList = [], uniqueRowList = [];\r\n    let numVersesThisChapter = 0;\r\n    for (let n = 0; n < lines.length; n++) {\r\n        // console.log(`checkTN_TSVText checking line ${n}: ${JSON.stringify(lines[n])}`);\r\n        if (n === 0) {\r\n            if (lines[0] === EXPECTED_TN_HEADING_LINE)\r\n                addSuccessMessage(`Checked TSV header ${ourLocation}`);\r\n            else\r\n                addNoticePartial({ priority: 746, message: \"Bad TSV header\", lineNumber: n + 1, location: `${ourLocation}: '${lines[0]}'` });\r\n        }\r\n        else // not the header\r\n        {\r\n            let fields = lines[n].split('\\t');\r\n            if (fields.length === NUM_EXPECTED_TN_TSV_FIELDS) {\r\n                // eslint-disable-next-line no-unused-vars\r\n                const [B, C, V, rowID, supportReference, origQuote, occurrence, _GLQuote, _occurrenceNote] = fields;\r\n\r\n                // Use the row check to do most basic checks\r\n                const drResultObject = await checkTN_TSVDataRow(languageCode, lines[n], bookID, C, V, ourLocation, checkingOptions);\r\n                // Choose only ONE of the following\r\n                // This is the fast way of append the results from this field\r\n                // result.noticeList = result.noticeList.concat(firstResult.noticeList);\r\n                // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n                //  process results line by line\r\n                for (const drNoticeEntry of drResultObject.noticeList)\r\n                    if (drNoticeEntry.extra) // it must be an indirect check on a TA or TW article from a TN check\r\n                        ttResult.noticeList.push(drNoticeEntry); // Just copy the complete notice as is\r\n                    else\r\n                        addNoticePartial({ ...drNoticeEntry, lineNumber: n + 1 });\r\n                // The following is needed coz we might be checking the linked TA and/or TW articles\r\n                if (drResultObject.checkedFileCount && drResultObject.checkedFileCount > 0)\r\n                    if (typeof ttResult.checkedFileCount === 'number') ttResult.checkedFileCount += drResultObject.checkedFileCount;\r\n                    else ttResult.checkedFileCount = drResultObject.checkedFileCount;\r\n                if (drResultObject.checkedFilesizes && drResultObject.checkedFilesizes > 0)\r\n                    if (typeof ttResult.checkedFilesizes === 'number') ttResult.checkedFilesizes += drResultObject.checkedFilesizes;\r\n                    else ttResult.checkedFilesizes = drResultObject.checkedFilesizes;\r\n                if (drResultObject.checkedRepoNames && drResultObject.checkedRepoNames.length > 0)\r\n                    for (const checkedRepoName of drResultObject.checkedRepoNames)\r\n                        try { if (ttResult.checkedRepoNames.indexOf(checkedRepoName) < 0) ttResult.checkedRepoNames.push(checkedRepoName); }\r\n                        catch { ttResult.checkedRepoNames = [checkedRepoName]; }\r\n                if (drResultObject.checkedFilenameExtensions && drResultObject.checkedFilenameExtensions.length > 0)\r\n                    for (const checkedFilenameExtension of drResultObject.checkedFilenameExtensions)\r\n                        try { if (ttResult.checkedFilenameExtensions.indexOf(checkedFilenameExtension) < 0) ttResult.checkedFilenameExtensions.push(checkedFilenameExtension); }\r\n                        catch { ttResult.checkedFilenameExtensions = [checkedFilenameExtension]; }\r\n                // if (ttResult.checkedFilenameExtensions) console.log(\"ttResult\", JSON.stringify(ttResult));\r\n\r\n                // So here we only have to check against the previous and next fields for out-of-order problems and duplicate problems\r\n                if (B !== lastB || C !== lastC || V !== lastV) {\r\n                    rowIDList = []; // ID's only need to be unique within each verse\r\n                    uniqueRowList = []; // Same for these\r\n                }\r\n\r\n                // TODO: Check if we need this at all (even though tC 3.0 cant display these \"duplicate\" notes)\r\n                // Check for duplicate notes\r\n                const uniqueID = C + V + supportReference + origQuote + occurrence; // This combination should not be repeated\r\n                // if (uniqueRowList.includes(uniqueID))\r\n                //     addNoticePartial({ priority: 880, C, V, message: `Duplicate note`, rowID, lineNumber: n + 1, location: ourLocation });\r\n                // if (uniqueRowList.includes(uniqueID))\r\n                //     addNoticePartial({ priority: 80, C, V, message: `Note: tC 3.0 wont display duplicate note`, rowID, lineNumber: n + 1, location: ourLocation });\r\n                uniqueRowList.push(uniqueID);\r\n\r\n                if (B) {\r\n                    if (B !== bookID)\r\n                        addNoticePartial({ priority: 745, C, V, message: `Wrong '${B}' book identifier (expected '${bookID}')`, rowID, lineNumber: n + 1, location: ourLocation });\r\n                }\r\n                else\r\n                    addNoticePartial({ priority: 744, C, V, message: \"Missing book identifier\", rowID, lineNumber: n + 1, location: ourLocation });\r\n\r\n                if (C) {\r\n                    if (C === 'front') { }\r\n                    else if (/^\\d+$/.test(C)) {\r\n                        let intC = Number(C);\r\n                        if (C !== lastC)\r\n                            numVersesThisChapter = books.versesInChapter(lowercaseBookID, intC);\r\n                        if (intC === 0)\r\n                            addNoticePartial({ priority: 551, C, V, message: `Invalid zero chapter number`, rowID, lineNumber: n + 1, extract: C, location: ourLocation });\r\n                        if (intC > numChaptersThisBook)\r\n                            addNoticePartial({ priority: 737, C, V, message: \"Invalid large chapter number\", rowID, lineNumber: n + 1, extract: C, location: ourLocation });\r\n                        if (/^\\d+$/.test(lastC)) {\r\n                            let lastintC = Number(lastC);\r\n                            if (intC < lastintC)\r\n                                addNoticePartial({ priority: 736, C, V, message: \"Receding chapter number\", details: `'${C}' after '${lastC}'`, rowID, lineNumber: n + 1, location: ourLocation });\r\n                            else if (intC > lastintC + 1)\r\n                                addNoticePartial({ priority: 735, C, V, message: \"Advancing chapter number\", details: `'${C}' after '${lastC}'`.rowID, lineNumber: n + 1, location: ourLocation });\r\n                        }\r\n                    }\r\n                    else\r\n                        addNoticePartial({ priority: 734, C, V, message: \"Bad chapter number\", rowID, lineNumber: n + 1, location: ourLocation });\r\n                }\r\n                else\r\n                    addNoticePartial({ priority: 739, C, V, message: \"Missing chapter number\", rowID, lineNumber: n + 1, location: ` after ${lastC}:${V}${ourLocation}` });\r\n\r\n                if (V) {\r\n                    if (V === 'intro') { }\r\n                    else if (/^\\d+$/.test(V)) {\r\n                        let intV = Number(V);\r\n                        if (intV === 0)\r\n                            addNoticePartial({ priority: 552, C, V, message: \"Invalid zero verse number\", details: `for chapter ${C}`, rowID, lineNumber: n + 1, extract: V, location: ourLocation });\r\n                        if (intV > numVersesThisChapter)\r\n                            addNoticePartial({ priority: 734, C, V, message: \"Invalid large verse number\", details: `for chapter ${C}`, rowID, lineNumber: n + 1, extract: V, location: ourLocation });\r\n                        if (/^\\d+$/.test(lastV)) {\r\n                            let lastintV = Number(lastV);\r\n                            if (C === lastC && intV < lastintV)\r\n                                addNoticePartial({ priority: 733, C, V, message: \"Receding verse number\", details: `'${V}' after '${lastV} for chapter ${C}`, rowID, lineNumber: n + 1, extract: V, location: ourLocation });\r\n                            // else if (intV > lastintV + 1)\r\n                            //   addNoticePartial({priority:556, \"Skipped verses with '${V}' verse number after '${lastV}'${withString}`);\r\n                        }\r\n                    }\r\n                    else\r\n                        addNoticePartial({ priority: 738, C, V, message: \"Bad verse number\", rowID, lineNumber: n + 1, location: ourLocation });\r\n\r\n                }\r\n                else\r\n                    addNoticePartial({ priority: 790, C, V, message: \"Missing verse number\", rowID, lineNumber: n + 1, location: ` after ${C}:${lastV}${ourLocation}` });\r\n\r\n                if (rowID) {\r\n                    if (rowIDList.includes(rowID))\r\n                        addNoticePartial({ priority: 729, C, V, message: `Duplicate '${rowID}' ID`, fieldName: 'ID', rowID, lineNumber: n + 1, location: ourLocation });\r\n                } else\r\n                    addNoticePartial({ priority: 730, C, V, message: \"Missing ID\", fieldName: 'ID', lineNumber: n + 1, location: ourLocation });\r\n\r\n\r\n                lastB = B; lastC = C; lastV = V;\r\n\r\n            } else // wrong number of fields in the row\r\n                // if (n === lines.length - 1) // its the last line\r\n                //     console.log(`  Line ${n}: Has ${fields.length} field(s) instead of ${NUM_EXPECTED_TN_FIELDS}: ${EXPECTED_TN_HEADING_LINE.replace(/\\t/g, ', ')}`);\r\n                // else\r\n                if (n !== lines.length - 1) { // its not the last line\r\n                    // Have a go at getting some of the first fields out of the line\r\n                    let C = '?', V = '?', rowID = '????';\r\n                    try { C = fields[1]; } catch { }\r\n                    try { V = fields[2]; } catch { }\r\n                    try { rowID = fields[3]; } catch { }\r\n                    addNoticePartial({ priority: 988, message: `Wrong number of tabbed fields (expected ${NUM_EXPECTED_TN_TSV_FIELDS})`, extract: `Found ${fields.length} field${fields.length === 1 ? '' : 's'}`, C, V, rowID, lineNumber: n + 1, location: ourLocation });\r\n                }\r\n        }\r\n    }\r\n\r\n    if (!checkingOptions?.suppressNoticeDisablingFlag) {\r\n        // console.log(`checkTN_TSVText: calling removeDisabledNotices(${ttResult.noticeList.length}) having ${JSON.stringify(checkingOptions)}`);\r\n        ttResult.noticeList = removeDisabledNotices(ttResult.noticeList);\r\n    }\r\n\r\n    if ((!checkingOptions?.cutoffPriorityLevel || checkingOptions?.cutoffPriorityLevel < 20)\r\n        && checkingOptions?.disableAllLinkFetchingFlag)\r\n        addNoticePartial({ priority: 20, message: \"Note that 'disableAllLinkFetchingFlag' was set so link targets were not checked\", location: ourLocation });\r\n\r\n    addSuccessMessage(`Checked all ${(lines.length - 1).toLocaleString()} data line${lines.length - 1 === 1 ? '' : 's'}${ourLocation}.`);\r\n    if (ttResult.noticeList)\r\n        addSuccessMessage(`checkTN_TSVText v${TN_TABLE_TEXT_VALIDATOR_VERSION_STRING} finished with ${ttResult.noticeList.length ? ttResult.noticeList.length.toLocaleString() : \"zero\"} notice${ttResult.noticeList.length === 1 ? '' : 's'}`);\r\n    else\r\n        addSuccessMessage(`No errors or warnings found by checkTN_TSVText v${TN_TABLE_TEXT_VALIDATOR_VERSION_STRING}`)\r\n    // console.log(`  checkTN_TSVText returning with ${result.successList.length.toLocaleString()} success(es), ${result.noticeList.length.toLocaleString()} notice(s).`);\r\n    // console.log(\"checkTN_TSVText result is\", JSON.stringify(result));\r\n    return ttResult;\r\n}\r\n// end of checkTN_TSVText function\r\n","import { DEFAULT_EXTRACT_LENGTH, isWhitespace, countOccurrences, ourDeleteAll } from './text-handling-functions'\r\nimport * as books from '../core/books/books';\r\nimport { checkTextField } from './field-text-check';\r\nimport { checkTextfileContents } from './file-text-check';\r\nimport { runUsfmJsCheck } from './usfm-js-check';\r\nimport { runBCSGrammarCheck } from './BCS-usfm-grammar-check';\r\nimport { ourParseInt } from './utilities';\r\nimport { removeDisabledNotices } from './disabled-notices';\r\n\r\n\r\n// const USFM_VALIDATOR_VERSION_STRING = '0.7.6';\r\n\r\n\r\nconst VALID_LINE_START_CHARACTERS = `([`; // '{' gets added for STs\r\n\r\n// See http://ubsicap.github.io/usfm/master/index.html\r\nconst COMPULSORY_MARKERS = ['id', 'ide'];\r\nconst EXPECTED_MARKERS = ['usfm', 'mt1'];\r\nconst EXPECTED_BIBLE_BOOK_MARKERS = ['h', 'toc1', 'toc2', 'toc3'];\r\nconst EXPECTED_PERIPHERAL_BOOK_MARKERS = ['periph'];\r\n\r\nconst INTRO_LINE_START_MARKERS = ['id', 'usfm', 'ide', 'h',\r\n    'toc1', 'toc2', 'toc3',\r\n    'mt', 'mt1', 'mt2',\r\n    'mte', 'mte1', 'mte2',\r\n    'imt', 'imt1', 'imt2',\r\n    'is', 'is1', 'is2',\r\n    'ip', 'ipi', 'im', 'imi', 'ipq', 'imq', 'ipr',\r\n    'iq', 'iq1', 'iq2',\r\n    'ili', 'ili1', 'ili2',\r\n    'iot', 'io', 'io1', 'io2',\r\n    'iex', 'imte', 'imte1', 'imte2'];\r\nconst CV_MARKERS = ['c', 'v', 'ca', 'va'];\r\nconst HEADING_TYPE_MARKERS = [ // expected to contain text on the same line\r\n    's', 's1', 's2', 's3', 's4', 'sr',\r\n    'ms', 'ms1', 'mr',\r\n    'r', 'd', 'rem', 'sp', 'qs', 'cl',\r\n    'sd', 'sd1', 'sd2',\r\n    'pr', 'qa', 'qc', 'qd', 'qr',\r\n    'cls', 'pmo', 'pmc', 'pmr', 'pc',\r\n    'periph'];\r\nconst PARAGRAPH_MARKERS = ['p',\r\n    'q', 'q1', 'q2', 'q3', 'q4',\r\n    'qm', 'qm1', 'qm2', 'qm3', 'qm4',\r\n    'm', 'mi',\r\n    'pi', 'pi1', 'pi2', 'pi3', 'pi4',\r\n    'li', 'li1', 'li2', 'li3', 'li4',\r\n    'lim', 'lim1', 'lim2', 'lim3', 'lim4',\r\n    'lh', 'lf',\r\n    'po', 'pm',\r\n    'ph', 'ph1', 'ph2', 'ph3', 'ph4',\r\n    'tr'];\r\nconst NOTE_MARKERS = ['f', 'x'];\r\nconst SPECIAL_MARKERS = ['w', 'zaln-s', 'k-s',\r\n    'qt-s', 'qt1-s', 'qt2-s',\r\n    'lit'];\r\nconst MILESTONE_MARKERS = ['ts\\\\*', 'ts-s', 'ts-e', 'k-e\\\\*']; // Is this a good way to handle it???\r\nconst MARKERS_WITHOUT_CONTENT = ['b', 'nb', 'ib', 'ie'].concat(MILESTONE_MARKERS);\r\nconst ALLOWED_LINE_START_MARKERS = [].concat(INTRO_LINE_START_MARKERS).concat(HEADING_TYPE_MARKERS)\r\n    .concat(CV_MARKERS).concat(PARAGRAPH_MARKERS)\r\n    .concat(NOTE_MARKERS).concat(SPECIAL_MARKERS).concat(MARKERS_WITHOUT_CONTENT)\r\n    .concat(MILESTONE_MARKERS);\r\nconst DEPRECATED_MARKERS = [\r\n    'h1', 'h2', 'h3', 'h4',\r\n    'pr',\r\n    'ph', 'ph1', 'ph2', 'ph3', 'ph4',\r\n    'addpn', 'pro', 'fdc', 'xdc'];\r\nconst MARKERS_WITH_COMPULSORY_CONTENT = [].concat(INTRO_LINE_START_MARKERS).concat(HEADING_TYPE_MARKERS)\r\n    .concat(CV_MARKERS).concat(NOTE_MARKERS).concat(SPECIAL_MARKERS);\r\nconst FOOTNOTE_INTERNAL_MARKERS = ['fr', 'fq', 'fqa', 'fk', 'fl', 'fw', 'fp', 'fv', 'ft', 'fdc', 'fm', 'xt'];\r\nconst XREF_INTERNAL_MARKERS = ['xo', 'xk', 'xq', 'xt', 'xta', 'xop', 'xot', 'xnt', 'xdc', 'rq'];\r\nconst SIMPLE_CHARACTER_MARKERS = ['add', 'bk', 'dc', 'k', 'nd', 'ord', 'pn', 'png', 'addpn',\r\n    'qt', 'sig', 'sls', 'tl', 'wj',\r\n    'ior', 'iqt', // TODO: What/Why was 'rq' in here???\r\n    'em', 'bd', 'it', 'bdit', 'no', 'sc', 'sup',\r\n    'ndx', 'rb', 'pro', 'wg', 'wh', 'wa',\r\n    'litl', 'lik',\r\n    'liv', 'liv1', 'liv2', 'liv3', 'liv4'];\r\nconst CHARACTER_MARKERS = ['fig', 'w'].concat(SIMPLE_CHARACTER_MARKERS); // NOTE that we have \\w in TWO places\r\nconst SIMPLE_INTERNAL_MARKERS = [SIMPLE_CHARACTER_MARKERS].concat().concat(FOOTNOTE_INTERNAL_MARKERS).concat(XREF_INTERNAL_MARKERS)\r\n// eslint-disable-next-line no-unused-vars\r\nconst CANONICAL_TEXT_MARKERS = ['d'].concat(PARAGRAPH_MARKERS).concat(CHARACTER_MARKERS);\r\n// eslint-disable-next-line no-unused-vars\r\nconst ANY_TEXT_MARKERS = [].concat(INTRO_LINE_START_MARKERS).concat(HEADING_TYPE_MARKERS)\r\n    .concat(PARAGRAPH_MARKERS).concat(CHARACTER_MARKERS)\r\n    .concat(NOTE_MARKERS).concat(SPECIAL_MARKERS);\r\nconst MATCHED_CHARACTER_FORMATTING_PAIRS = [\r\n    ['\\\\add ', '\\\\add*'], ['\\\\addpn ', '\\\\addpn*'],\r\n    ['\\\\bd ', '\\\\bd*'], ['\\\\bdit ', '\\\\bdit*'],\r\n    ['\\\\bk ', '\\\\bk*'],\r\n    ['\\\\dc ', '\\\\dc*'],\r\n    ['\\\\em ', '\\\\em*'],\r\n    ['\\\\fig ', '\\\\fig*'],\r\n    ['\\\\ior ', '\\\\ior*'],\r\n    ['\\\\iqt ', '\\\\iqt*'],\r\n    ['\\\\it ', '\\\\it*'],\r\n    ['\\\\k ', '\\\\k*'],\r\n    ['\\\\litl ', '\\\\litl*'],\r\n    ['\\\\lik ', '\\\\lik*'],\r\n    ['\\\\liv ', '\\\\liv*'], ['\\\\liv1 ', '\\\\liv1*'], ['\\\\liv2 ', '\\\\liv2*'], ['\\\\liv3 ', '\\\\liv3*'], ['\\\\liv4 ', '\\\\liv4*'],\r\n    ['\\\\nd ', '\\\\nd*'], ['\\\\ndx ', '\\\\ndx*'],\r\n    ['\\\\no ', '\\\\no*'],\r\n    ['\\\\ord ', '\\\\ord*'],\r\n    ['\\\\pn ', '\\\\pn*'], ['\\\\png ', '\\\\png*'],\r\n    ['\\\\pro ', '\\\\pro*'],\r\n    ['\\\\qt ', '\\\\qt*'],\r\n    ['\\\\rb ', '\\\\rb*'],\r\n    ['\\\\sc ', '\\\\sc*'],\r\n    ['\\\\sig ', '\\\\sig*'],\r\n    ['\\\\sls ', '\\\\sls*'],\r\n    ['\\\\sup ', '\\\\sup*'],\r\n    ['\\\\tl ', '\\\\tl*'],\r\n    ['\\\\w ', '\\\\w*'],\r\n    ['\\\\wa ', '\\\\wa*'], ['\\\\wg ', '\\\\wg*'], ['\\\\wh ', '\\\\wh*'],\r\n    ['\\\\wj ', '\\\\wj*'],\r\n\r\n    ['\\\\ca ', '\\\\ca*'], ['\\\\va ', '\\\\va*'],\r\n\r\n    ['\\\\f ', '\\\\f*'], ['\\\\x ', '\\\\x*'],\r\n];\r\n\r\n\r\n\r\nexport function checkUSFMText(languageCode, repoCode, bookID, filename, givenText, givenLocation, checkingOptions) {\r\n    /* This function is optimised for checking the entire file, i.e., all lines.\r\n\r\n    bookID is a three-character UPPERCASE USFM book identifier.\r\n\r\n    filename parameter can be an empty string if we dont have one.\r\n\r\n     Returns a result object containing a successList and a noticeList\r\n     */\r\n    // console.log(`checkUSFMText(${languageCode}, ${bookID}, ${givenText.length.toLocaleString()} chars, '${givenLocation}', ${JSON.stringify(checkingOptions)})`);\r\n    console.assert(languageCode !== undefined, \"checkUSFMText: 'languageCode' parameter should be defined\");\r\n    console.assert(typeof languageCode === 'string', `checkUSFMText: 'languageCode' parameter should be a string not a '${typeof languageCode}'`);\r\n    console.assert(repoCode !== undefined, \"checkUSFMText: 'repoCode' parameter should be defined\");\r\n    console.assert(typeof repoCode === 'string', `checkUSFMText: 'repoCode' parameter should be a string not a '${typeof repoCode}'`);\r\n    console.assert(bookID !== undefined, \"checkUSFMText: 'bookID' parameter should be defined\");\r\n    console.assert(typeof bookID === 'string', `checkUSFMText: 'bookID' parameter should be a string not a '${typeof bookID}'`);\r\n    console.assert(bookID.length === 3, `checkUSFMText: 'bookID' parameter should be three characters long not ${bookID.length}`);\r\n    console.assert(bookID.toUpperCase() === bookID, `checkUSFMText: 'bookID' parameter should be UPPERCASE not '${bookID}'`);\r\n    console.assert(bookID === 'OBS' || books.isValidBookID(bookID), `checkUSFMText: '${bookID}' is not a valid USFM book identifier`);\r\n    console.assert(filename !== undefined, \"checkUSFMText: 'filename' parameter should be defined\");\r\n    console.assert(typeof filename === 'string', `checkUSFMText: 'filename' parameter should be a string not a '${typeof filename}'`);\r\n    console.assert(givenLocation !== undefined, \"checkUSFMText: 'givenRowLocation' parameter should be defined\");\r\n    console.assert(typeof givenLocation === 'string', `checkUSFMText: 'givenRowLocation' parameter should be a string not a '${typeof givenLocation}'`);\r\n    console.assert(checkingOptions !== undefined, \"checkUSFMText: 'checkingOptions' parameter should be defined\");\r\n\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (usfmELerror) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n    // console.log(`Using supplied extractLength=${extractLength} cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n    const lowercaseBookID = bookID.toLowerCase();\r\n\r\n    let validLineStartCharacters = VALID_LINE_START_CHARACTERS;\r\n    if (repoCode === 'ST') validLineStartCharacters += '{';\r\n\r\n    const result = { successList: [], noticeList: [] };\r\n\r\n    function addSuccessMessage(successString) {\r\n        // console.log(`checkUSFMText success: ${successString}`);\r\n        result.successList.push(successString);\r\n    }\r\n    function addNoticePartial(noticeObject) {\r\n        // console.log(\"checkUSFMText addNoticePartial:\", JSON.stringify(noticeObject));\r\n        // console.log(`checkUSFMText addNoticePartial: (priority=${noticeObject.priority}) ${noticeObject.C}:${noticeObject.V} ${noticeObject.message}${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : \"\"}${noticeObject.extract ? ` ${noticeObject.extract}` : \"\"}${noticeObject.location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"cUSFM addNoticePartial: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `cUSFM addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"cUSFM addNoticePartial: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `cUSFM addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(C !== undefined, \"cUSFM addNoticePartial: 'C' parameter should be defined\");\r\n        if (noticeObject.C) console.assert(typeof noticeObject.C === 'string', `cUSFM addNoticePartial: 'C' parameter should be a string not a '${typeof noticeObject.C}': ${noticeObject.C}`);\r\n        // console.assert(V !== undefined, \"cUSFM addNoticePartial: 'V' parameter should be defined\");\r\n        if (noticeObject.V) console.assert(typeof noticeObject.V === 'string', `cUSFM addNoticePartial: 'V' parameter should be a string not a '${typeof noticeObject.V}': ${noticeObject.V}`);\r\n        // console.assert(characterIndex !== undefined, \"cUSFM addNoticePartial: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex !== undefined) console.assert(typeof noticeObject.characterIndex === 'number', `cUSFM addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract !== undefined, \"cUSFM addNoticePartial: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cUSFM addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"cUSFM addNoticePartial: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `cUSFM addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n\r\n        // Doublecheck -- we dont want \"Mismatched {}\" per line, only per file\r\n        console.assert(noticeObject.message.indexOf(\"Mismatched {}\") < 0 || noticeObject.lineNumber === undefined, `checkUSFMText addNoticePartial: got bad notice: ${JSON.stringify(noticeObject)}`);\r\n        if (noticeObject.debugChain) noticeObject.debugChain = `checkUSFMText ${noticeObject.debugChain}`;\r\n        result.noticeList.push({ ...noticeObject, bookID, filename });\r\n    }\r\n\r\n\r\n    function ourRunBCSGrammarCheck(filename, fileText, fileLocation) {\r\n        // Runs the BCS USFM Grammar checker\r\n        //  which can be quite time-consuming on large, complex USFM files\r\n        // console.log(\"Running our BCS USFM grammar check (can take quite a while for a large book)\");\r\n\r\n        const grammarCheckResult = runBCSGrammarCheck('strict', fileText, filename, fileLocation, checkingOptions);\r\n        // NOTE: We havent figured out how to get ERRORS out of this parser yet\r\n        // console.log(`  Finished our BCS USFM grammar check with ${grammarCheckResult.isValidUSFM} and ${grammarCheckResult.warnings.length} warnings.`);\r\n        addSuccessMessage(`Checked USFM Grammar (strict mode) ${grammarCheckResult.isValidUSFM ? \"without errors\" : \" (but the USFM DIDNT validate)\"}`);\r\n\r\n        // if (!grammarCheckResult.isValidUSFM) // TEMP DEGRADE TO WARNING 994 -> 544 ................XXXXXXXXXXXXXXXXXXXXXX\r\n        // Dont do this since we add the actual error message elsewhere now\r\n        // addNoticePartial({priority:994, '', '', `USFM3 Grammar Check (strict mode) doesnt pass`, location:fileLocation});\r\n\r\n        // We only get one error if it fails\r\n        if (grammarCheckResult.error && grammarCheckResult.error.priority)\r\n            // Prevent these false alarms (from Ohm schema issues, esp. empty lemma=\"\" fields)\r\n            if (!grammarCheckResult.error.extract\r\n                // Note: checking the extract might not always be reliable if they choose a length < 10\r\n                || (grammarCheckResult.error.extract.indexOf('mma=\"\" ') < 0 // see https://github.com/Bridgeconn/usfm-grammar/issues/87\r\n                    && grammarCheckResult.error.message.indexOf('Expected \"c\", \"v\", ') < 0 // forgotten what this prevents ???\r\n                    && grammarCheckResult.error.message.indexOf('Expected \"f*\", \"+\", ') < 0 // see https://github.com/Bridgeconn/usfm-grammar/issues/86\r\n                ))\r\n                addNoticePartial(grammarCheckResult.error);\r\n\r\n        // console.log(\"  Warnings:\", JSON.stringify(grammarCheckResult.warnings));\r\n        // Display these warnings but with a lower priority\r\n        for (const warningString of grammarCheckResult.warnings)\r\n            if (!warningString.startsWith(\"Empty lines present\") // we allow empty lines in our USFM\r\n                && !warningString.startsWith(\"Trailing spaces present at line end\") // we find these ourselves\r\n            )\r\n                addNoticePartial({ priority: 102, message: `USFMGrammar: ${warningString}`, location: fileLocation });\r\n\r\n        if (!grammarCheckResult.isValidUSFM) {\r\n            const relaxedGrammarCheckResult = runBCSGrammarCheck('relaxed', fileText, filename, fileLocation);\r\n            addSuccessMessage(`Checked USFM Grammar (relaxed mode) ${relaxedGrammarCheckResult.isValidUSFM ? \"without errors\" : \" (but the USFM DIDNT validate)\"}`);\r\n            if (!relaxedGrammarCheckResult.isValidUSFM)\r\n                addNoticePartial({ priority: 644, message: \"USFM3 Grammar Check (relaxed mode) doesnt pass either\", location: fileLocation });\r\n        }\r\n    }\r\n    // end of ourRunBCSGrammarCheck function\r\n\r\n\r\n    function CVCheck(bookID, givenText, CVlocation) {\r\n        /*\r\n        This check uses the USFM-JS package to parse the USFM\r\n            and then it checks the results to make sure all expected verses are there.\r\n\r\n        This has the side advantage that its using exactly the same code/package thats\r\n            used by tCore and tC Create.\r\n\r\n        Note that for verse bridges, USFM-JS returns the bridge, e.g., 24-25\r\n            AS WELL AS an entry for the bridged verses, e.g., 24 and 25.\r\n\r\n        Sadly this package doesnt return any errors or warnings from its parsing\r\n            so thats handle other ways in other places.\r\n\r\n        Note that this code below does NOT check for chapters and verses\r\n            being in the correct order. Thats done elsewhere.\r\n        */\r\n        // console.log(\"Running CVCheck() using USFM-JS (can take quite a while for a large book)\");\r\n        let chapterNumberString, verseNumberString;\r\n\r\n\r\n        const MINIMUM_TEXT_WORDS = 4;\r\n        const MINIMUM_WORD_LENGTH = 2;\r\n        function hasText(verseObjects) {\r\n            let gotDeep = false;\r\n            for (const someObject of verseObjects) {\r\n                // console.log(\"someObject\", JSON.stringify(someObject));\r\n                if (someObject['type'] === 'text' && someObject['text'].length > MINIMUM_TEXT_WORDS)\r\n                    return true;\r\n                if (someObject['type'] === 'word' && someObject['text'].length > MINIMUM_WORD_LENGTH)\r\n                    return true;\r\n                if (someObject['type'] === 'milestone')\r\n                    for (const someSubobject of someObject['children']) {\r\n                        // console.log(\"someSubobject\", JSON.stringify(someSubobject));\r\n                        if (someSubobject['type'] === 'text' && someSubobject['text'].length > MINIMUM_TEXT_WORDS)\r\n                            return true;\r\n                        if (someSubobject['type'] === 'word' && someSubobject['text'].length > MINIMUM_WORD_LENGTH)\r\n                            return true;\r\n                        if (someSubobject['type'] === 'milestone')\r\n                            for (const someSub2object of someSubobject['children']) {\r\n                                // console.log(\"someSub2object\", JSON.stringify(someSub2object));\r\n                                if (someSub2object['type'] === 'text' && someSub2object['text'].length > MINIMUM_TEXT_WORDS)\r\n                                    return true;\r\n                                if (someSub2object['type'] === 'word' && someSub2object['text'].length > MINIMUM_WORD_LENGTH)\r\n                                    return true;\r\n                                if (someSub2object['type'] === 'milestone')\r\n                                    for (const someSub3object of someSub2object['children']) {\r\n                                        // console.log(\"someSub3object\", JSON.stringify(someSub3object));\r\n                                        if (someSub3object['type'] === 'text' && someSub3object['text'].length > MINIMUM_TEXT_WORDS)\r\n                                            return true;\r\n                                        if (someSub3object['type'] === 'word' && someSub3object['text'].length > MINIMUM_WORD_LENGTH)\r\n                                            return true;\r\n                                        if (someSub3object['type'] === 'milestone')\r\n                                            for (const someSub4object of someSub3object['children']) {\r\n                                                // console.log(\"someSub4object\", JSON.stringify(someSub4object));\r\n                                                if (someSub4object['type'] === 'text' && someSub4object['text'].length > MINIMUM_TEXT_WORDS)\r\n                                                    return true;\r\n                                                if (someSub4object['type'] === 'word' && someSub4object['text'].length > MINIMUM_WORD_LENGTH)\r\n                                                    return true;\r\n                                                if (someSub4object['type'] === 'milestone')\r\n                                                    for (const someSub5object of someSub4object['children']) {\r\n                                                        // console.log(\"someSub5object\", JSON.stringify(someSub5object));\r\n                                                        if (someSub5object['type'] === 'text' && someSub5object['text'].length > MINIMUM_TEXT_WORDS)\r\n                                                            return true;\r\n                                                        if (someSub5object['type'] === 'word' && someSub5object['text'].length > MINIMUM_WORD_LENGTH)\r\n                                                            return true;\r\n                                                        if (someSub5object['type'] === 'milestone')\r\n                                                            for (const someSub6object of someSub5object['children']) {\r\n                                                                // console.log(\"someSub6object\", bookID, CVlocation, JSON.stringify(someSub6object));\r\n                                                                if (someSub6object['type'] === 'text' && someSub6object['text'].length > MINIMUM_TEXT_WORDS)\r\n                                                                    return true;\r\n                                                                if (someSub6object['type'] === 'word' && someSub6object['text'].length > MINIMUM_WORD_LENGTH)\r\n                                                                    return true;\r\n                                                                if (someSub6object['type'] === 'milestone')\r\n                                                                    for (const someSub7object of someSub6object['children']) {\r\n                                                                        // console.log(\"someSub7object\", bookID, CVlocation, JSON.stringify(someSub7object));\r\n                                                                        if (someSub7object['type'] === 'text' && someSub7object['text'].length > MINIMUM_TEXT_WORDS)\r\n                                                                            return true;\r\n                                                                        if (someSub7object['type'] === 'word' && someSub7object['text'].length > MINIMUM_WORD_LENGTH)\r\n                                                                            return true;\r\n                                                                        if (someSub7object['type'] === 'milestone')\r\n                                                                            // UST Luke 15:3 has eight levels of nesting !!!\r\n                                                                            for (const someSub8object of someSub7object['children']) {\r\n                                                                                // console.log(\"someSub8object\", bookID, CVlocation, JSON.stringify(someSub8object));\r\n                                                                                if (someSub8object['type'] === 'text' && someSub8object['text'].length > MINIMUM_TEXT_WORDS)\r\n                                                                                    return true;\r\n                                                                                if (someSub8object['type'] === 'word' && someSub8object['text'].length > MINIMUM_WORD_LENGTH)\r\n                                                                                    return true;\r\n                                                                                if (someSub8object['type'] === 'milestone')\r\n                                                                                    for (const someSub9object of someSub8object['children']) {\r\n                                                                                        // console.log(\"someSub9object\", bookID, CVlocation, JSON.stringify(someSub9object));\r\n                                                                                        if (someSub9object['type'] === 'text' && someSub9object['text'].length > MINIMUM_TEXT_WORDS)\r\n                                                                                            return true;\r\n                                                                                        if (someSub9object['type'] === 'word' && someSub9object['text'].length > MINIMUM_WORD_LENGTH)\r\n                                                                                            return true;\r\n                                                                                        if (someSub9object['type'] === 'milestone')\r\n                                                                                            for (const someSub10object of someSub9object['children']) {\r\n                                                                                                // console.log(\"someSub10object\", bookID, CVlocation, JSON.stringify(someSub10object));\r\n                                                                                                if (someSub10object['type'] === 'text' && someSub10object['text'].length > MINIMUM_TEXT_WORDS)\r\n                                                                                                    return true;\r\n                                                                                                if (someSub10object['type'] === 'word' && someSub10object['text'].length > MINIMUM_WORD_LENGTH)\r\n                                                                                                    return true;\r\n                                                                                                if (someSub10object['type'] === 'milestone')\r\n                                                                                                    // UST Obadiah 1:8 has eleven levels of nesting !!!\r\n                                                                                                    for (const someSub11object of someSub10object['children']) {\r\n                                                                                                        // console.log(\"someSub11object\", bookID, CVlocation, JSON.stringify(someSub11object));\r\n                                                                                                        if (someSub11object['type'] === 'text' && someSub11object['text'].length > MINIMUM_TEXT_WORDS)\r\n                                                                                                            return true;\r\n                                                                                                        if (someSub11object['type'] === 'word' && someSub11object['text'].length > MINIMUM_WORD_LENGTH)\r\n                                                                                                            return true;\r\n                                                                                                        if (someSub11object['type'] === 'milestone')\r\n                                                                                                            gotDeep = true;\r\n                                                                                                    }\r\n                                                                                            }\r\n                                                                                    }\r\n                                                                            }\r\n                                                                    }\r\n                                                            }\r\n                                                    }\r\n                                            }\r\n                                    }\r\n                            }\r\n                    }\r\n            }\r\n            if (gotDeep) console.assert(false, `We need to add more depth levels to hasText() for ${bookID} ${chapterNumberString}:${verseNumberString}`);\r\n            // console.log(`hasText() for ${chapterNumberString}:${verseNumberString} returning false with ${typeof verseObjects} (${verseObjects.length}): ${JSON.stringify(verseObjects)}`);\r\n            return false;\r\n        }\r\n        // end of hasText function\r\n\r\n\r\n        // Main code for CVCheck function\r\n        // const lowercaseBookID = bookID.toLowerCase();\r\n        let expectedVersesPerChapterList = [];\r\n        try {\r\n            console.assert(lowercaseBookID !== 'obs', \"Shouldnt happen in usfm-text-check1\");\r\n            expectedVersesPerChapterList = books.chaptersInBook(lowercaseBookID); // A list of integers -- numVerses for each chapter\r\n            // console.log(\"Got chapterList\", JSON.stringify(expectedVersesPerChapterList));\r\n        }\r\n        catch { }\r\n\r\n        // Try doing this using USFM-JS via runUsfmJsCheck()\r\n        const result1 = runUsfmJsCheck(givenText);\r\n        // console.log(\"Got a JSON result\", JSON.stringify(result1));\r\n        // console.log(\"Got a JSON headers result\", JSON.stringify(result1.returnedJSON.headers));\r\n        // console.log(\"Got a JSON chapters result\", JSON.stringify(result1.returnedJSON.chapters));\r\n        for (chapterNumberString in result1.returnedJSON.chapters) {\r\n            // console.log(`chapterNumberString=${chapterNumberString}`);\r\n            // if (chapterNumberString === '3')\r\n            //     console.log(`chapter ${chapterNumberString} ${JSON.stringify(result1.returnedJSON.chapters[chapterNumberString])}`);\r\n            let chapterInt;\r\n            try {\r\n                chapterInt = ourParseInt(chapterNumberString);\r\n            } catch (usfmCIerror) {\r\n                console.log(`CVCheck couldnt convert ${bookID} chapter '${chapterNumberString}': ${usfmCIerror}`);\r\n            }\r\n            if (chapterInt < 1 || chapterInt > expectedVersesPerChapterList.length)\r\n                addNoticePartial({ priority: 869, message: \"Chapter number out of range\", C: chapterNumberString, extract: `${bookID} ${chapterNumberString}`, location: CVlocation });\r\n            else {\r\n                let discoveredVerseList = [], discoveredVerseWithTextList = [];\r\n                // console.log(`Chapter ${chapterNumberString} verses ${Object.keys(result1.returnedJSON.chapters[chapterNumberString])}`);\r\n                for (verseNumberString in result1.returnedJSON.chapters[chapterNumberString]) {\r\n                    if (verseNumberString === 'front') continue; // skip the rest here\r\n                    // if (chapterNumberString === '3')\r\n                    //     console.log(`verseNumberString=${verseNumberString}`);\r\n                    // if (chapterNumberString === '3' && verseNumberString === '14')\r\n                    //     console.log(`verse ${verseNumberString} ${JSON.stringify(result1.returnedJSON.chapters[chapterNumberString][verseNumberString])}`);\r\n                    const verseObjects = result1.returnedJSON.chapters[chapterNumberString][verseNumberString]['verseObjects'];\r\n                    // if (chapterNumberString === '3' && verseNumberString === '14')\r\n                    //     console.log(`verseObjects=${verseObjects}`);\r\n                    const verseHasText = hasText(verseObjects);\r\n                    if (verseNumberString.indexOf('-') >= 0) { // Its a verse bridge\r\n                        const bits = verseNumberString.split('-');\r\n                        const firstVString = bits[0], secondVString = bits[1];\r\n                        let intFirstV, intSecondV;\r\n                        try {\r\n                            intFirstV = ourParseInt(firstVString);\r\n                            intSecondV = ourParseInt(secondVString);\r\n                            for (let v = intFirstV; v <= intSecondV; v++) {\r\n                                discoveredVerseList.push(v);\r\n                                if (verseHasText)\r\n                                    discoveredVerseWithTextList.push(v);\r\n                            }\r\n                        } catch (usfmVIerror) {\r\n                            addNoticePartial({ priority: 762, message: \"Unable to convert verse bridge numbers to integers\", C: chapterNumberString, V: verseNumberString, characterIndex: 3, extract: verseNumberString, location: `${CVlocation} with ${usfmVIerror}` });\r\n                        }\r\n                    } else { // Its NOT a verse bridge\r\n                        let verseInt;\r\n                        try {\r\n                            verseInt = ourParseInt(verseNumberString);\r\n                            discoveredVerseList.push(verseInt);\r\n                        } catch (usfmPIerror) {\r\n                            console.log(`We couldnt convert ${bookID} ${chapterNumberString} verse '${verseNumberString}': ${usfmPIerror}`);\r\n                        }\r\n\r\n                        if (verseInt < 1 || verseInt > expectedVersesPerChapterList[chapterInt - 1])\r\n                            addNoticePartial({ priority: 868, message: \"Verse number out of range\", C: chapterNumberString, V: verseNumberString, extract: `${bookID} ${chapterNumberString}:${verseNumberString}`, location: CVlocation });\r\n\r\n                        if (verseHasText)\r\n                            discoveredVerseWithTextList.push(verseInt);\r\n                    }\r\n                }\r\n\r\n                // Check that expected verses numbers were actually all there\r\n                // console.log(\"Doing missing verse check\");\r\n                for (let v = 1; v <= expectedVersesPerChapterList[chapterInt - 1]; v++) {\r\n                    if (!discoveredVerseList.includes(v))\r\n                        if (books.isOftenMissing(bookID, chapterInt, v))\r\n                            addNoticePartial({ priority: 67, C: chapterNumberString, V: `${v}`, message: \"Verse appears to be left out\", location: CVlocation });\r\n                        else\r\n                            addNoticePartial({ priority: 867, C: chapterNumberString, V: `${v}`, message: \"Verse appears to be missing\", location: CVlocation });\r\n                    // Check for existing verses but missing text\r\n                    if (!discoveredVerseWithTextList.includes(v)) {\r\n                        // const firstVerseObject = result1.returnedJSON.chapters[chapterNumberString][v]['verseObjects'][0];\r\n                        // console.log(\"firstVerseObject\", JSON.stringify(firstVerseObject));\r\n                        addNoticePartial({ priority: 866, C: chapterNumberString, V: `${v}`, message: \"Verse seems to have no text\", location: CVlocation });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        addSuccessMessage(`Checked CV patterns for ${bookID}${CVlocation}`);\r\n    }\r\n    // end of CVCheck function\r\n\r\n\r\n    /**\r\n    * @description - checks the given text field and processes the returned results\r\n    * @param {number} lineNumber -- 1-based integer\r\n    * @param {String} C - chapter number of the text being checked\r\n    * @param {String} V - verse number of the text being checked\r\n    * @param {String} fieldType - If 'USFM', fieldName will be the line marker, and fieldText will be the line text; If 'raw', fieldName will be 'from {marker}' and fieldText will have internal USFM markers removed\r\n    * @param {String} fieldName - name of the field being checked\r\n    * @param {String} fieldText - the actual text of the field being checked\r\n    * @param {boolean} allowedLinks - true if links are allowed in the field, otherwise false\r\n    * @param {String} fieldLocation - description of where the field is located\r\n    * @param {Object} checkingOptions - parameters that might affect the check\r\n    */\r\n    function ourCheckTextField(lineNumber, C, V, fieldType, fieldName, fieldText, allowedLinks, fieldLocation, checkingOptions) {\r\n        // Does basic checks for small errors like leading/trailing spaces, etc.\r\n\r\n        // We assume that checking for compulsory fields is done elsewhere\r\n\r\n        // Updates the global list of notices\r\n        // console.log(`cUSFM ourCheckTextField(${lineNumber}, ${C}:${V}, ${fieldName}, (${fieldText.length} chars), ${allowedLinks}, ${fieldLocation}, ${JSON.stringify(checkingOptions)})`);\r\n        console.assert(lineNumber !== undefined, \"cUSFM ourCheckTextField: 'lineNumber' parameter should be defined\");\r\n        console.assert(typeof lineNumber === 'number', `cUSFM ourCheckTextField: 'lineNumber' parameter should be a number not a '${typeof lineNumber}'`);\r\n        console.assert(C !== undefined, \"cUSFM ourCheckTextField: 'C' parameter should be defined\");\r\n        console.assert(typeof C === 'string', `cUSFM ourCheckTextField: 'C' parameter should be a string not a '${typeof C}'`);\r\n        console.assert(V !== undefined, \"cUSFM ourCheckTextField: 'V' parameter should be defined\");\r\n        console.assert(typeof V === 'string', `cUSFM ourCheckTextField: 'V' parameter should be a string not a '${typeof V}'`);\r\n        console.assert(fieldType !== undefined, \"cUSFM ourCheckTextField: 'fieldType' parameter should be defined\");\r\n        console.assert(typeof fieldType === 'string', `cUSFM ourCheckTextField: 'fieldType' parameter should be a string not a '${typeof fieldType}'`);\r\n        console.assert(fieldType === 'USFM' || fieldType === 'raw', `cUSFM ourCheckTextField: Unrecognized 'fieldType' parameter: ${fieldType}`);\r\n        console.assert(fieldName !== undefined, \"cUSFM ourCheckTextField: 'fieldName' parameter should be defined\");\r\n        console.assert(typeof fieldName === 'string', `cUSFM ourCheckTextField: 'fieldName' parameter should be a string not a '${typeof fieldName}'`);\r\n        console.assert(fieldName !== '', `cUSFM ourCheckTextField: ${fieldType} 'fieldName' parameter should be not be an empty string`);\r\n        console.assert(fieldText !== undefined, \"cUSFM ourCheckTextField: 'fieldText' parameter should be defined\");\r\n        console.assert(typeof fieldText === 'string', `cUSFM ourCheckTextField: 'fieldText' parameter should be a string not a '${typeof fieldText}'`);\r\n        console.assert(allowedLinks === true || allowedLinks === false, \"cUSFM ourCheckTextField: allowedLinks parameter must be either true or false\");\r\n        console.assert(fieldLocation !== undefined, \"cUSFM ourCheckTextField: 'fieldLocation' parameter should be defined\");\r\n        console.assert(typeof fieldLocation === 'string', `cUSFM ourCheckTextField: 'fieldLocation' parameter should be a string not a '${typeof fieldLocation}'`);\r\n\r\n        const dbtcResultObject = checkTextField(fieldType, fieldName, fieldText, allowedLinks, fieldLocation, checkingOptions);\r\n\r\n        // Process noticeList line by line to filter out potential false positives\r\n        //  for this particular kind of text field\r\n        for (const noticeEntry of dbtcResultObject.noticeList) {\r\n            // console.log(\"Notice keys\", JSON.stringify(Object.keys(noticeEntry)));\r\n            console.assert(Object.keys(noticeEntry).length >= 4, `USFM ourCheckTextField notice length=${Object.keys(noticeEntry).length}`);\r\n            addNoticePartial({ ...noticeEntry, lineNumber, C, V });\r\n            // }\r\n        }\r\n    }\r\n    // end of ourCheckTextField function\r\n\r\n\r\n    function ourBasicFileChecks(filename, fileText, fileLocation, checkingOptions) {\r\n        // Does basic checks for small errors like leading/trailing spaces, etc.\r\n\r\n        // We assume that checking for compulsory fields is done elsewhere\r\n\r\n        // Updates the global list of notices\r\n        console.assert(filename !== undefined, \"cUSFM ourBasicFileChecks: 'filename' parameter should be defined\");\r\n        console.assert(typeof filename === 'string', `cUSFM ourBasicFileChecks: 'filename' parameter should be a string not a '${typeof filename}'`);\r\n        console.assert(fileText !== undefined, \"cUSFM ourBasicFileChecks: 'fileText' parameter should be defined\");\r\n        console.assert(typeof fileText === 'string', `cUSFM ourBasicFileChecks: 'fileText' parameter should be a string not a '${typeof fileText}'`);\r\n        console.assert(checkingOptions !== undefined, \"cUSFM ourBasicFileChecks: 'checkingOptions' parameter should be defined\");\r\n\r\n        const resultObject = checkTextfileContents(languageCode, 'USFM', filename, fileText, fileLocation, checkingOptions);\r\n\r\n        // If we need to put everything through addNoticePartial, e.g., for debugging or filtering\r\n        //  process results line by line\r\n        for (const noticeEntry of resultObject.noticeList) {\r\n            console.assert(Object.keys(noticeEntry).length >= 5, `USFM ourBasicFileChecks notice length=${Object.keys(noticeEntry).length}`);\r\n            addNoticePartial(noticeEntry);\r\n        }\r\n    }\r\n    // end of ourBasicFileChecks function\r\n\r\n\r\n    function checkUSFMCharacterFields(filename, fileText, fileLocation) {\r\n        // Check matched pairs\r\n        for (const punctSet of MATCHED_CHARACTER_FORMATTING_PAIRS) {\r\n            const opener = punctSet[0], closer = punctSet[1];\r\n            const lCount = countOccurrences(fileText, opener);\r\n            const rCount = countOccurrences(fileText, closer);\r\n            if (lCount !== rCount)\r\n                addNoticePartial({ priority: 873, message: `Mismatched ${opener}${closer} fields`, extract: `(left=${lCount.toLocaleString()}, right=${rCount.toLocaleString()})`, location: fileLocation });\r\n        }\r\n    }\r\n    // end of checkUSFMCharacterFields function\r\n\r\n\r\n    function checkUSFMFileContents(filename, fileText, markerSet, fileLocation, checkingOptions) {\r\n        // Does global checks on the file\r\n        // Note: These run the risk of duplicating messages that are found within individual lines.\r\n        //          However, its common in USFM for parentheses to open '(' in one verse\r\n        //                      and close ')' in another. So the USFM line check cant check that.\r\n        //          Also, the USFM v3.0 spec seems to allow/require whitespace reduction,\r\n        //              i.e., newLines can conceivably appear WITHIN a footnote for example.\r\n\r\n        // Check markers like \\add ... \\add*, \\f .. \\f*\r\n        checkUSFMCharacterFields(filename, fileText, fileLocation)\r\n\r\n        // Now do the general global checks (e.g., for general punctuation)\r\n        ourBasicFileChecks(filename, fileText, fileLocation, checkingOptions);\r\n\r\n        for (const compulsoryMarker of COMPULSORY_MARKERS)\r\n            if (!markerSet.has(compulsoryMarker))\r\n                addNoticePartial({ priority: 819, message: \"Missing compulsory USFM line\", extract: `missing \\\\${compulsoryMarker}`, location: fileLocation });\r\n        for (const expectedMarker of EXPECTED_MARKERS)\r\n            if (!markerSet.has(expectedMarker)\r\n                && (!expectedMarker.endsWith('1') || !markerSet.has(expectedMarker.substring(0, expectedMarker.length - 1))))\r\n                addNoticePartial({ priority: 519, message: \"Missing expected USFM line\", extract: `missing \\\\${expectedMarker}`, location: fileLocation });\r\n        if (books.isExtraBookID(bookID))\r\n            for (const expectedMarker of EXPECTED_PERIPHERAL_BOOK_MARKERS)\r\n                if (!markerSet.has(expectedMarker))\r\n                    addNoticePartial({ priority: 517, message: \"Missing expected USFM line\", extract: `missing \\\\${expectedMarker}`, location: fileLocation });\r\n                else\r\n                    for (const expectedMarker of EXPECTED_BIBLE_BOOK_MARKERS)\r\n                        if (!markerSet.has(expectedMarker))\r\n                            addNoticePartial({ priority: 518, message: \"Missing expected USFM line\", extract: `missing \\\\${expectedMarker}`, location: fileLocation });\r\n        for (const deprecatedMarker of DEPRECATED_MARKERS)\r\n            if (markerSet.has(deprecatedMarker))\r\n                addNoticePartial({ priority: 218, message: \"Using deprecated USFM marker\", extract: `\\\\${deprecatedMarker}`, location: fileLocation });\r\n    }\r\n    // end of checkUSFMFileContents function\r\n\r\n\r\n    function checkUSFMLineText(lineNumber, C, V, marker, rest, lineLocation, checkingOptions) {\r\n        // Removes character formatting within the line contents and checks the remaining text\r\n        // console.log(`checkUSFMLineText(${lineNumber}, ${C}:${V}, ${marker}='${rest}', ${lineLocation}, ${JSON.stringify(checkingOptions)})`);\r\n        // console.log(`checkUSFMLineText(${lineNumber}, ${C}:${V}, ${marker}=${rest.length} chars, ${lineLocation}, ${JSON.stringify(checkingOptions)})`);\r\n\r\n        const details = `(line marker=\\\\${marker})`\r\n\r\n        // Remove any self-closed milestones and internal \\v markers\r\n        // NOTE: replaceAll() is not generally available in browsers yet, so need to use RegExps\r\n        let adjustedRest = rest.replace(/\\\\zaln-e\\\\\\*/g, '').replace(/\\\\ts\\\\\\*/g, '').replace(/\\\\k-e\\\\\\*/g, '')\r\n            .replace(/\\\\v /g, '')\r\n            .replace(/\\\\k-s[^\\\\]+\\\\\\*/g, ''); // This last one is a genuine RegExp because it includes the field contents\r\n\r\n        // Remove any simple character markers\r\n        // NOTE: replaceAll() is not generally available in browsers yet, so need to use RegExps\r\n        for (const charMarker of SIMPLE_INTERNAL_MARKERS) {\r\n            // oldTODO: Move the regEx creation so its only done once -- not for every line!!!\r\n            // const startRegex = new RegExp(`\\\\${charMarker} `, 'g');\r\n            // // eslint-disable-next-line no-useless-escape\r\n            // const endRegex = new RegExp(`\\\\${charMarker}\\*`, 'g');\r\n            // adjustedRest = adjustedRest.replace(startRegex, '').replace(endRegex, '');\r\n            adjustedRest = ourDeleteAll(adjustedRest, `\\\\${charMarker} `);\r\n            adjustedRest = ourDeleteAll(adjustedRest, `\\\\${charMarker}*`);\r\n        }\r\n        // if (adjustedRest !== rest) {console.log(`Still Got \\n'${adjustedRest}' from \\n'${rest}'`); return;}\r\n\r\n\r\n        let ixEnd;\r\n        if (marker === 'w') { // Handle first \\w field (i.e., if marker==w) -- there may be more \\w fields in rest\r\n            const ixWordEnd = adjustedRest.indexOf('|');\r\n            if (ixWordEnd < 0 && adjustedRest.indexOf('lemma=\"') >= 0) {\r\n                const characterIndex = 5; // Presumably, a little bit into the word\r\n                const extract = (characterIndex > halfLength ? '' : '') + adjustedRest.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/ /g, '') + (characterIndex + halfLengthPlus < adjustedRest.length ? '' : '')\r\n                addNoticePartial({ priority: 912, message: 'Missing | character in \\\\w line', lineNumber, C, V, characterIndex, extract, location: lineLocation });\r\n            }\r\n            console.assert(ixWordEnd >= 1, `Why1 is w| = ${ixWordEnd}? ${languageCode} ${bookID} ${C}:${V} ${lineNumber} '\\\\${marker}'`);\r\n            ixEnd = adjustedRest.indexOf('\\\\w*');\r\n            if (ixEnd >= 0)\r\n                adjustedRest = adjustedRest.substring(0, ixWordEnd) + adjustedRest.substring(ixEnd + 3, adjustedRest.length);\r\n            else console.assert(false, `Why is ixEnd = ${ixEnd}? ${languageCode} ${bookID} ${C}:${V} ${lineNumber} '\\\\${marker}'`);\r\n        } else if (marker === 'zaln-s') { // Remove first \\zaln-s milestone (if marker == zaln-s)\r\n            ixEnd = adjustedRest.indexOf('\\\\*');\r\n            if (ixEnd >= 0)\r\n                adjustedRest = adjustedRest.substring(ixEnd + 2, adjustedRest.length);\r\n            else console.assert(false, `Why is ixEnd = ${ixEnd}? ${languageCode} ${bookID} ${C}:${V} ${lineNumber} '\\\\${marker}'`);\r\n        } else if (marker === 'k-s') { // Remove first \\k-s milestone (if marker == k-s)\r\n            ixEnd = adjustedRest.indexOf('\\\\*');\r\n            if (ixEnd >= 0)\r\n                adjustedRest = adjustedRest.substring(ixEnd + 2, adjustedRest.length);\r\n            else console.assert(false, `Why is ixEnd = ${ixEnd}? ${languageCode} ${bookID} ${C}:${V} ${lineNumber} '\\\\${marker}'`);\r\n        } else if (marker === 'f') { // Handle first footnote (if marker == f)\r\n            ixEnd = adjustedRest.indexOf('\\\\f*');\r\n            const startIndex = adjustedRest.startsWith('+ ') ? 2 : 0;\r\n            if (ixEnd >= 0)\r\n                adjustedRest = adjustedRest.substring(startIndex, ixEnd) + adjustedRest.substring(ixEnd + 3, adjustedRest.length);\r\n            else {\r\n                // console.assert(false, `Why is ixEnd = ${ixEnd}? ${languageCode} ${bookID} ${C}:${V} ${lineNumber} '\\\\${marker}'`);\r\n                addNoticePartial({ priority: 312, message: 'Possible unclosed footnote', details, lineNumber, C, V, location: lineLocation });\r\n            }\r\n            // console.log(`After removing f field: '${adjustedRest}' from '${rest}'`);\r\n        }\r\n        else if (marker === 'va')\r\n            adjustedRest = adjustedRest.replace('\\\\va*', '');\r\n        else if (marker === 'ca')\r\n            adjustedRest = adjustedRest.replace('\\\\ca*', '');\r\n\r\n        // Remove any other \\zaln-s fields in the line\r\n        // if (adjustedRest.indexOf('\\\\z') >= 0) console.log(`checkUSFMLineText here first at ${lineNumber} ${C}:${V} with ${marker}='${adjustedRest}'`);\r\n        let nextZIndex;\r\n        while ((nextZIndex = adjustedRest.indexOf('\\\\zaln-s ')) >= 0) {\r\n            // console.log(`checkUSFMLineText here with ${marker}='${adjustedRest}'`);\r\n            const ixZEnd = adjustedRest.indexOf('\\\\*');\r\n            // console.log(`  ${nextZIndex} and ${ixZEnd}`);\r\n            if (ixZEnd >= 0) {\r\n                // console.assert(ixZEnd > nextZIndex, `Exected closure at ${ixZEnd} to be AFTER \\\\zaln-s (${nextZIndex})`);\r\n                adjustedRest = adjustedRest.substring(0, nextZIndex) + adjustedRest.substring(ixZEnd + 2, adjustedRest.length);\r\n                // console.log(`  Now '${adjustedRest}'`);\r\n            } else {\r\n                console.log(`\\\\zaln-s seems unclosed: 'adjustedRest' from '${rest}'`);\r\n                break;\r\n            }\r\n        }\r\n        // Remove any other \\w fields in the line\r\n        let nextWIndex;\r\n        while ((nextWIndex = adjustedRest.indexOf('\\\\w ')) >= 0) {\r\n            const ixWordEnd = adjustedRest.indexOf('|');\r\n            if (ixWordEnd < 0 && adjustedRest.indexOf('lemma=\"') >= 0) {\r\n                const characterIndex = nextWIndex + 5; // Presumably, a little bit into the word\r\n                const extract = (characterIndex > halfLength ? '' : '') + adjustedRest.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/ /g, '') + (characterIndex + halfLengthPlus < adjustedRest.length ? '' : '')\r\n                addNoticePartial({ priority: 911, message: 'Missing | character in \\\\w field', details, lineNumber, C, V, characterIndex, extract, location: lineLocation });\r\n                adjustedRest = ''; // Avoid follow-on errors\r\n                break;\r\n            }\r\n            console.assert(ixWordEnd > nextWIndex + 3, `Why2 is w| = ${ixWordEnd}? nextWIndex=${nextWIndex} ${languageCode} ${bookID} ${C}:${V} ${lineNumber}`);\r\n            const ixWEnd = adjustedRest.indexOf('\\\\w*');\r\n            if (ixWEnd >= 0) {\r\n                console.assert(ixWEnd > nextWIndex, `Exected closure at ${ixWEnd} to be AFTER \\\\w (${nextWIndex})`);\r\n                adjustedRest = adjustedRest.substring(0, nextWIndex) + adjustedRest.substring(nextWIndex + 3, ixWordEnd) + adjustedRest.substring(ixWEnd + 3, adjustedRest.length);\r\n                // console.log(`After removing w field, got '${adjustedRest}'`);\r\n            } else {\r\n                console.log(`\\\\w seems unclosed: 'adjustedRest' from '${rest}'`);\r\n                break;\r\n            }\r\n        }\r\n        // Remove any other \\f fields in the line\r\n        let nextFIndex;\r\n        while ((nextFIndex = adjustedRest.indexOf('\\\\f + ')) >= 0) {\r\n            const ixFEnd = adjustedRest.indexOf('\\\\f*');\r\n            if (ixFEnd >= 0) {\r\n                console.assert(ixFEnd > nextWIndex, `Exected closure at ${ixFEnd} to be AFTER \\\\w (${nextFIndex})`);\r\n                adjustedRest = adjustedRest.substring(0, nextFIndex) + adjustedRest.substring(nextFIndex + 5, ixFEnd) + adjustedRest.substring(ixFEnd + 3, adjustedRest.length);\r\n                // console.log(`checkUSFMLineText(${lineNumber}, ${C}:${V}, ${marker}='${rest}', ${lineLocation}, ${JSON.stringify(checkingOptions)})`);\r\n                // console.log(`After removing footnote: '${adjustedRest}'`);\r\n            } else {\r\n                console.log(`\\\\f seems unclosed: 'adjustedRest' from '${rest}'`);\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (adjustedRest) {\r\n            let characterIndex;\r\n            if ((characterIndex = adjustedRest.indexOf('\"')) >= 0) {\r\n                const extract = (characterIndex > halfLength ? '' : '') + adjustedRest.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/ /g, '') + (characterIndex + halfLengthPlus < adjustedRest.length ? '' : '')\r\n                addNoticePartial({ priority: 776, message: 'Unexpected \" straight quote character', details, lineNumber, C, V, extract, location: lineLocation });\r\n                // console.log(`ERROR 776: in ${marker} '${adjustedRest}' from '${rest}'`);\r\n            }\r\n            if ((characterIndex = adjustedRest.indexOf(\"'\")) >= 0) {\r\n                const extract = (characterIndex > halfLength ? '' : '') + adjustedRest.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/ /g, '') + (characterIndex + halfLengthPlus < adjustedRest.length ? '' : '')\r\n                addNoticePartial({ priority: 775, message: \"Unexpected ' straight quote character\", details, lineNumber, C, V, extract, location: lineLocation });\r\n                // console.log(`ERROR 775: in ${marker} '${adjustedRest}' from '${rest}'`);\r\n            }\r\n            if (adjustedRest.indexOf('\\\\') >= 0 || adjustedRest.indexOf('|') >= 0) {\r\n                // console.log(`checkUSFMLineText ${languageCode} ${filename} ${lineNumber} ${C}:${V} somehow ended up with ${marker}='${adjustedRest}'`);\r\n                characterIndex = adjustedRest.indexOf('\\\\');\r\n                if (characterIndex === -1) characterIndex = adjustedRest.indexOf('|');\r\n                const extract = (characterIndex > halfLength ? '' : '') + adjustedRest.substring(characterIndex - halfLength, characterIndex + halfLengthPlus).replace(/ /g, '') + (characterIndex + halfLengthPlus < adjustedRest.length ? '' : '')\r\n                addNoticePartial({ priority: 875, message: \"Unexpected USFM field\", details, lineNumber, C, V, extract, location: lineLocation });\r\n            }\r\n            if (adjustedRest !== rest) // Only re-check if line has changed (because original is checked in checkUSFMLineInternals())\r\n                // Note: false (below) is for allowedLinks flag\r\n                ourCheckTextField(lineNumber, C, V, 'raw', `from \\\\${marker}`, adjustedRest, false, lineLocation, checkingOptions);\r\n        }\r\n    }\r\n    // end of checkUSFMLineText function\r\n\r\n\r\n    function checkUSFMLineContents(lineNumber, C, V, marker, rest, lineLocation, checkingOptions) {\r\n        // Looks at the marker and determines what content is allowed/expected on the rest of the line\r\n        // 'SPECIAL1' is used internally here when a character other than a backslash starts a line\r\n\r\n        function checkUSFMLineInternals(lineNumber, C, V, marker, rest, lineLocation, checkingOptions) {\r\n            // Handles character formatting within the line contents\r\n            // console.log(`checkUSFMLineInternals(${lineNumber}, ${C}:${V}, ${marker}='${rest}', ${lineLocation}, ${JSON.stringify(checkingOptions)})`);\r\n\r\n            if (marker === 'c' && isNaN(rest))\r\n                addNoticePartial({ priority: 822, message: \"Expected field to contain an integer\", lineNumber, characterIndex: 3, extract: `\\\\c ${rest}`, C, V, location: lineLocation });\r\n            if (marker === 'v') {\r\n                let Vstr = (rest) ? rest.split(' ', 1)[0] : '?';\r\n                if (isNaN(Vstr) && Vstr.indexOf('-') < 0)\r\n                    addNoticePartial({ priority: 822, message: \"Expected field to contain an integer\", characterIndex: 3, extract: `\\\\v ${rest}`, C, V, location: lineLocation });\r\n            }\r\n            else if (marker === 'h' || marker === 'toc1' || marker === 'toc2' || marker === 'toc3')\r\n                if (rest.toLowerCase() === rest || rest.toUpperCase() === rest)\r\n                    addNoticePartial({ priority: languageCode === 'en' || languageCode === 'fr' ? 490 : 190, message: \"Expected header field to contain a mixed-case string\", fieldName: `\\\\${marker}`, extract: rest, C, V, location: lineLocation });\r\n\r\n            if (rest) checkUSFMLineText(lineNumber, C, V, marker, rest, lineLocation, checkingOptions);\r\n\r\n            const allowedLinks = (marker === 'w' || marker === 'k-s' || marker === 'f' || marker === 'SPECIAL1')\r\n                // (because we dont know what marker SPECIAL1 is, so default to \"no false alarms\")\r\n                && rest.indexOf('x-tw') >= 0;\r\n            if (rest) ourCheckTextField(lineNumber, C, V, 'USFM', `\\\\${marker}`, rest, allowedLinks, lineLocation, checkingOptions);\r\n        }\r\n        // end of checkUSFMLineInternals function\r\n\r\n\r\n        // Main code for checkUSFMLineContents()\r\n        if (ALLOWED_LINE_START_MARKERS.indexOf(marker) >= 0 || marker === 'SPECIAL1') {\r\n            if (rest && MARKERS_WITHOUT_CONTENT.indexOf(marker) >= 0)\r\n                if (isWhitespace(rest))\r\n                    addNoticePartial({ priority: 301, message: `Unexpected whitespace after \\\\${marker} marker`, C, V, lineNumber, characterIndex: marker.length, extract: rest, location: lineLocation });\r\n                else if (rest !== '' && rest !== '') // in UHB NEH 3:20 or EZR 3:18\r\n                    addNoticePartial({ priority: 401, message: `Unexpected content after \\\\${marker} marker`, C, V, lineNumber, characterIndex: marker.length, extract: rest, location: lineLocation });\r\n                else if (MARKERS_WITH_COMPULSORY_CONTENT.indexOf(marker) >= 0 && !rest)\r\n                    addNoticePartial({ priority: 711, message: \"Expected compulsory content\", C, V, lineNumber, characterIndex: marker.length, location: ` after \\\\${marker} marker${lineLocation}` });\r\n        } else // its not a recognised line marker\r\n            // Lower priority of deprecated \\s5 markers (compared to all other unknown markers)\r\n            addNoticePartial({ priority: marker === 's5' ? 111 : 809, message: `${marker === 's5' ? 'Deprecated' : 'Unexpected'} '\\\\${marker}' marker at start of line`, C, V, lineNumber, characterIndex: 1, location: lineLocation });\r\n        if (rest) checkUSFMLineInternals(lineNumber, C, V, marker, rest, lineLocation, checkingOptions);\r\n    }\r\n    // end of checkUSFMLineContents function\r\n\r\n\r\n    function mainUSFMCheck(bookID, filename, givenText, location) {\r\n        // console.log(\"Running mainUSFMCheck() (can take quite a while for a large book)\");\r\n\r\n        let ourLocation = location;\r\n        if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n        // const lowercaseBookID = bookID.toLowerCase();\r\n        // eslint-disable-next-line no-unused-vars\r\n        let numChaptersThisBook = 0;\r\n        try {\r\n            console.assert(lowercaseBookID !== 'obs', \"Shouldnt happen in usfm-text-check2\");\r\n            numChaptersThisBook = books.chaptersInBook(lowercaseBookID).length;\r\n        }\r\n        catch {\r\n            if (!books.isValidBookID(bookID)) // must not be in FRT, BAK, etc.\r\n                addNoticePartial({ priority: 903, message: \"Bad function call: should be given a valid book abbreviation\", extract: bookID, location: ` (not '${bookID}')${ourLocation}` });\r\n        }\r\n\r\n        function findStartMarker(C, V, lineNumber, USFMline) {\r\n            // Returns the USFM marker at the start of the line\r\n            //  (without the leading backslash but including full self-closing milestones)\r\n            console.assert(USFMline && USFMline[0] === '\\\\', `Programming error in findStartMarker(${C}:${V}, ${lineNumber}, ${USFMline})`);\r\n            let foundMarker = '';\r\n            for (let characterIndex = 1; characterIndex < USFMline.length; characterIndex++) {\r\n                const char = USFMline[characterIndex];\r\n                if (char === ' ') break;\r\n                // Cope with self-closing milestones like \\k-s\\*\r\n                if (char === '\\\\' && (characterIndex === USFMline.length - 1 || USFMline[characterIndex + 1] !== '*')) {\r\n                    const extract = USFMline.substring(0, extractLength) + (USFMline.length > extractLength ? '' : '');\r\n                    addNoticePartial({ priority: 603, message: \"USFM marker doesnt end with space\", C, V, lineNumber, characterIndex, extract, location: ourLocation });\r\n                    break;\r\n                }\r\n                foundMarker += char;\r\n                if (char === '*') break;\r\n            }\r\n            return foundMarker;\r\n        }\r\n\r\n        let lines = givenText.split('\\n');\r\n        // console.log(`  '${ourLocation}' has ${lines.length.toLocaleString()} total lines`);\r\n\r\n        // let lastB = '';\r\n        let lastC = '', lastV = '', C = '0', V = '0';\r\n        let lastIntC = 0, lastIntV = 0;\r\n        // let numVersesThisChapter = 0;\r\n        let lastMarker = '', lastRest = '';\r\n        const markerSet = new Set();\r\n        for (let n = 1; n <= lines.length; n++) {\r\n            let line = lines[n - 1];\r\n            if (C === '0') V = n.toString();\r\n            // console.log(`line '${line}'${atString}`);\r\n            if (!line) {\r\n                // addNoticePartial({priority:103, \"Unexpected blank line\", 0, '', location:ourLocation});\r\n                continue;\r\n            }\r\n            let characterIndex;\r\n            if ((characterIndex = line.indexOf('\\r')) >= 0) {\r\n                const iy = characterIndex + halfLength; // Want extract to focus more on what follows\r\n                const extract = (iy > halfLength ? '' : '') + line.substring(iy - halfLength, iy + halfLengthPlus).replace(/ /g, '') + (iy + halfLengthPlus < line.length ? '' : '')\r\n                addNoticePartial({ priority: 703, C, V, message: \"Unexpected CarriageReturn character\", lineNumber: n, characterIndex, extract, location: ourLocation });\r\n            }\r\n\r\n            let marker, rest;\r\n            if (line[0] === '\\\\') {\r\n                marker = findStartMarker(C, V, n, line);\r\n                rest = line.substring(marker.length + 2); // Skip backslash, marker, and space after marker\r\n                // console.log(`Line ${n}: marker='\\\\${marker}' rest='${rest}'`);\r\n            } else { // Line didnt start with a backslash\r\n                // NOTE: Some unfoldingWord USFM Bibles commonly have this\r\n                //          so its not necessarily either an error or a warning\r\n                rest = line;\r\n                if (validLineStartCharacters.indexOf(line[0]) < 0) { // These are the often expected characters\r\n                    // Drop the priority if its a \"half-likely\" character\r\n                    addNoticePartial({ priority: `\"`.indexOf(line[0]) < 0 ? 880 : 280, C, V, message: \"Expected line to start with backslash\", lineNumber: n, characterIndex: 0, extract: line[0], location: ourLocation });\r\n                    if (line[1] === '\\\\') { // Lets drop the leading punctuation and try to check the rest of the line\r\n                        marker = line.substring(2).split(' ', 1)[0];\r\n                        rest = line.substring(marker.length + 2 + 1); // Skip leading character, backslash, marker, and space after marker\r\n                        // console.log(`USFM after ${line[0]} got '\\\\${marker}': '${rest}'`);\r\n                    }\r\n                    else\r\n                        marker = 'rem'; // to try to avoid consequential errors, but the rest of the line wont be checked\r\n                } else { // How do we handle an allowed line that doesnt start with a backslash?\r\n                    // Cant use 'rem' because we want the rest of the line checked\r\n                    marker = 'SPECIAL1'; // Handle as a special case\r\n                }\r\n            }\r\n            markerSet.add(marker); // Keep track of all line markers\r\n\r\n            // Handle C/V numbers including verse bridges\r\n            let intC, intV, vIndex;\r\n            if (marker === 'c') {\r\n                C = rest; V = '0';\r\n                try {\r\n                    intC = ourParseInt(C);\r\n                } catch (usfmICerror) {\r\n                    addNoticePartial({ priority: 724, C, V, message: \"Unable to convert chapter number to integer\", lineNumber: n, characterIndex: 3, extract: `${rest.substring(0, halfLength)}${rest.length > halfLength ? '' : ''}`, location: ourLocation });\r\n                    intC = -999; // Used to prevent consequential errors\r\n                }\r\n                if (C === lastC || (intC > 0 && intC !== lastIntC + 1))\r\n                    addNoticePartial({ priority: 764, C, V, message: \"Chapter number didnt increment correctly\", lineNumber: n, characterIndex: 3, extract: `${rest.substring(0, halfLength)}${rest.length > halfLength ? '' : ''} (${lastC ? lastC : '0'}  ${C})`, location: ourLocation });\r\n                lastC = C; lastV = '0';\r\n                lastIntC = intC; lastIntV = 0;\r\n            } else if (marker === 'v') {\r\n                V = (rest) ? rest.split(' ', 1)[0] : '?';\r\n                if (V.indexOf('-') < 0) { // no hyphen -> no verse bridge\r\n                    try {\r\n                        intV = ourParseInt(V);\r\n                    } catch (usfmIVerror) {\r\n                        addNoticePartial({ priority: 723, C, V, message: \"Unable to convert verse number to integer\", lineNumber: n, characterIndex: 3, extract: `${rest.substring(0, halfLength)}${rest.length > halfLength ? '' : ''}`, location: ourLocation });\r\n                        intV = -999; // Used to prevent consequential errors\r\n                    }\r\n                    if (V === lastV || (intV > 0 && intV !== lastIntV + 1))\r\n                        addNoticePartial({ priority: 763, C, V, message: \"Verse number didnt increment correctly\", lineNumber: n, characterIndex: 3, extract: `${rest.substring(0, halfLength)}${rest.length > halfLength ? '' : ''} (${lastV ? lastV : '0'}  ${V})`, location: ourLocation });\r\n                    lastV = V; lastIntV = intV;\r\n                } else { // handle verse bridge\r\n                    const bits = V.split('-');\r\n                    const firstV = bits[0], secondV = bits[1];\r\n                    let intFirstV, intSecondV;\r\n                    try {\r\n                        intFirstV = ourParseInt(firstV);\r\n                        intSecondV = ourParseInt(secondV);\r\n                    } catch (usfmV12error) {\r\n                        addNoticePartial({ priority: 762, C, V, message: \"Unable to convert verse bridge numbers to integers\", lineNumber: n, characterIndex: 3, extract: `${rest.substring(0, Math.max(9, extractLength))}${rest.length > extractLength ? '' : ''}`, location: ourLocation });\r\n                        intFirstV = -999; intSecondV = -998; // Used to prevent consequential errors\r\n                    }\r\n                    if (intSecondV <= intFirstV)\r\n                        addNoticePartial({ priority: 769, C, V, message: \"Verse bridge numbers not in ascending order\", lineNumber: n, characterIndex: 3, extract: `${rest.substring(0, Math.max(9, extractLength))}${rest.length > extractLength ? '' : ''} (${firstV}  ${secondV})`, location: ourLocation });\r\n                    else if (firstV === lastV || (intFirstV > 0 && intFirstV !== lastIntV + 1))\r\n                        addNoticePartial({ priority: 766, C, V, message: \"Bridged verse numbers didnt increment correctly\", lineNumber: n, characterIndex: 3, extract: `${rest.substring(0, Math.max(9, extractLength))}${rest.length > extractLength ? '' : ''} (${lastV}  ${firstV})`, location: ourLocation });\r\n                    lastV = secondV; lastIntV = intSecondV;\r\n                }\r\n            } else if ((vIndex = rest.indexOf('\\\\v ')) >= 0) {\r\n                // verse number marker follows another marker on the same line, so its inside `rest`\r\n                const restRest = rest.substring(vIndex + 3);\r\n                // console.log(`Got restRest=${restRest}`);\r\n                try {\r\n                    intV = parseInt(restRest);\r\n                    // console.log(\"Got\", intV);\r\n                } catch (usfmIIVerror) {\r\n                    addNoticePartial({ priority: 720, C, V, message: \"Unable to convert internal verse number to integer\", lineNumber: n, characterIndex: 3, extract: `${restRest.substring(0, halfLength)}${restRest.length > halfLength ? '' : ''}`, location: ourLocation });\r\n                    intV = -999; // Used to prevent consequential errors\r\n                }\r\n                if (intV > 0 && intV !== lastIntV + 1)\r\n                    addNoticePartial({ priority: 761, C, V, message: \"Verse number didnt increment correctly\", lineNumber: n, characterIndex: 3, extract: `${restRest.substring(0, halfLength)}${restRest.length > halfLength ? '' : ''} (${lastV ? lastV : '0'}  ${V})`, location: ourLocation });\r\n                lastV = intV.toString(); lastIntV = intV;\r\n            }\r\n\r\n            if (marker === 'id' && !rest.startsWith(bookID)) {\r\n                const thisLength = Math.max(4, extractLength);\r\n                const extract = `${rest.substring(0, thisLength)}${rest.length > thisLength ? '' : ''}`;\r\n                addNoticePartial({ priority: 987, C, V, message: \"Expected \\\\id line to start with book identifier\", lineNumber: n, characterIndex: 4, extract, location: ourLocation });\r\n            }\r\n\r\n            // Check the order of markers\r\n            // In headers\r\n            if (marker === 'toc2' && lastMarker !== 'toc1')\r\n                addNoticePartial({ priority: 87, C, V, message: \"Expected \\\\toc2 line to follow \\\\toc1\", lineNumber: n, characterIndex: 1, details: `not '\\\\${lastMarker}'`, location: ourLocation });\r\n            else if (marker === 'toc3' && lastMarker !== 'toc2')\r\n                addNoticePartial({ priority: 87, C, V, message: \"Expected \\\\toc3 line to follow \\\\toc2\", lineNumber: n, characterIndex: 1, details: `not '\\\\${lastMarker}'`, location: ourLocation });\r\n            // In chapters\r\n            else if ((PARAGRAPH_MARKERS.indexOf(marker) >= 0 || marker === 's5' || marker === 'ts\\\\*')\r\n                && PARAGRAPH_MARKERS.indexOf(lastMarker) >= 0\r\n                && !lastRest)\r\n                addNoticePartial({ priority: 399, C, V, message: \"Useless paragraph marker\", lineNumber: n, characterIndex: 1, details: `'\\\\${lastMarker}' before '\\\\${marker}'`, location: ourLocation });\r\n            else if (['c', 'ca', 'cl'].indexOf(lastMarker) > 0 && marker === 'v')\r\n                addNoticePartial({ priority: C === '1' ? 657 : 457, C, V, message: \"Paragraph marker expected before first verse\", lineNumber: n, characterIndex: 1, details: `'\\\\${marker}' after '\\\\${lastMarker}'`, location: ourLocation });\r\n\r\n            // Do general checks\r\n            checkUSFMLineContents(n, C, V, marker, rest, ourLocation, checkingOptions);\r\n\r\n            lastMarker = marker; lastRest = rest;\r\n        }\r\n\r\n        // Do overall global checks of the entire text\r\n        checkUSFMFileContents(filename, givenText, markerSet, ourLocation, checkingOptions) // Do this last so the results are lower in the lists\r\n\r\n        addSuccessMessage(`Checked all ${lines.length.toLocaleString()} line${lines.length === 1 ? '' : 's'} for ${bookID}${ourLocation}`)\r\n    }\r\n    // end of mainUSFMCheck function\r\n\r\n\r\n    /* function runSlowTask(which) {\r\n        // Ideally these should be run in parallel using multiprocessing\r\n        //  See https://hackernoon.com/multithreading-multiprocessing-and-the-nodejs-event-loop-5b2929bd450b\r\n        console.log(`runSlowTask(${which})`)\r\n        return (which === 1)\r\n            ? mainUSFMCheck(bookID, filename, givenText, location)\r\n            : runBCSGrammarCheck(filename, givenText, location);\r\n    } */\r\n\r\n\r\n    // Main code for checkUSFMText()\r\n    // console.log(\"Starting USFM checking tasks\");\r\n    /*\r\n    const tasks = [1,2].map(runSlowTask);\r\n    const allResults = await Promise.all(tasks);\r\n    console.log(`  Finished all tasks with ${JSON.stringify(allResults)}.`);\r\n    console.log(\"  Finished all tasks.\");\r\n    if (!allResults[1].isValidUSFM)\r\n        addNoticePartial({priority: 942, \"USFM Grammar check fails\", location});\r\n    console.log(\"  Warnings:\", JSON.stringify(allResults[1].warnings));\r\n    // Display these warnings but with a lower priority\r\n    for (const warningString of allResults[1].warnings)\r\n        addNoticePartial({priority:103, `USFMGrammar: ${warningString.trim()}`, location});\r\n    */\r\n\r\n    // NOTE: If we're careful about how/when we add their notices to our global list,\r\n    //  we should be able to run these three slowish checks in parallel on different threads/processes\r\n    let allResults = [];\r\n    allResults.push(mainUSFMCheck(bookID, filename, givenText, ourLocation));\r\n    allResults.push(CVCheck(bookID, givenText, ourLocation));\r\n    if (!books.isExtraBookID(bookID))\r\n        allResults.push(ourRunBCSGrammarCheck(filename, givenText, ourLocation));\r\n    // console.assert(allResults.length === 2);\r\n    // console.log(\"allResults\", JSON.stringify(allResults));\r\n    // if (!allResults[1].isValidUSFM)\r\n    //     addNoticePartial({priority: 941, \"USFM Grammar check fails\", location});\r\n    // console.log(\"  Warnings:\", JSON.stringify(allResults[1].warnings));\r\n    // // Display these warnings but with a lower priority\r\n    // for (const warningString of allResults[1].warnings)\r\n    // addNoticePartial({priority:103, `USFMGrammar: ${warningString.trim()}`, location});\r\n\r\n    if (!checkingOptions?.suppressNoticeDisablingFlag) {\r\n        // console.log(`checkUSFMText: calling removeDisabledNotices(${result.noticeList.length}) having ${JSON.stringify(checkingOptions)}`);\r\n        result.noticeList = removeDisabledNotices(result.noticeList);\r\n    }\r\n\r\n    // console.log(`  checkUSFMText returning with ${result.successList.length.toLocaleString()} success(es) and ${result.noticeList.length.toLocaleString()} notice(s).`);\r\n    // console.log(`checkUSFMText result is ${JSON.stringify(result)}`);\r\n    return result;\r\n}\r\n// end of checkUSFMText function\r\n","import { toJSON } from 'usfm-js';\r\nimport * as books from '../core/books/books';\r\n\r\n\r\nexport function runUsfmJsCheck(fileText, convertOptions) {\r\n    // Runs the USFM-JS converter as a check\r\n    //  which can be quite time-consuming on large, complex USFM files\r\n    // console.log(\"Running USFM-JS converter check (can take quite a while for a large book)\");\r\n\r\n    const jsonResult = toJSON(fileText, convertOptions);\r\n    const jsonKeys = Object.keys(jsonResult); // Expect 'headers', 'chapters'\r\n    const numJSONkeys = jsonKeys.length;\r\n    // console.log(`  Finished USFM-JS converter check with ${numJSONkeys} json key(s)`);\r\n    // console.log(`  jsonResult: ${JSON.stringify(jsonResult)}`)\r\n    // NOTE: We dont know how to get the errors out yet\r\n\r\n    return { isValidUSFM: numJSONkeys >= 2, returnedJSON: jsonResult }; // Expect 'headers', 'chapters'\r\n}\r\n// end of runUsfmJsCheck function\r\n\r\n\r\nexport function checkUSFMToJSON(bookID, filename, givenText, givenLocation, checkingOptions) {\r\n    /*\r\n    This function is only used for the demonstration pages -- not for the core!\r\n\r\n    bookID is a three-character UPPERCASE USFM book identifier.\r\n\r\n        filename parameter can be an empty string if we dont have one.\r\n\r\n     Returns a result object containing a successList and a noticeList\r\n     */\r\n    // console.log(`checkUSFMToJSON(${givenText.length.toLocaleString()} chars, '${givenLocation}')`);\r\n    console.assert(bookID !== undefined, \"checkUSFMToJSON: 'bookID' parameter should be defined\");\r\n    console.assert(typeof bookID === 'string', `checkUSFMToJSON: 'bookID' parameter should be a string not a '${typeof bookID}': ${bookID}`);\r\n    console.assert(bookID.length === 3, `checkUSFMToJSON: 'bookID' parameter should be three characters long not ${bookID.length}`);\r\n    console.assert(bookID.toUpperCase() === bookID, `checkUSFMToJSON: 'bookID' parameter should be UPPERCASE not '${bookID}'`);\r\n    console.assert(books.isValidBookID(bookID), `checkUSFMToJSON: '${bookID}' is not a valid USFM book identifier`);\r\n    console.assert(filename !== undefined, \"checkUSFMToJSON: 'filename' parameter should be defined\");\r\n    console.assert(typeof filename === 'string', `checkUSFMToJSON: 'filename' parameter should be a string not a '${typeof filename}': ${filename}`);\r\n    console.assert(givenText !== undefined, \"checkUSFMToJSON: 'givenText' parameter should be defined\");\r\n    console.assert(typeof givenText === 'string', `checkUSFMToJSON: 'givenText' parameter should be a string not a '${typeof givenText}': ${givenText}`);\r\n    console.assert(givenLocation !== undefined, \"checkUSFMToJSON: 'givenRowLocation' parameter should be defined\");\r\n    console.assert(typeof givenLocation === 'string', `checkUSFMToJSON: 'givenRowLocation' parameter should be a string not a '${typeof givenLocation}'`);\r\n\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n    // if (filename) ourLocation = ` in ${filename}${ourLocation}`;\r\n\r\n\r\n    const result = { successList: [], noticeList: [] };\r\n\r\n    function addSuccessMessage(successString) {\r\n        // console.log(`checkUSFMToJSON success: ${successString}`);\r\n        result.successList.push(successString);\r\n    }\r\n    function addNotice6to7({ priority, message, lineNumber, characterIndex, extract, location }) {\r\n        /**\r\n        * @description - adds a new notice entry, adding bookID,C,V to the given fields\r\n        * @param {Number} priority - notice priority from 1 (lowest) to 999 (highest)\r\n        * @param {String} message - the text of the notice message\r\n        * @param {Number} characterIndex - where the issue occurs in the line\r\n        * @param {String} extract - short extract from the line centred on the problem (if available)\r\n        * @param {String} location - description of where the issue is located\r\n        */\r\n        // console.log(`checkUSFMToJSON notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : \"\"}${extract ? ` ${extract}` : \"\"}${location}`);\r\n        console.assert(priority !== undefined, \"cUSFMjs addNotice6to7: 'priority' parameter should be defined\");\r\n        console.assert(typeof priority === 'number', `cUSFMjs addNotice6to7: 'priority' parameter should be a number not a '${typeof priority}': ${priority}`);\r\n        console.assert(message !== undefined, \"cUSFMjs addNotice6to7: 'message' parameter should be defined\");\r\n        console.assert(typeof message === 'string', `cUSFMjs addNotice6to7: 'message' parameter should be a string not a '${typeof message}': ${message}`);\r\n        // console.assert(characterIndex !== undefined, \"cUSFMjs addNotice6to7: 'characterIndex' parameter should be defined\");\r\n        if (characterIndex) console.assert(typeof characterIndex === 'number', `cUSFMjs addNotice6to7: 'characterIndex' parameter should be a number not a '${typeof characterIndex}': ${characterIndex}`);\r\n        // console.assert(extract !== undefined, \"cUSFMjs addNotice6to7: 'extract' parameter should be defined\");\r\n        if (extract) console.assert(typeof extract === 'string', `cUSFMjs addNotice6to7: 'extract' parameter should be a string not a '${typeof extract}': ${extract}`);\r\n        console.assert(location !== undefined, \"cUSFMjs addNotice6to7: 'location' parameter should be defined\");\r\n        console.assert(typeof location === 'string', `cUSFMjs addNotice6to7: 'location' parameter should be a string not a '${typeof location}': ${location}`);\r\n        result.noticeList.push({ priority, message, bookID, lineNumber, characterIndex, extract, location });\r\n    }\r\n\r\n\r\n    // Set your options here -- change values or comment out lines\r\n    const convertOptions = {\r\n        'chunk': true,\r\n        'content-source': ourLocation,\r\n        'convertToInt': []\r\n    };\r\n    const convertCheckResult = runUsfmJsCheck(givenText, ourLocation, convertOptions);\r\n    // NOTE: We havent figured out how to get ERRORS out of this parser yet\r\n\r\n    if (!convertCheckResult.isValidUSFM)\r\n        addNotice6to7({ priority: 943, message: `USFM3 toJSON Check doesnt pass`, location: ourLocation });\r\n\r\n    addSuccessMessage(`Checked USFM-JS`);\r\n    // console.log(`  checkUSFMToJSON returning with ${result.successList.length.toLocaleString()} success(es) and ${result.noticeList.length.toLocaleString()} notice(s).`);\r\n    // console.log(`checkUSFMToJSON result is ${JSON.stringify(result)}`);\r\n    return result;\r\n}\r\n// end of checkUSFMToJSON function\r\n","import grammar from 'usfm-grammar';\r\nimport * as books from '../core/books/books';\r\nimport { DEFAULT_EXTRACT_LENGTH } from './text-handling-functions'\r\n\r\n\r\n// const USFM_GRAMMAR_VALIDATOR_VERSION_STRING = '0.3.2';\r\n\r\n\r\nexport function runBCSGrammarCheck(strictnessString, fileText, filename, givenLocation, checkingOptions) {\r\n    // Runs the BCS USFM Grammar checker\r\n    //  which can be quite time-consuming on large, complex USFM files\r\n    // console.log(`Running ${strictnessString} BCS USFM grammar check${givenLocation} (can take quite a while for a large book)`);\r\n    console.assert(strictnessString === 'strict' || strictnessString === 'relaxed', `Unexpected strictnessString='${strictnessString}'`);\r\n\r\n    let extractLength;\r\n    try {\r\n        extractLength = checkingOptions?.extractLength;\r\n    } catch (usfmELerror) { }\r\n    if (typeof extractLength !== 'number' || isNaN(extractLength)) {\r\n        extractLength = DEFAULT_EXTRACT_LENGTH;\r\n        // console.log(`Using default extractLength=${extractLength}`);\r\n    }\r\n    // else\r\n    // console.log(`Using supplied extractLength=${extractLength} cf. default=${DEFAULT_EXTRACT_LENGTH}`);\r\n    const halfLength = Math.floor(extractLength / 2); // rounded down\r\n    const halfLengthPlus = Math.floor((extractLength + 1) / 2); // rounded up\r\n    // console.log(`Using halfLength=${halfLength}`, `halfLengthPlus=${halfLengthPlus}`);\r\n\r\n    // Now create the parser and run the check\r\n    const ourUsfmParser = new grammar.USFMParser(fileText,\r\n        strictnessString === 'relaxed' ? grammar.LEVEL.RELAXED : null);\r\n    // Returns a Boolean indicating whether the input USFM text satisfies the grammar or not.\r\n    // This method is available in both default and relaxed modes.\r\n    // const parserResult = ourUsfmParser.validate();\r\n    const parserResult = ourUsfmParser.toJSON()\r\n    let parserMessages;\r\n    parserMessages = parserResult._messages; // Throw away the JSON (if any)\r\n    // console.log(`  Finished BCS USFM grammar check with messages: ${JSON.stringify(parserResult)}\\n and warnings: ${JSON.stringify(ourUsfmParser.warnings)}.`);\r\n    let parseError;\r\n    parseError = parserMessages._error;\r\n    // console.log(`  parseError: ${parseError}`);\r\n    let ourErrorMessage, lineNumberString, characterIndex, extract;\r\n    // NOTE: The following code is quite fragile\r\n    //  as it depends on the precise format of the error message return from USFMParser\r\n    let ourErrorObject = {};\r\n    if (parseError) {\r\n        const contextRE = /(\\d+?)\\s\\|\\s(.+)/g;\r\n        for (const errorLine of parseError.split('\\n')) {\r\n            // console.log(`BCS errorLine=${errorLine}`);\r\n            if (errorLine.startsWith('>')) {\r\n                const regexResult = contextRE.exec(errorLine.substring(1).trim());\r\n                // console.log(`  regexResult: ${JSON.stringify(regexResult)}`);\r\n                if (regexResult) {\r\n                    lineNumberString = regexResult[1];\r\n                    extract = regexResult[2];\r\n                }\r\n            }\r\n            else if (errorLine.endsWith('^')) {\r\n                characterIndex = errorLine.indexOf('^') - 8;\r\n                if (characterIndex < 0) characterIndex = 0; // Just in case\r\n                if (extract.length)\r\n                    extract = (characterIndex > halfLength ? '' : '') + extract.substring(characterIndex - halfLength, characterIndex + halfLengthPlus) + (characterIndex + halfLengthPlus < extract.length ? '' : '')\r\n            }\r\n            else ourErrorMessage = errorLine; // We only want the last one\r\n        }\r\n        // console.log(`  ourErrorMessage: '${ourErrorMessage}' lineNumberString=${lineNumberString} characterIndex=${characterIndex} extract='${extract}'`);\r\n\r\n        // Some of these \"errors\" need to be degraded in priority\r\n\r\n        let adjustedPriority = 594; // We dont make these extra high coz the messages are hard for users to interpret\r\n        if (extract === '\\\\s5' // Temporarily, even though \\s5 fields are not valid USFM\r\n            || ourErrorMessage.startsWith('Expected \"f*\", \"+\"') // Might neeed a OHM schema fix?\r\n        )\r\n            adjustedPriority = 294;\r\n\r\n        ourErrorObject = {\r\n            priority: adjustedPriority, message: `USFMGrammar: ${ourErrorMessage}`,\r\n            filename,\r\n            characterIndex, extract,\r\n            location: givenLocation\r\n        };\r\n\r\n        // Save our line number\r\n        if (lineNumberString && lineNumberString.length) {\r\n            /*\r\n            //  but we need a temporary fix for the BCS bug which doesnt include blank lines in the count\r\n            let lineNumber = Number(lineNumberString)\r\n            let notified = false;\r\n            const lines = fileText.split('\\n');\r\n            for (let n = 1; n <= lines.length; n++) {\r\n                if (n >= lineNumber) break; // Gone far enough\r\n                if (!lines[n - 1]) {\r\n                    lineNumber += 1; // Increment error line number for each blank line\r\n                    if (!notified) {\r\n                        console.log(\"Temporarily adjusting BCS grammar error line number to account for blank lines\");\r\n                        notified = true;\r\n                    }\r\n                }\r\n            }\r\n            ourErrorObject.lineNumber = lineNumber;\r\n            */\r\n            ourErrorObject.lineNumber = Number(lineNumberString);\r\n        }\r\n    }\r\n\r\n    const parseWarnings = parserResult._warnings ? parserResult._warnings : ourUsfmParser.warnings;\r\n    // console.log(`  Warnings: ${JSON.stringify(parseWarnings)}`);\r\n    let ourWarnings = [];\r\n    for (const warningString of parseWarnings) {\r\n        // console.log(`warningString: '${warningString}'`);\r\n        // Clean up their warnings a little: Remove trailing spaces and periods\r\n        let adjustedString = warningString.trim(); // Removes the trailing space\r\n        if (adjustedString.endsWith('.')) adjustedString = adjustedString.substring(0, adjustedString.length - 1);\r\n        ourWarnings.push(adjustedString);\r\n    }\r\n\r\n    return { isValidUSFM: !parseError, error: ourErrorObject, warnings: ourWarnings };\r\n}\r\n// end of runBCSGrammarCheck function\r\n\r\n\r\nexport function checkUSFMGrammar(bookID, strictnessString, filename, givenText, givenLocation, checkingOptions) {\r\n    /*\r\n    This function is only used for the demonstration pages -- not for the core!\r\n\r\n    bookID is a three-character UPPERCASE USFM book identifier.\r\n\r\n    filename parameter can be an empty string if we dont have one.\r\n\r\n     Returns a result object containing a successList and a noticeList\r\n     */\r\n    console.log(`checkUSFMGrammar(${givenText.length.toLocaleString()} chars, '${givenLocation}')`);\r\n    console.assert(strictnessString === 'strict' || strictnessString === 'relaxed', `Unexpected strictnessString='${strictnessString}'`);\r\n\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n\r\n\r\n    const cugResult = { successList: [], noticeList: [] };\r\n\r\n    function addSuccessMessage(successString) {\r\n        // console.log(`checkUSFMGrammar success: ${successString}`);\r\n        cugResult.successList.push(successString);\r\n    }\r\n    function addNotice6to7(noticeObject) {\r\n        /**\r\n        * @description - adds a new notice entry, adding bookID,C,V to the given fields\r\n        * @param {Number} priority - notice priority from 1 (lowest) to 999 (highest)\r\n        * @param {String} message - the text of the notice message\r\n        * @param {Number} characterIndex - where the issue occurs in the line\r\n        * @param {String} extract - short extract from the line centred on the problem (if available)\r\n        * @param {String} location - description of where the issue is located\r\n        */\r\n        // console.log(`checkUSFMGrammar notice: (priority=${priority}) ${message}${characterIndex > 0 ? ` (at character ${characterIndex})` : \"\"}${extract ? ` ${extract}` : \"\"}${location}`);\r\n        console.assert(noticeObject.priority !== undefined, \"cUSFMgr addNotice6to7: 'priority' parameter should be defined\");\r\n        console.assert(typeof noticeObject.priority === 'number', `cUSFMgr addNotice6to7: 'priority' parameter should be a number not a '${typeof noticeObject.priority}': ${noticeObject.priority}`);\r\n        console.assert(noticeObject.message !== undefined, \"cUSFMgr addNotice6to7: 'message' parameter should be defined\");\r\n        console.assert(typeof noticeObject.message === 'string', `cUSFMgr addNotice6to7: 'message' parameter should be a string not a '${typeof noticeObject.message}': ${noticeObject.message}`);\r\n        // console.assert(characterIndex !== undefined, \"cUSFMgr addNotice6to7: 'characterIndex' parameter should be defined\");\r\n        if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cUSFMgr addNotice6to7: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}': ${noticeObject.characterIndex}`);\r\n        // console.assert(extract !== undefined, \"cUSFMgr addNotice6to7: 'extract' parameter should be defined\");\r\n        if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cUSFMgr addNotice6to7: 'extract' parameter should be a string not a '${typeof extract}': ${noticeObject.extract}`);\r\n        console.assert(noticeObject.location !== undefined, \"cUSFMgr addNotice6to7: 'location' parameter should be defined\");\r\n        console.assert(typeof noticeObject.location === 'string', `cUSFMgr addNotice6to7: 'location' parameter should be a string not a '${typeof noticeObject.location}': ${noticeObject.location}`);\r\n        cugResult.noticeList.push({ ...noticeObject, bookID, filename });\r\n    }\r\n\r\n\r\n    // Main code for checkUSFMGrammar function\r\n    if (books.isExtraBookID(bookID)) // doesnt work for these\r\n        return cugResult;\r\n\r\n    const grammarCheckResult = runBCSGrammarCheck(strictnessString, givenText, filename, ourLocation, checkingOptions);\r\n    // console.log(`grammarCheckResult=${JSON.stringify(grammarCheckResult)}`);\r\n\r\n    if (!grammarCheckResult.isValidUSFM)\r\n        addNotice6to7({ priority: 944, message: `USFM3 Grammar Check (${strictnessString} mode) doesnt pass`, filename, location: ourLocation });\r\n\r\n    // We only get one error if it fails\r\n    if (grammarCheckResult.error && grammarCheckResult.priority)\r\n        addNotice6to7(grammarCheckResult.error);\r\n\r\n    // Display these warnings but with a lowish priority\r\n    for (const warningString of grammarCheckResult.warnings)\r\n        addNotice6to7({ priority: 101, message: `USFMGrammar: ${warningString}`, filename, location: ourLocation });\r\n\r\n    addSuccessMessage(`Checked USFM Grammar (${strictnessString} mode) ${grammarCheckResult.isValidUSFM ? \"without errors\" : \" (but the USFM DIDNT validate)\"}`);\r\n    // console.log(`  checkUSFMGrammar returning with ${result.successList.length.toLocaleString()} success(es) and ${result.noticeList.length.toLocaleString()} notice(s).`);\r\n    // console.log(`checkUSFMGrammar result is ${JSON.stringify(result)}`);\r\n    return cugResult;\r\n}\r\n// end of checkUSFMGrammar function\r\n","export const DEFAULT_EXTRACT_LENGTH = 15;\r\n\r\n\r\n// See http://xahlee.info/comp/unicode_matching_brackets.html for a more complete list\r\n// Also see https://unicode-table.com/en/sets/quotation-marks/\r\nexport const PAIRED_PUNCTUATION_OPENERS = '[({<';\r\nexport const PAIRED_PUNCTUATION_CLOSERS = '])}>';\r\nexport const MATCHED_PUNCTUATION_PAIRS = [\r\n    ['[', ']'], ['(', ')'], ['{', '}'],\r\n    ['', ''], ['', ''],\r\n    ['<', '>'], ['', ''],\r\n    ['', ''], ['', ''],\r\n    ['', ''], ['', ''],\r\n    ['', ''], ['', ''],\r\n    ['**_', '_**']\r\n];\r\nexport const BAD_CHARACTER_COMBINATIONS = [\r\n    '\\\\[\\\\[', '\\\\]\\\\]', // These were introduced by a tC Create bug (NOTE: \\[ or \\] is quite legal)\r\n    '] (http', '] (.', // Bad markdown links (with a space between the parts)\r\n];\r\n\r\nexport function isWhitespace(myString) {\r\n    // includes zero-width space\r\n    if (/^[\\s\\u200B]+$/.test(myString)) return true;\r\n    return false;\r\n}\r\n\r\n\r\nexport function countOccurrences(mainString, subString, allowOverlapping = false) {\r\n    // Adapted from https://stackoverflow.com/questions/4009756/how-to-count-string-occurrence-in-string\r\n\r\n    mainString += '';\r\n    subString += '';\r\n    if (subString.length <= 0) return (mainString.length + 1);\r\n\r\n    let n = 0,\r\n        pos = 0,\r\n        step = allowOverlapping ? 1 : subString.length;\r\n\r\n    while (true) {\r\n        pos = mainString.indexOf(subString, pos);\r\n        if (pos >= 0) {\r\n            ++n;\r\n            pos += step;\r\n        } else break;\r\n    }\r\n    return n;\r\n}\r\n// end of countOccurrences function\r\n\r\n\r\nexport function ourReplaceAll(givenString, findString, replaceString) {\r\n    let resultString = givenString;\r\n    while (resultString.indexOf(findString) >= 0)\r\n        resultString = resultString.replace(findString, replaceString);\r\n    return resultString;\r\n}\r\n\r\n\r\nexport function ourDeleteAll(givenString, findString) {\r\n    let resultString = givenString;\r\n    while (resultString.indexOf(findString) >= 0)\r\n        resultString = resultString.replace(findString, '');\r\n    return resultString;\r\n}","module.exports = __webpack_public_path__ + \"static/media/SILEOTSR.a5284649.ttf\";","import data from './books.json';\r\n\r\nexport interface bookDataIF {\r\n  \"id\": string;\r\n  \"title\": string;\r\n  \"usfm\": string;\r\n  \"testament\": string;\r\n  \"verseCount\": number;\r\n  \"chapters\": number[];\r\n}\r\n\r\ninterface bpStateIF { [x: string]: boolean[]; };\r\n\r\nexport const chaptersInBook = (bookId: string) => {\r\n    let chapters: number[];\r\n    chapters = bookData(bookId).chapters;\r\n    if ( chapters === undefined ) {\r\n      throw new Error(\"Error: chaptersInBook(): Invalid bookId\");\r\n    }\r\n    return chapters;\r\n};\r\n\r\nexport const versesInChapter = (bookId: string, chapter: number) => {\r\n  const verses = chaptersInBook(bookId)[chapter - 1];\r\n  return verses;\r\n};\r\n\r\nexport const bookData = (bookId: string) => {\r\n  const _bookData: bookDataIF = data.filter(row => row.id === bookId)[0];\r\n  return _bookData;\r\n};\r\n\r\nexport const testament = (bookId: string) => {\r\n    bookId = bookId.toLowerCase();\r\n    const _testament = bookData(bookId).testament;\r\n  return _testament;\r\n};\r\n\r\nexport const newTestament = () => {\r\n  let list: string[] = [];\r\n  for (let i=0; i < data.length; i++) {\r\n    if ( data[i].testament === \"new\" ) {\r\n      list.push( data[i].title )\r\n    }\r\n  }\r\n  return list;\r\n}\r\n\r\nexport const oldTestament = () => {\r\n  let list: string[] = [];\r\n  for (let i=0; i < data.length; i++) {\r\n    if ( data[i].testament === \"old\" ) {\r\n      list.push( data[i].title )\r\n    }\r\n  }\r\n  return list;\r\n}\r\n\r\nexport const bookDataTitles = () => {\r\n  let list: string[] = [];\r\n  for (let i=0; i < data.length; i++) {\r\n      list.push( data[i].title )\r\n  }\r\n  return list;\r\n}\r\n\r\nexport const titlesToBoolean = () => {\r\n  let ob: bpStateIF = {};\r\n  let list = bookDataTitles();\r\n  list.forEach((v,k) => {ob[v]= [false,false]});\r\n  return ob;\r\n}\r\n\r\nexport const bookIdByTitle = (title: string) => {\r\n  for (let i=0; i < data.length; i++) {\r\n    if ( data[i].title === title ) {\r\n      return data[i].id;\r\n    }\r\n  }\r\n  return \"\";\r\n}\r\n\r\nexport const bookTitleById = (id: string) => {\r\n    id = id.toLowerCase();\r\n    for (let i=0; i < data.length; i++) {\r\n    if ( data[i].id === id ) {\r\n      return data[i].title;\r\n    }\r\n  }\r\n  return \"\";\r\n}\r\n\r\nconst extraBookList = ['FRT','BAK'];\r\n\r\nexport const isOptionalValidBookID = (bookId: string) => {\r\n  return !bookId || bookId.toLowerCase() in data || extraBookList.indexOf(bookId) >= 0;\r\n}\r\nexport const isValidBookID = (id: string) => {\r\n  const _id = id.toLowerCase();\r\n  for (let i=0; i < data.length; i++) {\r\n    if ( data[i].id === _id ) {\r\n      return true;\r\n    }\r\n  }\r\n  const __id = id.toUpperCase();\r\n  for (let i=0; i < extraBookList.length; i++) {\r\n    if ( extraBookList[i] === __id ) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\nexport const usfmNumberNameById = (id: string) => {\r\n  id = id.toLowerCase();\r\n  for (let i=0; i < data.length; i++) {\r\n    if ( data[i].id === id ) {\r\n      return data[i].usfm;\r\n    }\r\n  }\r\n  throw new Error(`usfmNumberName() given invalid bookId: '${id}'`);\r\n}\r\n\r\n","import Path from 'path';\nimport yaml from 'yaml';\nimport localforage from 'localforage';\nimport { setup } from 'axios-cache-adapter';\nimport JSZip from 'jszip';\nimport _ from \"lodash\";\n\nconst baseURL = 'https://git.door43.org/';\nconst apiPath = 'api/v1';\n\nconst repoDefaultMap = {\n  // format is organization and then repoName\n  hbo: {\n    UHB: \"unfoldingWord/hbo_uhb\",\n  },\n  'el-x-koine': {\n    UGNT: \"unfoldingWord/el-x-koine_ugnt\",\n  },\n  en: {\n    label: \"English (unfoldingWord)\",\n    UHB: \"unfoldingWord/hbo_uhb\",\n    UGNT: \"unfoldingWord/el-x-koine_ugnt\",\n    TA: \"unfoldingWord/en_ta\",\n    TN: \"unfoldingWord/en_tn\",\n    TW: \"unfoldingWord/en_tw\",\n    TQ: \"unfoldingWord/en_tq\",\n    ST: \"unfoldingWord/en_ust\",\n    LT: \"unfoldingWord/en_ult\",\n  },\n  hi: {\n    label: \"Hindi (translationCore-Create-BCS)\",\n    UHB: \"unfoldingWord/hbo_uhb\",\n    UGNT: \"unfoldingWord/el-x-koine_ugnt\",\n    TA: \"translationCore-Create-BCS/hi_ta\",\n    TN: \"translationCore-Create-BCS/hi_tn\",\n    TW: \"translationCore-Create-BCS/hi_tw\",\n    TQ: \"translationCore-Create-BCS/hi_tq\",\n    ST: \"translationCore-Create-BCS/hi_gst\",\n    LT: \"translationCore-Create-BCS/hi_glt\",\n  },\n  kn: {\n    label: \"Kannada (translationCore-Create-BCS)\",\n    UHB: \"unfoldingWord/hbo_uhb\",\n    UGNT: \"unfoldingWord/el-x-koine_ugnt\",\n    TA: \"translationCore-Create-BCS/kn_ta\",\n    TN: \"translationCore-Create-BCS/kn_tn\",\n    TW: \"translationCore-Create-BCS/kn_tw\",\n    TQ: \"translationCore-Create-BCS/kn_tq\",\n    ST: \"translationCore-Create-BCS/kn_gst\",\n    LT: \"translationCore-Create-BCS/kn_glt\",\n  },\n  'es-419': {\n    label: \"Latin-American Spanish (Es-419_gl)\",\n    UHB: \"unfoldingWord/hbo_uhb\",\n    UGNT: \"unfoldingWord/el-x-koine_ugnt\",\n    TA: \"Es-419_gl/es-419_ta\",\n    TN: \"Es-419_gl/es-419_tn\",\n    TW: \"Es-419_gl/es-419_tw\",\n    TQ: \"Es-419_gl/es-419_tq\",\n    ST: \"Es-419_gl/es-419_gst\",\n    LT: \"Es-419_gl/es-419_glt\",\n  },\n  ru: {\n    label: \"Russian (ru_gl)\",\n    UHB: \"unfoldingWord/hbo_uhb\",\n    UGNT: \"unfoldingWord/el-x-koine_ugnt\",\n    TA: \"ru_gl/ru_ta\",\n    TN: \"ru_gl/ru_tn\",\n    TW: \"ru_gl/ru_tw\",\n    TQ: \"ru_gl/ru_tq_2lv\",\n    ST: \"ru_gl/ru_rsob\",\n    LT: \"ru_gl/ru_rlob\",\n  }\n};\n\nlet repoMap = repoDefaultMap;\n\n/**\n * initialize repo map to new value or reset to default\n * @param {object} newRepoMap - defaults to defaultRepoMap\n * @return {*}\n */\nexport function initRepoMap(newRepoMap = repoDefaultMap) {\n  //console.log(`initRepoMap() - setting repo map to ${JSON.stringify(newRepoMap)}`)\n  repoMap = _.cloneDeep(newRepoMap);\n}\n\n/**\n * find settings for the language\n * @return {object} current repoMap\n */\nexport function getRepoMap() {\n  return _.cloneDeep(repoMap);\n}\n\n/**\n * verify existence valid repo manifest - missing repos are added to error\n * @param {string} username\n * @param {string} repository\n * @param {Array} errors\n * @param {string} repoType\n * @param {string} language\n * @param {string} branch\n * @return {Promise<Array>}\n */\nexport async function verifyRepo(username, repository, errors, repoType, language, branch = 'master') {\n  console.log(`verifyRepo(${username}, ${repository}, ${repoType}, ${language})`)\n  // verify that repo exists and that it has a manifest\n  let { repoExists, manifestValid } = await verifyManifest({ username, repository });\n  let manifestFound = manifestValid, repoFound = repoExists, manifestParseFailed = false;\n\n  let message;\n\n  if ( repoFound ) {\n    // check if repo manifest exists\n    const manifestContents = await getFileCached({ username, repository, path: 'manifest.yaml', branch });\n    if (manifestContents) {\n      manifestFound = true;\n      // see if manifest is parseable\n      const manifestJSON = await cachedGetManifest({ username, repository, branch });\n      if (manifestJSON) {\n        manifestParseFailed = false;\n        // see if manifest is minimally sufficient\n        if (manifestJSON.projects && manifestJSON.projects.length) {\n          manifestValid = true;\n          message = 'repo and manifest OK';\n        } else {\n          manifestValid = false;\n          message = 'manifest is imcomplete';\n        }\n        errors.push({repoType, \n          username,\n          repository,\n          language,\n          message, \n          manifestFound, \n          manifestValid, \n          manifestParseFailed, \n          repoFound\n        });\n      } else {\n        manifestParseFailed = true;\n        message = 'manifest is not parseable';\n        errors.push({repoType, \n          username,\n          repository,\n          language,\n          message, \n          manifestFound, \n          manifestValid, \n          manifestParseFailed, \n          repoFound\n        });\n      }\n    } else {\n      message = 'manifest is missing';\n      errors.push({repoType, \n        username,\n        repository,\n        language,\n        message, \n        manifestFound, \n        manifestValid, \n        manifestParseFailed, \n        repoFound\n      });\n    }\n  } else {\n    message = 'repo does not exist';\n    errors.push({repoType, \n      username,\n      repository,\n      language,\n      message, \n      manifestFound, \n      manifestValid, \n      manifestParseFailed, \n      repoFound\n    });\n  } \n  return errors;\n\n}\n\n/**\n * check server to see if repository with valid manifest exists on server.\n * @param {string} username\n * @param {string} repository\n * @return {Promise<{repoExists: boolean, manifestValid: boolean}>}\n */\nasync function verifyManifest({ username, repository }) {\n\n  const params = { };\n  // console.log(`repositoryExists params=${JSON.stringify(params)}`);\n  // https://git.door43.org/api/v1/repos/unfoldingword/en_tq\n  const uri = Path.join(apiPath, 'repos', username, repository);\n  // console.log(`repositoryExists uri=${uri}`);\n  let response, repoExists = false, manifestValid = false;\n  try {\n    response = await cachedGet({uri, params});\n    if (response) {\n      repoExists = true;\n      if (!response.subject) {\n        manifestValid = false;\n      } else {\n        manifestValid = true;\n      }\n    } else {\n      repoExists = false;\n    }\n  } catch (e) {\n    repoExists = false;\n    if (e && e.response && (e.response.status === 404)) {\n      console.log(`verifyManifest(${username}, ${repository}) - repo does not exist`);\n    } else {\n      console.error(`verifyManifest(${username}, ${repository}) - query error`, e);\n    }\n  }\n  return { repoExists, manifestValid };\n}\n\n/**\n * make sure we find repos on DCS for a language\n * @param {string} username\n * @param {string} language\n * @param {Array} repoTypes\n * @param {string} branch\n * @return {Promise<Array>} list of repo types that were not found on DCS\n */\nexport async function verifyRepos(username, language, repoTypes, branch = 'master') {\n  const errors = [];\n  const promises = [];\n  const startTime = new Date();\n  for (let repoType of repoTypes) {\n    const path = findPathForRepo(username, language, repoType, repoType);\n    if (!path) {\n      errors.push({ repoType, message: `could not find path for ${language}/${repoType}`});\n      continue;\n    }\n    let orgName, repo;\n    [ orgName, repo ] = path.split('/');\n    // console.log(`verifying ${path}`)\n    promises.push(verifyRepo(orgName, repo, errors, repoType, language, branch)); // run each check in parallel\n  }\n  await Promise.all(promises); // wait for all repos to be verified\n  if (errors.length) {\n    //console.log(`verifyRepos(${username}, ${language}, ${JSON.stringify(repoTypes)}) - missing repos for ${JSON.stringify(errors)}`)\n  }\n  const elapsedSeconds = (new Date() - startTime) / 1000; // seconds\n  console.log(`verifyRepos(${username}, ${language}..) finished ${elapsedSeconds} seconds`);\n  return errors;\n}\n\n/**\n * make sure we find repos on DCS for all languages\n * @param {string} username\n * @param {Array} repoTypes\n * @param {Object} results\n * @param {string} branch\n * @return {Promise<*>} list of repo types that were not found on DCS\n */\nexport async function verifyReposForLanguages(username, repoTypes, results, branch = 'master') {\n  const startTime = new Date();\n  const promises = [];\n  results.finished = false;\n  for (let langID of Object.keys(repoMap)) {\n    if (!repoMap[langID].label) { // don't validate languages that don't have a label\n      continue;\n    }\n    const langResults = {\n      finished: false,\n    };\n    results[langID] = langResults;\n    promises.push(verifyRepos(username, langID, repoTypes, branch ).then((errors) => {\n      langResults.finished = true;\n      langResults.errors = errors;\n    }));\n  }\n  await Promise.all(promises); // wait for all repos to be verified\n  results.finished = true;\n  const elapsedSeconds = (new Date() - startTime) / 1000; // seconds\n  console.log(`verifyReposForLanguages() finished in ${elapsedSeconds} seconds`);\n}\n\n/**\n * change the path for the repo\n * @param {string} language\n * @param {string} repoType\n * @param {string} username\n * @param {string} repoName\n */\nexport function setPathForRepo(language, repoType, username, repoName) {\n  //    console.log(`setPathForRepo('${username}', '${repo}')`);\n  let path;\n  const { langRepos } = findSettingsForLanguage(repoType, language);\n  if (langRepos) {\n    langRepos[repoType] = `${username}/${repoName}`;\n    //console.error(`setPathForRepo(${language}, ${repoType}) - setting repo path to ${langRepos[repoType]}`);\n    return\n  }\n  //console.error(`setPathForRepo(${language}, ${repoType}) - cannot find repo path`);\n  return path;\n}\n\n/**\n * find settings for the language\n * @param {string} language\n * @param {string} repoType\n * @return {*}\n */\nfunction findSettingsForLanguage(repoType, language) {\n  repoType = repoType.toUpperCase();\n  if (['ULT', 'GLT'].includes(repoType)) repoType = 'LT';\n  if (['UST', 'GST'].includes(repoType)) repoType = 'ST';\n  const langRepos = repoMap[language.toLowerCase()];\n  return {repoType, langRepos};\n}\n\n/**\n * look up the username/repoName for the repo based on language\n * @param {string} language\n * @param {string} repoType\n * @return {string}\n */\nexport function findPathForRepo(username, language, repoType, repoName) {\n  //    console.log(`findPathForRepo('${language}', '${repoType}')`);\n  const { langRepos, repoType: repoType_ } = findSettingsForLanguage(repoType, language);\n  if (langRepos) {\n    const location = langRepos[repoType_];\n    if (location) {\n      return location;\n    }\n  }\n  //console.log(`findPathForRepo(${language}, ${repoType}) - not overriding default`);\n  return `${username}/${repoName}`; // fall back to original\n}\n\n/**\n *\n * @param {string} username\n * @param {string} repoName (e.g. hi_tn)\n * @return {{username: string, repoName: string}} username and repoName to use\n */\nexport function getOverridesForRepo(username, repoName) {\n  //    console.log(`getOverridesForRepo('${username}', '${repo}')`);\n  // const originalUsername = username;\n  const divider = repoName.indexOf('_');\n  if (divider >= 0) {\n    const language = repoName.substr(0, divider);\n    const repoType = repoName.substr(divider + 1);\n    const path = findPathForRepo(username, language, repoType, repoName);\n    if (path) {\n      [username, repoName] = path.split('/');\n    }\n  }\n\n  // if (username.toLowerCase() !== originalUsername.toLowerCase()) {\n  //   console.log(`getOverridesForRepo('${originalUsername}', '${repoName}') - changing username to ${username}`);\n  // }\n  return { username, repoName };\n}\n\n// caches failed http file fetches so we don't waste time with repeated attempts\nconst failedStore = localforage.createInstance({\n  driver: [localforage.INDEXEDDB],\n  name: 'failed-store',\n});\n\n// caches zip file fetches done by fetchRepositoryZipFile()\nconst zipStore = localforage.createInstance({\n  driver: [localforage.INDEXEDDB],\n  name: 'zip-store',\n});\n\n// caches http file fetches done by fetchFileFromServer()\nconst cacheStore = localforage.createInstance({\n  driver: [localforage.INDEXEDDB],\n  name: 'web-cache',\n});\n\n// caches the unzipped files requested so we don't do repeated unzipping of the same file which is slow in JS\nconst unzipStore = localforage.createInstance({\n  driver: [localforage.INDEXEDDB],\n  name: 'unzip-store',\n});\n\n\n// API for http requests\nconst Door43Api = setup({\n  baseURL: baseURL,\n  cache: {\n    store: cacheStore,\n    maxAge: 5 * 60 * 1000, // 5-minutes\n    exclude: { query: false },\n    key: req => {\n      // if (req.params) debugger\n      let serialized = req.params instanceof URLSearchParams ?\n        req.params.toString() : JSON.stringify(req.params) || '';\n      return req.url + serialized;\n    },\n  },\n});\n\n/**\n * try to get previously unzipped file from cache\n * @param {string} path\n * @return {Promise<unknown>} resolves to file contents or null if not found\n */\nexport async function getUnZippedFile(path) {\n  // console.log(`getUnZippedFile(${path})`);\n  const contents = await unzipStore.getItem(path.toLowerCase());\n  return contents;\n}\n\n/**\n * searches for files in this order:\n *   - cache of uncompressed files (unzipStore)\n *   - cache of zipped repos (zipStore)\n *   - and finally calls fetchFileFromServer() which firts checks in cacheStore to see if already fetched.\n * @param {String} username\n * @param {String} repository\n * @param {String} path\n * @param {String} branch\n * @return {Promise<*>}\n */\nexport async function getFileCached({ username, repository, path, branch }) {\n\n  const { username: username_, repoName } = getOverridesForRepo(username, repository);\n  username = username_;\n  repository = repoName;\n\n  const filePath = Path.join(username, repository, branch, path);\n  // console.log(`getFileCached(${username}, ${repository}, ${path}, ${branch})`);\n  let contents = await getUnZippedFile(filePath);\n  if (contents) {\n    // console.log(`in cache - ${filePath}`);\n    return contents;\n  }\n\n  contents = await getFileFromZip({ username, repository, path, branch });\n  if (!contents) {\n    contents = await fetchFileFromServer({ username, repository, path, branch });\n  }\n\n  if (contents) {\n    // save unzipped file in cache to speed later retrieval\n    await unzipStore.setItem(filePath.toLowerCase(), contents);\n    // console.log(`saving to cache - ${filePath}`);\n  } else {\n    console.log(`getFileCached(${username}, ${repository}, ${path}, ${branch}) - failed to get file`);\n  }\n\n  return contents;\n}\n\n/**\n * Retrieve manifest.yaml from requested repo\n * @param {string} username\n * @param {string} repository\n * @param {string} branch\n * @return {Promise<[]|*[]>} resolves to manifest contents if downloaded (else undefined)\n */\nasync function cachedGetManifest({ username, repository, branch }) {\n  // console.log(`cachedGetManifest(${username}, ${repository}, ${branch})`);\n\n  const manifestContents = await getFileCached({ username, repository, path: 'manifest.yaml', branch });\n  let formData;\n  try {\n    formData = yaml.parse(manifestContents);\n    // console.log(\"yaml.parse(YAMLText) got formData\", JSON.stringify(formData));\n  }\n  catch (yamlError) {\n    console.error(`${username} ${repository} ${branch} manifest yaml parse error: ${yamlError.message}`);\n  }\n  return formData;\n}\n\n\n/**\n * Retrieve manifest.yaml from requested repo\n * @param {string} username\n * @param {string} repository\n * @param {string} branch\n * @param {string} bookID -- 3-character USFM book code\n * @return {Promise<[]|*[]>} resolves to filename from the manifest for the book (else undefined)\n */\nexport async function cachedGetBookFilenameFromManifest({ username, repository, branch, bookID }) {\n  // console.log(`cachedGetBookFilenameFromManifest(${username}, ${repository}, ${branch}, ${bookID})`);\n  const manifestJSON = await cachedGetManifest({ username, repository, branch });\n  for (const projectEntry of manifestJSON.projects) {\n    if (projectEntry.identifier === bookID) {\n      let bookPath = projectEntry.path;\n      if (bookPath.startsWith('./')) bookPath = bookPath.substring(2);\n      return bookPath;\n    }\n  }\n}\n\n/**\n * clear all the stores\n * @return {Promise<void>}\n */\nexport async function clearCaches() {\n  //console.log(\"Clearing localforage.INDEXEDDB zipStore, cacheStore, etc. caches\");\n  // const tasks = [zipStore, cacheStore].map(localforage.clear);\n  // const results = await Promise.all(tasks);\n  // results.forEach(x => console.log(\"Done it\", x));\n  await failedStore.clear();\n  await zipStore.clear();\n  await cacheStore.clear();\n  await unzipStore.clear();\n}\n\n/**\n * @description - Forms and returns a Door43 repoName string\n * @param {String} languageCode - the language code, e.g., 'en'\n * @param {String} repoCode - the repo code, e.g., 'TQ'\n * @return {String} - the Door43 repoName string\n */\nexport function formRepoName(languageCode, repoCode) {\n  //    console.log(`formRepoName('${languageCode}', '${repoCode}')`);\n  repoCode = repoCode.toUpperCase();\n\n  // TODO: Should we also check the username 'unfoldingWord' and/or 'Door43-Catalog' here???\n  //        (We don't currently have the username available in this function.)\n  if (repoCode === 'LT') repoCode = languageCode === 'en' ? 'ULT' : 'GLT';\n  if (repoCode === 'ST') repoCode = languageCode === 'en' ? 'UST' : 'GST';\n\n  let repo_languageCode = languageCode;\n  if (repoCode === 'UHB') repo_languageCode = 'hbo';\n  else if (repoCode === 'UGNT') repo_languageCode = 'el-x-koine';\n  const repoName = `${repo_languageCode}_${repoCode.toLowerCase()}`;\n  return repoName;\n}\n\n/**\n * add new repo to list if missing\n * @param {string} repos\n * @param {string} newRepo\n * @param {boolean} addToStart - if true add to start\n */\nfunction addIfMissing(repos, newRepo, addToStart = true) {\n  if (!repos.includes(newRepo)) {\n    if (addToStart) {\n      repos.unshift(newRepo);\n    } else {\n      repos.push(newRepo);\n    }\n  }\n}\n\n/**\n * preloads repo zips, before running book package checks.\n *   TRICKY: note that even if the user is super fast in selecting books and clicking next, it will not hurt anything.  getFile() would just be fetching files directly from repo until the zips are loaded.  After that the files would be pulled out of zipStore.\n * @param {string} username\n * @param {string} languageCode\n * @param {string} branch - optional, defaults to master\n * @param {Array} repos - optional, list of additional repos to pre-load\n * @param {boolean} loadOriginalLangs - if true will download original language books\n * @param {boolean} loadUltAndUst\n * @return {Promise<Boolean>} resolves to true if file loads are successful\n */\nexport async function PreLoadRepos(username, languageCode, branch = 'master', repos = [],\n                                   loadOriginalLangs = false,\n                                   loadUltAndUst = false) {\n  //console.log(`PreLoadRepos(${username}, ${languageCode}, ${branch}, ${repos}, ${loadOriginalLangs})`);\n\n  let success = true;\n  const repos_ = repos.map((repo) => (formRepoName(languageCode, repo)));\n\n  if (loadOriginalLangs) {\n    // make sure we have the original languages needed\n    for (const origLangBibles of [ 'UHB', 'UGNT' ]) {\n      addIfMissing(repos_, formRepoName(languageCode, origLangBibles), true);\n    }\n  }\n\n  if (loadUltAndUst) {\n    const LT = languageCode === 'en' ? 'ULT' : 'GLT';\n    const ST = languageCode === 'en' ? 'UST' : 'GST';\n    addIfMissing(repos_, formRepoName(languageCode, LT), false);\n    addIfMissing(repos_, formRepoName(languageCode, ST), false);\n  }\n\n  // load all the repos needed\n  for (const repoName of repos_) {\n    //console.log(`PreLoadRepos: preloading zip file for ${repoName}`);\n    const zipFetchSucceeded = await fetchRepositoryZipFile({ username, repository: repoName, branch });\n    if (!zipFetchSucceeded) {\n      //console.log(`PreLoadRepos: misfetched zip file for ${repoName} repo with ${zipFetchSucceeded}`);\n      success = false;\n    }\n  }\n\n  return success;\n}\n\n/**\n * does http file fetch from server  uses cacheStore to minimize repeated fetches of same file\n * @param {string} username\n * @param {string} repository\n * @param {string} path\n * @param {string} branch\n * @return {Promise<null|any>} resolves to file content\n */\nasync function fetchFileFromServer({ username, repository, path, branch = 'master' }) {\n  //console.log(`fetchFileFromServer(${username}, ${repository}, ${path}, ${branch})`);\n  const uri = Path.join(username, repository, 'raw/branch', branch, path);\n  const failMessage = await failedStore.getItem(uri.toLowerCase());\n  if (failMessage) {\n    // console.log(`fetchFileFromServer failed previously for ${uri}: ${failMessage}`);\n    return null;\n  }\n  try {\n    // console.log(\"URI=\",uri);\n    const data = await cachedGet({ uri });\n    // console.log(\"Got data\", data);\n    return data;\n  }\n  catch (fffsError) {\n    console.log(`ERROR: fetchFileFromServer could not fetch ${path}: ${fffsError}`)\n    /* await */ failedStore.setItem(uri.toLowerCase(), fffsError.message);\n    return null;\n  }\n}\n\n/**\n *  older getFile without that doesn't use the unzipStore\n * @param {string} username\n * @param {string} repository\n * @param {string} path\n * @param {string} branch\n * @return {Promise<*>}\n */\n// eslint-disable-next-line no-unused-vars\nasync function getFile({ username, repository, path, branch }) {\n  //console.log(`getFile(${username}, ${repository}, ${path}, ${branch})`);\n  let file;\n  file = await getFileFromZip({ username, repository, path, branch });\n  if (!file) {\n    file = await fetchFileFromServer({ username, repository, path, branch });\n  }\n  return file;\n}\n\n// async function getUID({ username }) {\n//   // console.log(`getUID(${username})`);\n//   const uri = Path.join(apiPath, 'users', username);\n//   // console.log(`getUID uri=${uri}`);\n//   const user = await cachedGet({ uri });\n//   // console.log(`getUID user=${user}`);\n//   const { id: uid } = user;\n//   // console.log(`  getUID returning: ${uid}`);\n//   return uid;\n// }\n\n/**\n * check server to see if repository exists on server.  Do this before we try to download\n * @param {string} username\n * @param {string} repository\n * @return {Promise<boolean>}\n */\n// eslint-disable-next-line no-unused-vars\nasync function repositoryExists({ username, repository }) {\n  // console.log(`repositoryExists(${username}, ${repository})`);\n  // https://qa.door43.org/api/v1/repos/search?repo=kn_tn&owner=translationCore-Create-BCS\n  // TODO: we probably want to change this to do paging since we cannot be sure of future size limits on fetches\n  const params = { repo: repository, owner: username };\n  // console.log(`repositoryExists params=${JSON.stringify(params)}`);\n  const uri = Path.join(apiPath, 'repos', `search`);\n  // console.log(`repositoryExists uri=${uri}`);\n  const { data: repos } = await cachedGet({ uri, params });\n  // console.log(`repositoryExists repos (${repos.length})=${repos}`);\n  // for (const thisRepo of repos) console.log(`  thisRepo (${JSON.stringify(Object.keys(thisRepo))}) =${JSON.stringify(thisRepo.name)}`);\n  const match = `${username}/${repository}`.toLowerCase();\n  const repoList = repos.filter(repo => repo.full_name.toLowerCase() === match);\n  const repo = repoList[0];\n  // console.log(`repositoryExists repo=${repo}`);\n  // console.log(`  repositoryExists returning: ${!!repo}`);\n  if (!repo) {\n    console.log(`repositoryExists(${username}, ${repository}) - repo not found`, repos, repoList);\n  }\n  return !!repo;\n}\n\nasync function cachedGet({ uri, params }) {\n  // console.log(`cachedGet(${uri}, ${JSON.stringify(params)})`);\n  // console.log(`  get querying: ${baseURL+uri}`);\n  const { data } = await Door43Api.get(baseURL + uri, { params });\n  // console.log(`  cachedGet returning: ${JSON.stringify(data)}`);\n  return data;\n}\n\nexport async function cachedGetURL({ uri, params }) {\n  // console.log(`cachedGetURL(${uri}, ${params})`);\n  const { data } = await Door43Api.get(uri, { params });\n  // console.log(`  cachedGetURL returning: ${data}`);\n  return data;\n}\n\n/*\nfunction fetchRepositoriesZipFiles({username, languageId, branch}) {\n  const repositories = resourceRepositories({languageId});\n  const promises = Object.values(repositories).map(repository => {\n    return fetchRepositoryZipFile({username, repository, branch});\n  });\n  const zipArray = await Promise.all(promises);\n  return zipArray;\n};\n*/\n\n\n/**\n * retrieve repo as zip file\n * @param {string} username\n * @param {string} repository\n * @param {string} branch\n * @param {boolean} forceLoad - if not true, then use existing repo in zipstore\n * @return {Promise<[]|*[]>} resolves to true if downloaded\n */\nexport async function fetchRepositoryZipFile({ username, repository, branch }, forceLoad = false) {\n  // https://git.door43.org/{username}/{repository}/archive/{branch}.zip\n  //console.log(`fetchRepositoryZipFile(${username}, ${repository}, ${branch})`);\n\n  const { username: username_, repoName } = getOverridesForRepo(username, repository);\n  username = username_;\n  repository = repoName;\n\n  if (!forceLoad) { // see if we already have in zipStore\n    const zipBlob = await getZipFromStore(username, repository, branch);\n    if (zipBlob) {\n      //console.log(`fetchRepositoryZipFile(${username}, ${repository}, ${branch}) - already loaded`);\n      return true;\n    }\n  }\n\n  const uri = zipUri({ username, repository, branch });\n  const response = await fetch(uri);\n  if (response.status === 200 || response.status === 0) {\n    const zipArrayBuffer = await response.arrayBuffer(); // blob storage not supported on mobile\n    //console.log(`fetchRepositoryZipFile(${username}, ${repository}, ${branch}) - saving zip: ${uri}`);\n    await zipStore.setItem(uri.toLowerCase(), zipArrayBuffer);\n    return true;\n  } else {\n    //console.log(`fetchRepositoryZipFile(${username}, ${repository}, ${branch}) - got response status: ${response.status}`);\n    return false;\n  }\n}\n\n/**\n * pull repo from zipstore and get a file list\n * @param {string} username\n * @param {string} repository\n * @param {string} branch\n * @param {string} optionalPrefix - to filter by book, etc.\n * @return {Promise<[]>}  resolves to file list\n */\nexport async function getFileListFromZip({ username, repository, branch, optionalPrefix }) {\n  // console.log(`getFileListFromZip(${username}, ${repository}, ${branch}, ${optionalPrefix})`);\n\n  const { username: username_, repoName } = getOverridesForRepo(username, repository);\n  username = username_;\n  repository = repoName;\n\n  const uri = zipUri({ username, repository, branch });\n  let zipBlob = await getZipFromStore(username, repository, branch);\n\n  if (!zipBlob) { // Seems that we need to load the zip file first\n    const response = await fetch(uri);\n    if (response.status === 200 || response.status === 0) {\n      const zipArrayBuffer = await response.arrayBuffer(); // blob storage not supported on mobile\n      zipBlob = await zipStore.setItem(uri.toLowerCase(), zipArrayBuffer);\n    } else {\n      //console.log(`ERROR: getFilelistFromZip got response status: ${response.status}`);\n      return [];\n    }\n  }\n\n  const pathList = [];\n  try {\n    if (zipBlob) {\n      // console.log(`  Got zipBlob for uri=${uri}`);\n      const zip = await JSZip.loadAsync(zipBlob);\n      // console.log(`  Got zip`);\n      // Now we need to fetch the list of files from the repo\n      // zip.forEach(function (relativePath, fileObject) {\n      zip.forEach(function (relativePath) {\n        // console.log(`relPath=${relativePath}`)\n        // consoleLogObject('fileObject', fileObject);\n        if (!relativePath.endsWith('/')) // it's not a folder\n        {\n          if (relativePath.startsWith(`${repository}/`)) // remove repo name prefix\n            relativePath = relativePath.substring(repository.length + 1);\n          if (relativePath.length\n            && !relativePath.startsWith('.git') // skips files in these folders\n            && !relativePath.startsWith('.apps') // skips files in this folder\n            && (!optionalPrefix || relativePath.toLowerCase().startsWith(optionalPrefix))) // it's the correct prefix\n            pathList.push(relativePath);\n        }\n      })\n    }\n    // else console.log(\"  getFileListFromZip: No zipBlob\");\n  } catch (error) {\n    console.log(`ERROR: getFilelistFromZip got: ${error.message}`);\n  }\n\n  // console.log(`getFileListFromZip is returning (${pathList.length}) entries: ${pathList}`);\n  return pathList;\n}\n\n/**\n * try to get zip file from cache\n * @param {string} username\n * @param {string} repository\n * @param {string} branch\n * @return {Promise<unknown>} resolves to null if not found\n */\nexport async function getZipFromStore(username, repository, branch) {\n  const uri = zipUri({username, repository, branch});\n  const zipBlob = await zipStore.getItem(uri.toLowerCase());\n  // console.log(`getZipFromStore(${uri} - empty: ${!zipBlob}`);\n  return zipBlob;\n}\n\n/**\n * pull repo from zipstore and get the unzipped file\n * @param {string} username\n * @param {string} repository\n * @param {string} branch\n * @param {object} optionalPrefix\n * @return {Promise<[]|null>} resolves to unzipped file if found or null\n */\nasync function getFileFromZip({ username, repository, path, branch }) {\n  // console.log(`getFileFromZip(${username}, ${repository}, ${path}, ${branch})`);\n  let file, zipPath, zip, fileData;\n  const zipBlob = await getZipFromStore(username, repository, branch);\n  try {\n    if (zipBlob) {\n      // console.log(`  Got zipBlob for uri=${uri}`);\n      zip = await JSZip.loadAsync(zipBlob);\n      zipPath = Path.join(repository.toLowerCase(), path);\n      // console.log(`  zipPath=${zipPath}`);\n      fileData = zip.file(zipPath);\n      if (fileData) { // if file was found\n        file = await fileData.async('string');\n        // console.log(`    Got zipBlob ${file.length} bytes`);\n      } else {\n        console.log(`getFileFromZip - file not found for ${username} ${repository} ${encodeURI(path)} ${branch}`);\n        file = null;\n      }\n    }\n    // else console.log(\"  No zipBlob\");\n  } catch (error) {\n    console.error(`getFileFromZip for ${username} ${repository} ${path} ${branch} got: ${error.message}`);\n    file = null;\n  }\n  return file;\n};\n\n\nexport function zipUri({ username, repository, branch = 'master' }) {\n  // console.log(`zipUri(${username}, ${repository}, ${branch})`);\n  const zipPath = Path.join(username, repository, 'archive', `${branch}.zip`);\n  const zipUri = baseURL + zipPath;\n  return zipUri;\n};\n\n\nexport async function fetchTree({ username, repository, sha = 'master' }) {\n  // console.log(`fetchTree(${username}, ${repository}, ${sha})`);\n  let data;\n  try {\n    const uri = Path.join('api/v1/repos', username, repository, 'git/trees', sha);\n    // console.log(`  uri='${uri}'`);\n    data = await cachedGet({ uri });\n    // console.log(`  data (${typeof data})`);\n    return data;\n    // const tree = JSON.parse(data); // RJH: Why was this here???\n    // console.log(`  tree (${typeof tree})`);\n    // return tree;\n  } catch (error) {\n    console.log(`ERROR: fetchTree got: ${error.message}`);\n    console.log(`  Data was: ${JSON.stringify(data)}`);\n    return null;\n  }\n};\n\n\n/*\nasync function recursiveTree({username, repository, path, sha}) {\n  console.log(\"recurse tree args:\",username,repository,path,sha)\n  let tree = {};\n  const pathArray = path.split();\n  const results = fetchTree({username, repository, sha});\n  const result = results.tree.filter(item => item.path === pathArray[0])[0];\n  if (result) {\n    if (result.type === 'tree') {\n      const childPath = pathArray.slice(1).join('/');\n      const children = recursiveTree({username, repository, path: childPath, sha: result.sha});\n      tree[result.path] = children;\n    } else if (result.type === 'blob') {\n      tree[result.path] = true;\n    }\n  }\n};\n\nasync function fileExists({username, repository, path, branch}) {\n  // get root listing\n  recursiveTree()\n  // get recursive path listing\n}\n*/\n","import React from 'react';\r\nimport * as books from './books';\r\nimport {\r\n  cachedGetBookFilenameFromManifest,\r\n  //formRepoName, \r\n  getFileListFromZip,\r\n  getFileCached,\r\n  fetchRepositoryZipFile, getRepoMap\r\n} from './getApi';\r\n\r\nimport {\r\n  checkManifestText,\r\n  checkMarkdownText,\r\n  checkPlainText,\r\n  checkTN_TSVText,\r\n  checkUSFMText,\r\n  checkYAMLText\r\n} from 'uw-content-validation';\r\n\r\n/*\r\n    checkRepo\r\n*/\r\nexport async function checkRepo(username, repoName, branch, givenLocation, setResultValue, checkingOptions) {\r\n  /*\r\n  checkRepo DOES NOT USE the Gitea React Toolkit to fetch the repo\r\n\r\n  It returns an object containing:\r\n      successList: an array of strings to tell the use exactly what has been checked\r\n      noticeList: an array of 9 (i.e., with extra bookOrFileCode parameter at end) notice components\r\n  */\r\n  // console.log(`checkRepo(${username}, ${repoName}, ${branch}, ${givenLocation}, (fn), ${JSON.stringify(checkingOptions)})`);\r\n  const startTime = new Date();\r\n\r\n  const languageCode = repoName.split('_')[0];\r\n  // console.log(\"checkRepo languageCode\", languageCode);\r\n\r\n  if (branch === undefined) branch = 'master'; // Ideally we should ask what the default branch is\r\n\r\n  let checkRepoResult = {\r\n    successList: [], noticeList: [],\r\n    checkedFileCount: 0, checkedFilenames: [], checkedFilenameExtensions: []\r\n  };\r\n\r\n  function addSuccessMessage(successString) {\r\n    // Adds the message to the result that we will later return\r\n    // console.log(`checkRepo success: ${successString}`);\r\n    checkRepoResult.successList.push(successString);\r\n  }\r\n  function addNoticePartial(noticeObject) {\r\n    // Adds the notices to the result that we will later return\r\n    // bookID is a three-character UPPERCASE USFM book identifier or 'OBS'.\r\n    // Note that bookID,C,V might all be empty strings (as some repos don't have BCV)\r\n    // console.log(`checkRepo addNoticePartial: ${noticeObject.priority}:${noticeObject.message} ${noticeObject.bookID} ${noticeObject.C}:${noticeObject.V} ${noticeObject.filename}:${noticeObject.lineNumber} ${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : \"\"}${noticeObject.extract ? ` ${noticeObject.extract}` : \"\"}${noticeObject.location}`);\r\n    console.assert(noticeObject.priority !== undefined, \"cR addNoticePartial: 'priority' parameter should be defined\");\r\n    console.assert(typeof noticeObject.priority === 'number', `cR addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}'`);\r\n    console.assert(noticeObject.message !== undefined, \"cR addNoticePartial: 'message' parameter should be defined\");\r\n    console.assert(typeof noticeObject.message === 'string', `cR addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}'`);\r\n    // console.assert(bookID !== undefined, \"cR addNoticePartial: 'bookID' parameter should be defined\");\r\n    if (noticeObject.bookID) {\r\n      console.assert(typeof noticeObject.bookID === 'string', `cR addNoticePartial: 'bookID' parameter should be a string not a '${typeof noticeObject.bookID}'`);\r\n      console.assert(noticeObject.bookID.length === 3, `cR addNoticePartial: 'bookID' parameter should be three characters long not ${noticeObject.bookID.length}`);\r\n      console.assert(books.isOptionalValidBookID(noticeObject.bookID), `cR addNoticePartial: '${noticeObject.bookID}' is not a valid USFM book identifier`);\r\n    }\r\n    // console.assert(C !== undefined, \"cR addNoticePartial: 'C' parameter should be defined\");\r\n    if (noticeObject.C) console.assert(typeof noticeObject.C === 'string', `cR addNoticePartial: 'C' parameter should be a string not a '${typeof noticeObject.C}'`);\r\n    // console.assert(V !== undefined, \"cR addNoticePartial: 'V' parameter should be defined\");\r\n    if (noticeObject.V) console.assert(typeof noticeObject.V === 'string', `cR addNoticePartial: 'V' parameter should be a string not a '${typeof noticeObject.V}'`);\r\n    // console.assert(characterIndex !== undefined, \"cR addNoticePartial: 'characterIndex' parameter should be defined\");\r\n    if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cR addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}'`);\r\n    // console.assert(extract !== undefined, \"cR addNoticePartial: 'extract' parameter should be defined\");\r\n    if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cR addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}'`);\r\n    console.assert(noticeObject.location !== undefined, \"cR addNoticePartial: 'location' parameter should be defined\");\r\n    console.assert(typeof noticeObject.location === 'string', `cR addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}'`);\r\n    console.assert(noticeObject.extra !== undefined, \"cR addNoticePartial: 'extra' parameter should be defined\");\r\n    console.assert(typeof noticeObject.extra === 'string', `cR addNoticePartial: 'extra' parameter should be a string not a '${typeof noticeObject.extra}'`);\r\n    // Add in the repoName from the outer scope\r\n    checkRepoResult.noticeList.push({ ...noticeObject, repoName });\r\n  }\r\n\r\n\r\n  async function ourCheckRepoFileContents(bookOrFileCode, cfBookID, filename, file_content, fileLocation, optionalCheckingOptions) {\r\n    // We assume that checking for compulsory fields is done elsewhere\r\n    // console.log(`checkRepo ourCheckRepoFileContents(${filename})`);\r\n\r\n    // Updates the global list of notices\r\n    console.assert(bookOrFileCode !== undefined, \"ourCheckRepoFileContents: 'bookOrFileCode' parameter should be defined\");\r\n    console.assert(typeof bookOrFileCode === 'string', `ourCheckRepoFileContents: 'bookOrFileCode' parameter should be a string not a '${typeof bookOrFileCode}'`);\r\n    console.assert(cfBookID !== undefined, \"ourCheckRepoFileContents: 'cfBookID' parameter should be defined\");\r\n    console.assert(typeof cfBookID === 'string', `ourCheckRepoFileContents: 'cfBookID' parameter should be a string not a '${typeof cfBookID}'`);\r\n    console.assert(filename !== undefined, \"ourCheckRepoFileContents: 'filename' parameter should be defined\");\r\n    console.assert(typeof filename === 'string', `ourCheckRepoFileContents: 'filename' parameter should be a string not a '${typeof filename}'`);\r\n    console.assert(file_content !== undefined, \"ourCheckRepoFileContents: 'file_content' parameter should be defined\");\r\n    console.assert(typeof file_content === 'string', `ourCheckRepoFileContents: 'file_content' parameter should be a string not a '${typeof file_content}'`);\r\n    console.assert(fileLocation !== undefined, \"ourCheckRepoFileContents: 'fileLocation' parameter should be defined\");\r\n    console.assert(typeof fileLocation === 'string', `ourCheckRepoFileContents: 'fileLocation' parameter should be a string not a '${typeof fileLocation}'`);\r\n\r\n    const cfcResultObject = await checkFileContents(languageCode, filename, file_content, fileLocation, optionalCheckingOptions);\r\n    // console.log(\"checkFileContents() returned\", resultObject.successList.length, \"success message(s) and\", resultObject.noticeList.length, \"notice(s)\");\r\n    // for (const successEntry of resultObject.successList)\r\n    //     console.log(\"  \", successEntry);\r\n\r\n    // Process results line by line,  appending the bookOrFileCode as an extra field as we go\r\n    for (const cfcNoticeEntry of cfcResultObject.noticeList)\r\n      // We add the bookOrFileCode as an extra value\r\n      addNoticePartial({ ...cfcNoticeEntry, bookID: cfBookID, extra: bookOrFileCode });\r\n  }\r\n  // end of ourCheckRepoFileContents function\r\n\r\n\r\n  // Main code for checkRepo()\r\n  // Put all this in a try/catch block coz otherwise it's difficult to debug/view errors\r\n  try {\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n    // if (ourLocation.indexOf(username) < 0)\r\n    // ourLocation = ` in ${username} ${repoName} ${givenLocation}`\r\n\r\n    // Update our \"waiting\" message\r\n    setResultValue(<p style={{ color: 'magenta' }}>Fetching zipped files from <b>{username}/{repoName}</b> repository</p>);\r\n\r\n    // Let's fetch the zipped repo since it should be much more efficient than individual fetches\r\n    // console.log(`checkRepo: fetch zip file for ${repoName}`);\r\n    const fetchRepositoryZipFile_ = (checkingOptions && checkingOptions.fetchRepositoryZipFile) ? checkingOptions.fetchRepositoryZipFile : fetchRepositoryZipFile;\r\n    const zipFetchSucceeded = await fetchRepositoryZipFile_({ username, repository: repoName, branch });\r\n    if (!zipFetchSucceeded) {\r\n      console.error(`checkRepo: misfetched zip file for repo with ${zipFetchSucceeded}`);\r\n      setResultValue(<p style={{ color: 'red' }}>Failed to fetching zipped files from <b>{username}/{repoName}</b> repository</p>);\r\n      addNoticePartial({ priority: 999, message: \"Failed to find/load repository\", location: ourLocation });\r\n      return checkRepoResult;\r\n    }\r\n\r\n    // Now we need to fetch the list of files from the repo\r\n    setResultValue(<p style={{ color: 'magenta' }}>Preprocessing file list from <b>{username}/{repoName}</b> repository</p>);\r\n    // const pathList = await getFileListFromFetchedTreemaps(username, repoName, branch);\r\n    const getFileListFromZip_ = checkingOptions && checkingOptions.getFileListFromZip ? checkingOptions.getFileListFromZip : getFileListFromZip;\r\n    const pathList = await getFileListFromZip_({ username, repository: repoName, branch });\r\n    // console.log(`Got pathlist (${pathList.length}) = ${pathList}`);\r\n\r\n    // So now we want to work through checking all the files in this repo\r\n    const countString = `${pathList.length.toLocaleString()} file${pathList.length === 1 ? '' : 's'}`;\r\n    let checkedFileCount = 0, checkedFilenames = [], checkedFilenameExtensions = new Set(), totalCheckedSize = 0;\r\n    for (const thisFilepath of pathList) {\r\n      // console.log(`At top of loop: thisFilepath='${thisFilepath}'`);\r\n\r\n      // Update our \"waiting\" message\r\n      setResultValue(<p style={{ color: 'magenta' }}>Checking <b>{username}/{repoName}</b> repo: checked {checkedFileCount.toLocaleString()}/{countString}</p>);\r\n\r\n      const thisFilename = thisFilepath.split('/').pop();\r\n      // console.log(`thisFilename=${thisFilename}`);\r\n      const thisFilenameExtension = thisFilename.split('.').pop();\r\n      // console.log(`thisFilenameExtension=${thisFilenameExtension}`);\r\n\r\n      // Default to the main filename without the extensions\r\n      let bookOrFileCode = thisFilename.substring(0, thisFilename.length - thisFilenameExtension.length - 1);\r\n      let ourBookID = \"\";\r\n      if (thisFilenameExtension === 'usfm') {\r\n        // const filenameMain = thisFilename.substring(0, thisFilename.length - 5); // drop .usfm\r\n        // console.log(`Have USFM filenameMain=${bookOrFileCode}`);\r\n        const bookID = bookOrFileCode.substring(bookOrFileCode.length - 3);\r\n        // console.log(`Have USFM bookcode=${bookID}`);\r\n        console.assert(books.isValidBookID(bookID), `checkRepo: '${bookID}' is not a valid USFM book identifier`);\r\n        bookOrFileCode = bookID;\r\n        ourBookID = bookID;\r\n      }\r\n      else if (thisFilenameExtension === 'tsv') {\r\n        // const filenameMain = thisFilename.substring(0, thisFilename.length - 4); // drop .tsv\r\n        // console.log(`Have TSV filenameMain=${bookOrFileCode}`);\r\n        const bookID = bookOrFileCode.substring(bookOrFileCode.length - 3);\r\n        // console.log(`Have TSV bookcode=${bookID}`);\r\n        console.assert(books.isValidBookID(bookID), `checkRepo: '${bookID}' is not a valid USFM book identifier`);\r\n        bookOrFileCode = bookID;\r\n        ourBookID = bookID;\r\n      }\r\n\r\n      // console.log(\"checkRepo: Try to load\", username, repoName, thisFilepath, branch);\r\n      const getFile_ = (checkingOptions && checkingOptions.getFile) ? checkingOptions.getFile : getFileCached;\r\n      let repoFileContent;\r\n      try {\r\n        repoFileContent = await getFile_({ username, repository: repoName, path: thisFilepath, branch });\r\n        // console.log(\"Fetched file_content for\", repoName, thisPath, typeof repoFileContent, repoFileContent.length);\r\n      } catch (cRgfError) {\r\n        console.error(\"Failed to load\", username, repoName, thisFilepath, branch, `${cRgfError}`);\r\n        addNoticePartial({ priority: 996, message: \"Failed to load\", bookID: ourBookID, filename: thisFilename, location: `${givenLocation} ${thisFilepath}: ${cRgfError}`, extra: repoName });\r\n        return;\r\n      }\r\n      if (repoFileContent) {\r\n        // console.log(`checkRepo for ${repoName} checking ${thisFilename}`);\r\n        await ourCheckRepoFileContents(bookOrFileCode, ourBookID,\r\n          // OBS has many files with the same name, so we have to give some of the path as well\r\n          repoName.endsWith('_obs') ? thisFilepath.replace('content/', '') : thisFilename,\r\n          repoFileContent, ourLocation, checkingOptions);\r\n        checkedFileCount += 1;\r\n        checkedFilenames.push(thisFilename);\r\n        checkedFilenameExtensions.add(thisFilenameExtension);\r\n        totalCheckedSize += repoFileContent.length;\r\n        // console.log(`checkRepo checked ${thisFilename}`);\r\n        if (thisFilenameExtension !== 'md') // There's often far, far too many of these\r\n          addSuccessMessage(`Checked ${bookOrFileCode.toUpperCase()} file: ${thisFilename}`);\r\n      }\r\n    }\r\n\r\n    // Check that we processed a license and a manifest\r\n    if (checkedFilenames.indexOf('LICENSE.md') < 0)\r\n      addNoticePartial({ priority: 946, message: \"Missing LICENSE.md\", location: ourLocation, extra: 'LICENSE' });\r\n    if (checkedFilenames.indexOf('manifest.yaml') < 0)\r\n      addNoticePartial({ priority: 947, message: \"Missing manifest.yaml\", location: ourLocation, extra: 'MANIFEST' });\r\n\r\n    // Add some extra fields to our checkRepoResult object\r\n    //  in case we need this information again later\r\n    checkRepoResult.checkedFileCount = checkedFileCount;\r\n    checkRepoResult.checkedFilenames = checkedFilenames;\r\n    checkRepoResult.checkedFilenameExtensions = [...checkedFilenameExtensions]; // convert Set to Array\r\n    checkRepoResult.checkedFilesizes = totalCheckedSize;\r\n    checkRepoResult.checkedRepoNames = [`${username}/${repoName}`];\r\n    // checkRepoResult.checkedOptions = checkingOptions; // This is done at the caller level\r\n\r\n    addSuccessMessage(`Checked ${username} repo: ${repoName}`);\r\n    // console.log(`checkRepo() is returning ${checkRepoResult.successList.length.toLocaleString()} success message(s) and ${checkRepoResult.noticeList.length.toLocaleString()} notice(s)`);\r\n  } catch (cRerror) {\r\n    console.error(`checkRepo main code block got error: ${cRerror.message}`);\r\n    setResultValue(<>\r\n      <p style={{ color: 'red' }}>checkRepo main code block got error: <b>{cRerror.message}</b></p>\r\n    </>);\r\n\r\n  }\r\n  checkRepoResult.elapsedSeconds = (new Date() - startTime) / 1000; // seconds\r\n  // console.log(`checkRepo() returning ${JSON.stringify(checkRepoResult)}`);\r\n  return checkRepoResult;\r\n};\r\n// end of checkRepo()\r\n\r\n\r\n/*\r\n    checkFileContents\r\n*/\r\nexport async function checkFileContents(languageCode, filename, fileContent, givenLocation, checkingOptions) {\r\n  // Determine the file type from the filename extension\r\n  //  and return the results of checking that kind of file text\r\n  // console.log(`checkFileContents(${languageCode}, ${filename}, ${fileContent.length} chars, ${givenLocation}, ${JSON.stringify(checkingOptions)})`);\r\n  const startTime = new Date();\r\n\r\n  let ourCFLocation = givenLocation;\r\n  if (ourCFLocation[0] !== ' ') ourCFLocation = ' ' + ourCFLocation;\r\n\r\n  let checkFileResult;\r\n  if (filename.toLowerCase().endsWith('.tsv')) {\r\n    const filenameMain = filename.substring(0, filename.length - 4); // drop .tsv\r\n    // console.log(`Have TSV filenameMain=${filenameMain}`);\r\n    const bookID = filenameMain.substring(filenameMain.length - 3);\r\n    // console.log(`Have TSV bookcode=${bookID}`);\r\n    console.assert(books.isValidBookID(bookID), `checkFileContents: '${bookID}' is not a valid USFM book identifier`);\r\n    checkFileResult = await checkTN_TSVText(languageCode, bookID, filename, fileContent, ourCFLocation, checkingOptions);\r\n  }\r\n  else if (filename.toLowerCase().endsWith('.usfm')) {\r\n    const filenameMain = filename.substring(0, filename.length - 5); // drop .usfm\r\n    // console.log(`Have USFM filenameMain=${filenameMain}`);\r\n    const bookID = filenameMain.substring(filenameMain.length - 3);\r\n    // console.log(`Have USFM bookcode=${bookID}`);\r\n    console.assert(books.isValidBookID(bookID), `checkFileContents: '${bookID}' is not a valid USFM book identifier`);\r\n    let repoCode = \"\";\r\n    checkFileResult = checkUSFMText(languageCode, repoCode, bookID, filename, fileContent, ourCFLocation, checkingOptions);\r\n  } else if (filename.toLowerCase().endsWith('.sfm')) {\r\n    const filenameMain = filename.substring(0, filename.length - 4); // drop .sfm\r\n    console.log(`Have SFM filenameMain=${filenameMain}`);\r\n    const bookID = filenameMain.substring(2, 5);\r\n    console.log(`Have SFM bookcode=${bookID}`);\r\n    console.assert(books.isValidBookID(bookID), `checkFileContents: '${bookID}' is not a valid USFM book identifier`);\r\n    checkFileResult = checkUSFMText(languageCode, bookID, filename, fileContent, ourCFLocation, checkingOptions);\r\n  } else if (filename.toLowerCase().endsWith('.md'))\r\n    checkFileResult = checkMarkdownText(languageCode, filename, fileContent, ourCFLocation, checkingOptions);\r\n  else if (filename.toLowerCase().endsWith('.txt'))\r\n    checkFileResult = checkPlainText(filename, fileContent, ourCFLocation, checkingOptions);\r\n  else if (filename.toLowerCase() === 'manifest.yaml')\r\n    checkFileResult = checkManifestText(filename, fileContent, ourCFLocation, checkingOptions);\r\n  else if (filename.toLowerCase().endsWith('.yaml'))\r\n    checkFileResult = checkYAMLText(filename, fileContent, ourCFLocation, checkingOptions);\r\n  else {\r\n    checkFileResult = checkPlainText(filename, fileContent, ourCFLocation, checkingOptions);\r\n    checkFileResult.noticeList.unshift({ priority: 995, message: \"File extension is not recognized, so treated as plain text.\", filename, location: filename });\r\n  }\r\n  // console.log(`checkFileContents got initial results with ${checkFileResult.successList.length} success message(s) and ${checkFileResult.noticeList.length} notice(s)`);\r\n\r\n  // Add some extra fields to our checkFileResult object\r\n  //  in case we need this information again later\r\n  checkFileResult.checkedFileCount = 1;\r\n  checkFileResult.checkedFilename = filename;\r\n  checkFileResult.checkedFilesize = fileContent.length;\r\n  checkFileResult.checkedOptions = checkingOptions;\r\n\r\n  checkFileResult.elapsedSeconds = (new Date() - startTime) / 1000; // seconds\r\n  // console.log(`checkFileContents() returning ${JSON.stringify(checkFileResult)}`);\r\n  return checkFileResult;\r\n};\r\n// end of checkFileContents()\r\n\r\n\r\n/*\r\n    checkTQbook\r\n*/\r\nexport async function checkTQbook(username, languageCode, repoName, branch, bookID, checkingOptions) {\r\n  // console.log(`checkTQbook(${username}, ${repoName}, ${branch}, ${bookID}, ${JSON.stringify(checkingOptions)})`)\r\n  const repoCode = 'TQ';\r\n  const generalLocation = ` in ${username} (${branch})`;\r\n\r\n  const ctqResult = { successList: [], noticeList: [] };\r\n\r\n  function addSuccessMessage(successString) {\r\n    // console.log(`checkBookPackage success: ${successString}`);\r\n    ctqResult.successList.push(successString);\r\n  }\r\n\r\n  function addNoticePartial(noticeObject) {\r\n    // bookID is a three-character UPPERCASE USFM book identifier or 'OBS'.\r\n    // console.log(`checkTQbook addNoticePartial: ${noticeObject.priority}:${noticeObject.message} ${noticeObject.bookID} ${noticeObject.C}:${noticeObject.V} ${noticeObject.filename}:${noticeObject.lineNumber} ${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : \"\"}${noticeObject.extract ? ` ${noticeObject.extract}` : \"\"}${noticeObject.location}`);\r\n    console.assert(noticeObject.priority !== undefined, \"cTQ addNoticePartial: 'priority' parameter should be defined\");\r\n    console.assert(typeof noticeObject.priority === 'number', `cTQ addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}'`);\r\n    console.assert(noticeObject.message !== undefined, \"cTQ addNoticePartial: 'message' parameter should be defined\");\r\n    console.assert(typeof noticeObject.message === 'string', `cTQ addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}'`);\r\n    console.assert(noticeObject.bookID !== undefined, \"cTQ addNoticePartial: 'bookID' parameter should be defined\");\r\n    console.assert(typeof noticeObject.bookID === 'string', `cTQ addNoticePartial: 'bookID' parameter should be a string not a '${typeof noticeObject.bookID}'`);\r\n    console.assert(noticeObject.bookID.length === 3, `cTQ addNoticePartial: 'bookID' parameter should be three characters long not ${noticeObject.bookID.length}`);\r\n    console.assert(books.isValidBookID(noticeObject.bookID), `cTQ addNoticePartial: '${noticeObject.bookID}' is not a valid USFM book identifier`);\r\n    // console.assert(C !== undefined, \"cTQ addNoticePartial: 'C' parameter should be defined\");\r\n    if (noticeObject.C) console.assert(typeof noticeObject.C === 'string', `cTQ addNoticePartial: 'C' parameter should be a string not a '${typeof noticeObject.C}'`);\r\n    // console.assert(V !== undefined, \"cTQ addNoticePartial: 'V' parameter should be defined\");\r\n    if (noticeObject.V) console.assert(typeof noticeObject.V === 'string', `cTQ addNoticePartial: 'V' parameter should be a string not a '${typeof noticeObject.V}'`);\r\n    // console.assert(characterIndex !== undefined, \"cTQ addNoticePartial: 'characterIndex' parameter should be defined\");\r\n    if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cTQ addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}'`);\r\n    // console.assert(extract !== undefined, \"cTQ addNoticePartial: 'extract' parameter should be defined\");\r\n    if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cTQ addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}'`);\r\n    console.assert(noticeObject.location !== undefined, \"cTQ addNoticePartial: 'location' parameter should be defined\");\r\n    console.assert(typeof noticeObject.location === 'string', `cTQ addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}'`);\r\n    console.assert(noticeObject.extra !== undefined, \"cTQ addNoticePartial: 'extra' parameter should be defined\");\r\n    console.assert(typeof noticeObject.extra === 'string', `cTQ addNoticePartial: 'extra' parameter should be a string not a '${typeof noticeObject.extra}'`);\r\n    ctqResult.noticeList.push({ ...noticeObject, repoName, bookID });\r\n  }\r\n\r\n\r\n  async function ourCheckTQFileContents(repoCode, bookID, C, V, cfFilename, file_content, fileLocation, optionalCheckingOptions) {\r\n    // console.log(`checkBookPackage ourCheckTQFileContents(${cfFilename})`);\r\n\r\n    // Updates the global list of notices\r\n    console.assert(repoCode !== undefined, \"cTQ ourCheckTQFileContents: 'repoCode' parameter should be defined\");\r\n    console.assert(typeof repoCode === 'string', `cTQ ourCheckTQFileContents: 'repoCode' parameter should be a string not a '${typeof repoCode}'`);\r\n    console.assert(cfFilename !== undefined, \"cTQ ourCheckTQFileContents: 'cfFilename' parameter should be defined\");\r\n    console.assert(typeof cfFilename === 'string', `cTQ ourCheckTQFileContents: 'cfFilename' parameter should be a string not a '${typeof cfFilename}'`);\r\n    console.assert(file_content !== undefined, \"cTQ ourCheckTQFileContents: 'file_content' parameter should be defined\");\r\n    console.assert(typeof file_content === 'string', `cTQ ourCheckTQFileContents: 'file_content' parameter should be a string not a '${typeof file_content}'`);\r\n    console.assert(fileLocation !== undefined, \"cTQ ourCheckTQFileContents: 'fileLocation' parameter should be defined\");\r\n    console.assert(typeof fileLocation === 'string', `cTQ ourCheckTQFileContents: 'fileLocation' parameter should be a string not a '${typeof fileLocation}'`);\r\n\r\n    const cfResultObject = await checkFileContents(languageCode, cfFilename, file_content, fileLocation, optionalCheckingOptions);\r\n    // console.log(\"checkFileContents() returned\", cfResultObject.successList.length, \"success message(s) and\", cfResultObject.noticeList.length, \"notice(s)\");\r\n    // for (const successEntry of cfResultObject.successList) console.log(\"  ourCheckTQFileContents:\", successEntry);\r\n\r\n    // Process results line by line,  appending the repoCode as an extra field as we go\r\n    for (const noticeEntry of cfResultObject.noticeList) {\r\n      // noticeEntry is an array of eight fields: 1=priority, 2=bookID, 3=C, 4=V, 5=msg, 6=characterIndex, 7=extract, 8=location\r\n      // console.assert(Object.keys(noticeEntry).length === 5, `cTQ ourCheckTQFileContents notice length=${Object.keys(noticeEntry).length}`);\r\n      // We add the repoCode as an extra value\r\n      addNoticePartial({ ...noticeEntry, bookID, C, V, extra: repoCode });\r\n    }\r\n  }\r\n  // end of ourCheckTQFileContents function\r\n\r\n\r\n  // Main code for checkTQbook\r\n  // We need to find an check all the markdown folders/files for this book\r\n  let checkedFileCount = 0, checkedFilenames = [], checkedFilenameExtensions = new Set(['md']), totalCheckedSize = 0;\r\n  const getFileListFromZip_ = checkingOptions && checkingOptions.getFileListFromZip ? checkingOptions.getFileListFromZip : getFileListFromZip;\r\n  const bookIdLc = bookID.toLowerCase();\r\n  let pathList = await getFileListFromZip_({ username, repository: repoName, branch, optionalPrefix: `${bookIdLc}/` });\r\n  if (!Array.isArray(pathList) || !pathList.length) {\r\n    console.error(\"checkTQrepo failed to load\", username, repoName, branch);\r\n    addNoticePartial({ priority: 996, message: \"Failed to load\", bookID, location: generalLocation, extra: repoCode });\r\n  } else {\r\n\r\n    // console.log(`  Got ${pathList.length} pathList entries`)\r\n    for (const thisPath of pathList) {\r\n      // console.log(\"checkTQbook: Try to load\", username, repoName, thisPath, branch);\r\n\r\n      console.assert(thisPath.endsWith('.md'), `Expected ${thisPath} to end with .md`);\r\n      const filename = thisPath.split('/').pop();\r\n      const pathParts = thisPath.slice(0, -3).split('/');\r\n      const C = pathParts[pathParts.length - 2].replace(/^0+(?=\\d)/, ''); // Remove leading zeroes\r\n      const V = pathParts[pathParts.length - 1].replace(/^0+(?=\\d)/, ''); // Remove leading zeroes\r\n\r\n      const getFile_ = (checkingOptions && checkingOptions.getFile) ? checkingOptions.getFile : getFileCached;\r\n      let tqFileContent;\r\n      try {\r\n        tqFileContent = await getFile_({ username, repository: repoName, path: thisPath, branch });\r\n        // console.log(\"Fetched file_content for\", repoName, thisPath, typeof tqFileContent, tqFileContent.length);\r\n        checkedFilenames.push(thisPath);\r\n        totalCheckedSize += tqFileContent.length;\r\n      } catch (tQerror) {\r\n        console.error(\"checkTQbook failed to load\", username, repoName, thisPath, branch, tQerror + '');\r\n        addNoticePartial({ priority: 996, message: \"Failed to load\", bookID, C, V, location: `${generalLocation} ${thisPath}: ${tQerror}`, extra: repoCode });\r\n        continue;\r\n      }\r\n\r\n      // We use the generalLocation here (does not include repo name)\r\n      //  so that we can adjust the returned strings ourselves\r\n      await ourCheckTQFileContents(repoCode, bookID, C, V, filename, tqFileContent, generalLocation, checkingOptions); // Adds the notices to checkBookPackageResult\r\n      checkedFileCount += 1;\r\n      // addSuccessMessage(`Checked ${repoCode.toUpperCase()} file: ${thisPath}`);\r\n    }\r\n    addSuccessMessage(`Checked ${checkedFileCount.toLocaleString()} ${repoCode.toUpperCase()} file${checkedFileCount === 1 ? '' : 's'}`);\r\n  }\r\n\r\n  ctqResult.checkedFileCount = checkedFileCount;\r\n  ctqResult.checkedFilenames = checkedFilenames;\r\n  ctqResult.checkedFilenameExtensions = [...checkedFilenameExtensions]; // convert Set to Array\r\n  ctqResult.checkedFilesizes = totalCheckedSize;\r\n  // console.log(`  checkTQbook returning ${JSON.stringify(ctqResult)}`);\r\n  return ctqResult;\r\n}\r\n// end of checkTQbook function\r\n\r\n\r\n/*\r\n    checkBookPackage\r\n*/\r\n/**\r\n *\r\n * @param {string} username\r\n * @param {string} languageCode\r\n * @param {string} bookID\r\n * @param {Function} setResultValue\r\n * @param {Object} checkingOptions\r\n */\r\nexport async function checkBookPackage(username, languageCode, bookID, setResultValue, checkingOptions) {\r\n  /*\r\n  Note: You may want to run clearCaches() before running this function???\r\n\r\n  Note that bookID here can also be the 'OBS' pseudo bookID.\r\n  */\r\n  // console.log(`checkBookPackage(${username}, ${languageCode}, ${bookID}, , ${JSON.stringify(checkingOptions)})`)\r\n  const startTime = new Date();\r\n  bookID = bookID.toUpperCase(); // normalise to USFM standard\r\n\r\n  let checkBookPackageResult = { successList: [], noticeList: [] };\r\n\r\n  const newCheckingOptions = checkingOptions ? { ...checkingOptions } : {}; // clone before modify\r\n  const getFile_ = newCheckingOptions.getFile ? newCheckingOptions.getFile : getFileCached; // default to using caching of files\r\n  newCheckingOptions.getFile = getFile_; // use same getFile_ when we call core functions\r\n  \r\n  if (!newCheckingOptions.originalLanguageRepoUsername) newCheckingOptions.originalLanguageRepoUsername = username;\r\n  if (!newCheckingOptions.taRepoUsername) newCheckingOptions.taRepoUsername = username;\r\n\r\n  // No point in passing the branch through as a parameter\r\n  //  coz if it's not 'master', it's unlikely to be common for all the repos\r\n  const branch = 'master';\r\n\r\n  //const generalLocation = ` in ${languageCode} ${bookID} book package from ${username} ${branch} branch`;\r\n  const generalLocation = ` in ${languageCode} ${bookID} book package`;\r\n\r\n\r\n  function addSuccessMessage(successString) {\r\n    // console.log(`checkBookPackage success: ${successString}`);\r\n    checkBookPackageResult.successList.push(successString);\r\n  }\r\n\r\n  function addNoticePartial(noticeObject) {\r\n    // bookID is a three-character UPPERCASE USFM book identifier or 'OBS'.\r\n    // console.log(`checkBookPackage addNoticePartial: (priority=${noticeObject.priority}) ${noticeObject.bookID} ${noticeObject.C}:${noticeObject.V} ${noticeObject.message}${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : \"\"}${extract ? ` ${extract}` : \"\"}${location}`);\r\n    console.assert(noticeObject.priority !== undefined, \"cBP addNoticePartial: 'priority' parameter should be defined\");\r\n    console.assert(typeof noticeObject.priority === 'number', `cBP addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}'`);\r\n    console.assert(noticeObject.message !== undefined, \"cBP addNoticePartial: 'message' parameter should be defined\");\r\n    console.assert(typeof noticeObject.message === 'string', `cBP addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}'`);\r\n    // console.assert(bookID !== undefined, \"cBP addNoticePartial: 'bookID' parameter should be defined\");\r\n    if (noticeObject.bookID) {\r\n      console.assert(typeof noticeObject.bookID === 'string', `cBP addNoticePartial: 'bookID' parameter should be a string not a '${typeof noticeObject.bookID}'`);\r\n      console.assert(noticeObject.bookID.length === 3, `cBP addNoticePartial: 'bookID' parameter should be three characters long not ${noticeObject.bookID.length}`);\r\n      console.assert(books.isValidBookID(noticeObject.bookID), `cBP addNoticePartial: '${noticeObject.bookID}' is not a valid USFM book identifier`);\r\n    }\r\n    // console.assert(C !== undefined, \"cBP addNoticePartial: 'C' parameter should be defined\");\r\n    if (noticeObject.C) console.assert(typeof noticeObject.C === 'string', `cBP addNoticePartial: 'C' parameter should be a string not a '${typeof noticeObject.C}'`);\r\n    // console.assert(V !== undefined, \"cBP addNoticePartial: 'V' parameter should be defined\");\r\n    if (noticeObject.V) console.assert(typeof noticeObject.V === 'string', `cBP addNoticePartial: 'V' parameter should be a string not a '${typeof noticeObject.V}'`);\r\n    // console.assert(characterIndex !== undefined, \"cBP addNoticePartial: 'characterIndex' parameter should be defined\");\r\n    if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cBP addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}'`);\r\n    // console.assert(extract !== undefined, \"cBP addNoticePartial: 'extract' parameter should be defined\");\r\n    if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cBP addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}'`);\r\n    console.assert(noticeObject.location !== undefined, \"cBP addNoticePartial: 'location' parameter should be defined\");\r\n    console.assert(typeof noticeObject.location === 'string', `cBP addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}'`);\r\n    console.assert(noticeObject.extra !== undefined, \"cBP addNoticePartial: 'extra' parameter should be defined\");\r\n    console.assert(typeof noticeObject.extra === 'string', `cBP addNoticePartial: 'extra' parameter should be a string not a '${typeof noticeObject.extra}'`);\r\n    checkBookPackageResult.noticeList.push({ ...noticeObject, bookID });\r\n  }\r\n\r\n\r\n  async function ourCheckBPFileContents(repoCode, cfFilename, file_content, fileLocation, optionalCheckingOptions) {\r\n    // console.log(`checkBookPackage ourCheckBPFileContents(${repoCode}, ${cfFilename}, ${file_content.length}, ${fileLocation}, ${JSON.stringify(optionalCheckingOptions)})`);\r\n\r\n    // Updates the global list of notices\r\n    console.assert(repoCode !== undefined, \"cBP ourCheckBPFileContents: 'repoCode' parameter should be defined\");\r\n    console.assert(typeof repoCode === 'string', `cBP ourCheckBPFileContents: 'repoCode' parameter should be a string not a '${typeof repoCode}'`);\r\n    console.assert(cfFilename !== undefined, \"cBP ourCheckBPFileContents: 'cfFilename' parameter should be defined\");\r\n    console.assert(typeof cfFilename === 'string', `cBP ourCheckBPFileContents: 'cfFilename' parameter should be a string not a '${typeof cfFilename}'`);\r\n    console.assert(file_content !== undefined, \"cBP ourCheckBPFileContents: 'file_content' parameter should be defined\");\r\n    console.assert(typeof file_content === 'string', `cBP ourCheckBPFileContents: 'file_content' parameter should be a string not a '${typeof file_content}'`);\r\n    console.assert(fileLocation !== undefined, \"cBP ourCheckBPFileContents: 'fileLocation' parameter should be defined\");\r\n    console.assert(typeof fileLocation === 'string', `cBP ourCheckBPFileContents: 'fileLocation' parameter should be a string not a '${typeof fileLocation}'`);\r\n\r\n    const cfcResultObject = await checkFileContents(languageCode, cfFilename, file_content, fileLocation, optionalCheckingOptions);\r\n    // console.log(\"checkFileContents() returned\", cfResultObject.successList.length, \"success message(s) and\", cfResultObject.noticeList.length, \"notice(s)\");\r\n    // for (const successEntry of cfResultObject.successList) console.log(\"  ourCheckBPFileContents:\", successEntry);\r\n    // console.log(\"cfcResultObject\", JSON.stringify(cfcResultObject));\r\n\r\n    // Process results line by line,  appending the repoCode as an extra field as we go\r\n    for (const cfcNoticeEntry of cfcResultObject.noticeList)\r\n      // noticeEntry is an object\r\n      // We add the repoCode as an extra value\r\n      addNoticePartial({ ...cfcNoticeEntry, filename: cfFilename, extra: repoCode });\r\n  }\r\n  // end of ourCheckBPFileContents function\r\n\r\n\r\n  // Main code for checkBookPackage()\r\n  // console.log(\"checkBookPackage() main code\");\r\n  if (bookID === 'OBS') {\r\n    // We use the generalLocation here (does not include repo name)\r\n    //  so that we can adjust the returned strings ourselves\r\n    // console.log(\"Calling OBS checkRepo()\");\r\n    checkBookPackageResult = await checkRepo(username, `${languageCode}_obs`, branch, generalLocation, setResultValue, newCheckingOptions); // Adds the notices to checkBookPackageResult\r\n    // console.log(`checkRepo() returned ${checkBookPackageResult.successList.length} success message(s) and ${checkBookPackageResult.noticeList.length} notice(s)`);\r\n    // console.log(\"crResultObject keys\", JSON.stringify(Object.keys(checkBookPackageResult)));\r\n\r\n    // Concat is faster if we don't need to process each notice individually\r\n    // checkBookPackageResult.successList = checkBookPackageResult.successList.concat(crResultObject.successList);\r\n    // checkBookPackageResult.noticeList = checkBookPackageResult.noticeList.concat(crResultObject.noticeList);\r\n    // checkedFileCount += crResultObject.fileCount;\r\n    addSuccessMessage(`Checked ${languageCode} OBS repo from ${username}`);\r\n  } else { // not OBS\r\n    // We also need to know the number for USFM books\r\n    let bookNumberAndName, whichTestament;\r\n    try {\r\n      bookNumberAndName = books.usfmNumberNameById(bookID);\r\n      whichTestament = books.testament(bookID); // returns 'old' or 'new'\r\n    } catch (bNNerror) {\r\n      if (books.isValidBookID(bookID)) // must be in FRT, BAK, etc.\r\n        whichTestament = 'other'\r\n      else {\r\n        addNoticePartial({ priority: 902, message: \"Bad function call: should be given a valid book abbreviation\", extract: bookID, location: ` (not '${bookID}')${generalLocation}` }); return checkBookPackageResult;\r\n      }\r\n    }\r\n    // console.log(`checkBookPackage: bookNumberAndName='${bookNumberAndName}' (${whichTestament} testament)`);\r\n\r\n    // So now we want to work through checking this one specified Bible book in various repos:\r\n    //  UHB/UGNT, ULT/GLT, UST/GST, TN, TQ\r\n    const getFile_ = (newCheckingOptions && newCheckingOptions.getFile) ? newCheckingOptions.getFile : getFileCached;\r\n    let checkedFileCount = 0, checkedFilenames = [], checkedFilenameExtensions = new Set(), totalCheckedSize = 0, checkedRepoNames = [];\r\n    const origLang = whichTestament === 'old' ? 'UHB' : 'UGNT';\r\n\r\n    // optionally pass in list of repos to check\r\n    const repoCodeList = (newCheckingOptions && newCheckingOptions.checkRepos) ? newCheckingOptions.checkRepos : [origLang, 'LT', 'ST', 'TN', 'TQ'];\r\n    for (const repoCode of repoCodeList) {\r\n      // consult repo map for org and repo values\r\n      const orgRepo  = getRepoMap()[languageCode][repoCode];\r\n      const orgname  = orgRepo.split('/')[0];\r\n      const repoName = orgRepo.split('/')[1];\r\n\r\n      console.log(`checkBookPackage: check ${bookID} in ${repoCode} (${languageCode} ${bookID} from ${orgname})`);\r\n      const repoLocation = ` in ${repoCode.toUpperCase()}${generalLocation}`;\r\n      //const repoName = formRepoName(languageCode, repoCode);\r\n\r\n      // Update our \"waiting\" message\r\n      //setResultValue(<p style={{ color: 'magenta' }}>Checking {username} {languageCode} <b>{bookID}</b> book package in <b>{repoCode}</b> (checked <b>{checkedRepoNames.length.toLocaleString()}</b>/{repoCodeList.length} repos)</p>);\r\n      setResultValue(<p style={{ color: 'magenta' }}>Checking {orgname} {languageCode} <b>{bookID}</b> book package in <b>{repoCode}</b> (checked <b>{checkedRepoNames.length.toLocaleString()}</b>/{repoCodeList.length} repos)</p>);\r\n\r\n      let filename;\r\n      if (repoCode === 'UHB' || repoCode === 'UGNT' || repoCode === 'LT' || repoCode === 'ST') {\r\n        // TODO: Might we need specific releases/tags for some of these (e.g., from the TN manifest)???\r\n        // TODO: Do we need to hard-code where to find the UHB and UGNT???\r\n        filename = `${bookNumberAndName}.usfm`;\r\n        checkedFilenameExtensions.add('usfm');\r\n      }\r\n      else if (repoCode === 'TN') {\r\n        try {\r\n          filename = await cachedGetBookFilenameFromManifest({ username: orgname, repository: repoName, branch, bookID: bookID.toLowerCase() });\r\n          checkBookPackageResult.tsvFileName = filename;\r\n          //console.assert(filename.startsWith(`${languageCode}_`), `Expected TN filename '${filename}' to start with the language code '${languageCode}_'`);\r\n        } catch (e) {\r\n          console.error(`cachedGetBookFilenameFromManifest failed with: ${e}`);\r\n          filename = `${languageCode}_tn_${bookNumberAndName}.tsv`;\r\n        }\r\n        console.assert(filename.endsWith('.tsv'), `Expected TN filename '${filename}' to end with '.tsv'`);\r\n        checkedFilenameExtensions.add('tsv');\r\n      }\r\n\r\n      if (repoCode === 'TQ') {\r\n        // This resource might eventually be converted to TSV tables\r\n        const tqResultObject = await checkTQbook(orgname, languageCode, repoName, branch, bookID, newCheckingOptions);\r\n        checkBookPackageResult.successList = checkBookPackageResult.successList.concat(tqResultObject.successList);\r\n        checkBookPackageResult.noticeList = checkBookPackageResult.noticeList.concat(tqResultObject.noticeList);\r\n        checkedFilenames = checkedFilenames.concat(tqResultObject.checkedFilenames);\r\n        checkedFilenameExtensions = new Set([...checkedFilenameExtensions, ...tqResultObject.checkedFilenameExtensions]);\r\n        checkedFileCount += tqResultObject.checkedFileCount;\r\n        totalCheckedSize += tqResultObject.totalCheckedSize;\r\n        checkedRepoNames.push(repoCode);\r\n      } else { // For repos other than TQ, we only have one file to check\r\n        // console.log(\"Try to load\", username, repoName, filename, branch);\r\n        let repoFileContent;\r\n        try {\r\n          // console.log(\"checkBookPackage about to fetch file_content for\", username, repoName, branch, filename);\r\n          repoFileContent = await getFile_({ username: orgname, repository: repoName, path: filename, branch });\r\n          // console.log(\"checkBookPackage fetched file_content for\", username, repoName, branch, filename, typeof repoFileContent, repoFileContent.length);\r\n          checkedFilenames.push(filename);\r\n          totalCheckedSize += repoFileContent.length;\r\n          checkedRepoNames.push(repoCode);\r\n        } catch (cBPgfError) {\r\n          console.error(\"Failed to load\", orgname, repoName, filename, branch, cBPgfError + '');\r\n          addNoticePartial({ priority: 996, message: \"Failed to load\", repoName, filename, location: `${repoLocation}: ${cBPgfError}`, extra: repoCode });\r\n          continue;\r\n        }\r\n\r\n        // We use the generalLocation here (does not include repo name)\r\n        //  so that we can adjust the returned strings ourselves\r\n        newCheckingOptions.originalLanguageRepoUsername = orgname;\r\n        newCheckingOptions.taRepoUsername = getRepoMap()[languageCode].TA.split('/')[0]\r\n        await ourCheckBPFileContents(repoCode, filename, repoFileContent, generalLocation, newCheckingOptions); // Adds the notices to checkBookPackageResult\r\n        checkedFileCount += 1;\r\n        addSuccessMessage(`Checked ${repoCode.toUpperCase()} file: ${filename}`);\r\n      }\r\n    }\r\n\r\n    // Add some extra fields to our checkFileResult object\r\n    //  in case we need this information again later\r\n    checkBookPackageResult.checkedFileCount = checkedFileCount;\r\n    checkBookPackageResult.checkedFilenames = checkedFilenames;\r\n    checkBookPackageResult.checkedFilenameExtensions = [...checkedFilenameExtensions]; // convert Set to Array\r\n    checkBookPackageResult.checkedFilesizes = totalCheckedSize;\r\n    checkBookPackageResult.checkedRepoNames = checkedRepoNames;\r\n    // checkBookPackageResult.checkedOptions = newCheckingOptions; // This is done at the caller level\r\n  }\r\n\r\n  checkBookPackageResult.elapsedSeconds = (new Date() - startTime) / 1000; // seconds\r\n  // console.log(\"checkBookPackageResult:\", JSON.stringify(checkBookPackageResult));\r\n  console.log(`checkBookPackageResult(${bookID}): elapsedSeconds = ${checkBookPackageResult.elapsedSeconds}, notices count = ${checkBookPackageResult.noticeList.length}`);\r\n  return checkBookPackageResult;\r\n};\r\n// end of checkBookPackage()\r\n","// utilities\r\nimport * as books from 'uw-content-validation';\r\nimport { formRepoName, getOverridesForRepo } from \"./getApi\";\r\n\r\n// function to convert an array to an object\r\n// with keys being 0..n\r\nexport const array_to_obj = ( (ar: any) => {\r\n    const ob = {};\r\n    Object.assign(ob,ar);\r\n    return ob;\r\n});\r\n\r\n// function to convert map to object\r\nexport const map_to_obj = ( (mp: any[]) => {\r\n    const ob: any = {};\r\n    mp.forEach((v: any,k: any) => {ob[k]=v});\r\n    return ob;\r\n});\r\n\r\n// function to convert object to a map\r\nexport const obj_to_map = ( (ob: { [x: string]: any; }) => {\r\n    const mp = new Map();\r\n    Object.keys ( ob ).forEach (k => { mp.set(k, ob[k]) });\r\n    return mp;\r\n});\r\n\r\n\r\ninterface ObjectLiteral {\r\n    [key: string]: any;\r\n}\r\n\r\n/**\r\n * make sure references are a minimum of 2 digits, if not do zero padding\r\n * @param reference\r\n * @return reference with zero padding\r\n */\r\nexport const padRef2 = (reference: string) => {\r\n    if (reference) {\r\n        if (reference.length < 2) {\r\n            reference = '0' + reference;\r\n        }\r\n    }\r\n    return reference\r\n}\r\n\r\n/**\r\n * create link to repo\r\n * @param repoType\r\n * @param username\r\n * @param languageCode\r\n * @param bookID\r\n * @param lineNum\r\n * @param rawData\r\n * @param branch\r\n */\r\nexport const getLink = (repoType: string, username: string, languageCode: string, bookID: string, lineNum: string,\r\n                        rowData: { [x: string]: any; }, rawData: { [x: string]: any; }, branch = `master`) => {\r\n    const repoName = formRepoName(languageCode, repoType);\r\n    let extension = 'usfm';\r\n    let view = 'src';\r\n    let fileName;\r\n    try {\r\n        fileName = books.usfmNumberName(bookID).toUpperCase();\r\n    } catch (e) {}\r\n    let repoTypeUC = repoType.toUpperCase();\r\n    if (repoTypeUC === 'TN') {\r\n        view = 'blame';\r\n        extension = 'tsv';\r\n        if (rawData.tsvFileName) {\r\n          fileName = rawData.tsvFileName.split(\".tsv\")[0]; // remove the extension\r\n        } else {\r\n          fileName = `${repoName}_${fileName}`;\r\n        }\r\n        //         bookNumberAndName = await cachedGetBookFilenameFromManifest({ username, repository: repoName, branch, bookID: bookID.toLowerCase() });\r\n    } else if (repoTypeUC === 'TQ') {\r\n        extension = 'md';\r\n        fileName = `${bookID}/${padRef2(rowData.C)}/${padRef2(rowData.V)}`;\r\n    }\r\n    const { username: username_, repoName: repoName_ } = getOverridesForRepo(username, repoName);\r\n    if (['TN', 'TQ', 'UHB', 'UGNT', 'ULT', 'UST', 'LT', 'ST'].includes(repoTypeUC)) {\r\n\r\n            let link = `https://git.door43.org/${username_}/${repoName_}/${view}/branch/${branch}/${fileName}.${extension}`;\r\n            if (lineNum) {\r\n                link += `#L${lineNum}`;\r\n            }\r\n            return link;\r\n            // const anchor = `<a href=\"${link}\" target=\"_blank\">${lineNum}</a>`;\r\n            // return anchor;\r\n\r\n    }\r\n    console.log(`getLink() - could not find link for repo type ${repoType} for ${languageCode}`);\r\n    return null;\r\n}\r\n\r\n/**\r\n * remove columns that don't have any data\r\n * @param rows\r\n * @param columns\r\n */\r\nexport const trimColumns = (rows: any[], columns: any[]) => {\r\n    const newColumns = [];\r\n    for (let column of columns) {\r\n        const { field, title } = column;\r\n        let hasData = false;\r\n\r\n        for (let row of rows) {\r\n            const cellData = row[field]\r\n            if (cellData) {\r\n                hasData = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (hasData) {\r\n            newColumns.push(column);\r\n        } else {\r\n            console.log(`Removing column \"${title}\" because no data found`);\r\n        }\r\n    }\r\n    return newColumns;\r\n}\r\n\r\n/**\r\n * converts strings to numbers\r\n * @param value\r\n */\r\nexport const stringToNumber = (value: any) => {\r\n    if (typeof value === 'string') {\r\n        const num = parseInt(value, 10);\r\n        if (!isNaN(num)) {\r\n            return num;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\n\r\n/**\r\n * string compare that attempts to do numerical sorting fist and then will sort by string\r\n * @param a\r\n * @param b\r\n */\r\nexport const somewhatNumericalSort = (a: any, b: any) => {\r\n    const aNum = stringToNumber(a);\r\n    const bNum = stringToNumber(b);\r\n    const aStr = a || \"\";\r\n    const bStr = b || \"\";\r\n\r\n    if (!isNaN(aNum) && !isNaN(bNum)) { // if both are numbers then do numerical compare\r\n        return aNum - bNum;\r\n    }\r\n\r\n    if (isNaN(aNum) && isNaN(bNum)) { // if both are not numbers then do a string compare\r\n        return aStr > bStr ? 1 : ( aStr === bStr ? 0 : -1);\r\n    }\r\n\r\n    if (isNaN(aNum)) {\r\n        return -1;  // non-numeric strings less than numbers\r\n    }\r\n    return 1;\r\n}\r\n\r\n/**\r\n * sort by chapter first and then by verse if same chapter\r\n * @param a\r\n * @param b\r\n */\r\nexport const sortChapterVerse = (a: any, b: any) => {\r\n    let results = somewhatNumericalSort(a.C, b.C);\r\n    if (results === 0) { // if chapters are same, then sort on verse\r\n        results = somewhatNumericalSort(a.V, b.V);\r\n    }\r\n    return results;\r\n}\r\n\r\n/* Sample of Warnings List:\r\n    C: \"1\"\r\n    V: \"1\"\r\n    bookID: \"2PE\"\r\n    characterIndex: undefined\r\n    extract: undefined\r\n    lineNumber: 4\r\n    location: \" with ID 'n1di' en 2pe book package from unfoldingword\"\r\n    message: \"TN Missing OrigQuote field\"\r\n    priority: 276\r\n*/\r\n// function to convert word frequency map\r\n// to an object suitable for MaterialTable\r\nexport const notices_to_mt = ( ob: { [x: string]: any; }, username: string, languageCode: string, bookID: string,\r\n    renderLink: any, renderWithUnicodeLink: any, renderPriority: any,\r\n    rawData: { [x: string]: any; }) =>\r\n{\r\n    let mt: ObjectLiteral = {};\r\n    mt.title = \"Validation Notices\";\r\n    mt.columns = [\r\n        { title: 'Repo', field: 'extra' },\r\n        {\r\n            title: 'Pri',\r\n            field: 'priority',\r\n            render: (rowData: any) => (renderPriority(rowData.priority))\r\n        },\r\n        {\r\n            title: 'Ch',\r\n            field: 'C',\r\n            customSort: (a: any, b: any) => sortChapterVerse(a, b)\r\n        },\r\n        {\r\n            title: 'Vs',\r\n            field: 'V',\r\n            customSort: (a: any, b: any) => somewhatNumericalSort(a.V, b.V)\r\n        },\r\n        {\r\n            title: 'Line',\r\n            field: 'lineNumber',\r\n            render: (rowData: any) => (renderLink(rowData.link, rowData.lineNumber))\r\n        },\r\n        { title: 'Row ID', field: 'rowID' },\r\n        { title: 'Field Name', field: 'fieldName' },\r\n        { title: 'Details', field: 'details' },\r\n        { title: 'Char Pos', field: 'charPos' },\r\n        {\r\n            title: 'Excerpt',\r\n            field: 'excerpt',\r\n            cellStyle: {\r\n                fontFamily: \"Ezra, Roboto, Helvetica, Arial, sans-serif\"\r\n            },\r\n            render: (rowData: any) => (renderWithUnicodeLink(rowData.excerpt))\r\n        },\r\n        {\r\n            title: 'Message',\r\n            field: 'message',\r\n            cellStyle: {\r\n                fontFamily: \"Ezra, Roboto, Helvetica, Arial, sans-serif\",\r\n                width: `400px`\r\n            },\r\n        },\r\n        { title: 'Location', field: 'location' },\r\n    ];\r\n    mt.data = [];\r\n    Object.keys(ob).forEach ( key => {\r\n        const rowData = ob[key];\r\n        let _location = rowData.location;\r\n        _location = _location.replace(/en ... book package from unfoldingword/, '' );\r\n        let _link = getLink(rowData.extra, username, languageCode, bookID, rowData.lineNumber, rowData, rawData);\r\n        mt.data.push({\r\n            extra: rowData.extra,\r\n            priority: rowData.priority,\r\n            C: rowData.C,\r\n            V: rowData.V,\r\n            lineNumber: rowData.lineNumber,\r\n            rowID: rowData.rowID,\r\n            charPos: rowData.characterIndex,\r\n            excerpt: rowData.extract,\r\n            link: _link,\r\n            location: _location,\r\n            message: rowData.message,\r\n            fieldName: rowData.fieldName,\r\n            details: rowData.details,\r\n        })\r\n    })\r\n\r\n    // @ts-ignore\r\n    mt.data = mt.data.sort((a: object, b: object) => (a.priority > b.priority ? -1 : 1) ); // sort highest priority to the top of the table\r\n\r\n    mt.columns = trimColumns(mt.data, mt.columns);\r\n\r\n    mt.options = {\r\n        sorting: true,\r\n        // padding: 'dense',\r\n        exportButton: true,\r\n        exportAllData: true,\r\n        // tableLayout: 'auto',\r\n        columnsButton: true,\r\n        filtering: true,\r\n        pageSize: 10,\r\n    };\r\n\r\n    return mt;\r\n};\r\n\r\n","import React from 'react';\r\nimport { forwardRef } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport { withStyles } from '@material-ui/core/styles';\r\n\r\nimport AddBox from '@material-ui/icons/AddBox';\r\nimport ArrowDownward from '@material-ui/icons/ArrowDownward';\r\nimport Check from '@material-ui/icons/Check';\r\nimport ChevronLeft from '@material-ui/icons/ChevronLeft';\r\nimport ChevronRight from '@material-ui/icons/ChevronRight';\r\nimport Clear from '@material-ui/icons/Clear';\r\nimport DeleteOutline from '@material-ui/icons/DeleteOutline';\r\nimport Edit from '@material-ui/icons/Edit';\r\nimport FilterList from '@material-ui/icons/FilterList';\r\nimport FirstPage from '@material-ui/icons/FirstPage';\r\nimport LastPage from '@material-ui/icons/LastPage';\r\nimport Remove from '@material-ui/icons/Remove';\r\nimport SaveAlt from '@material-ui/icons/SaveAlt';\r\nimport Search from '@material-ui/icons/Search';\r\nimport ViewColumn from '@material-ui/icons/ViewColumn';\r\n\r\nimport MaterialTable from 'material-table';\r\nimport * as util from './core/utilities.ts';\r\n\r\nconst tableIcons = {\r\n  Add: forwardRef((props, ref) => <AddBox {...props} ref={ref} />),\r\n  Check: forwardRef((props, ref) => <Check {...props} ref={ref} />),\r\n  Clear: forwardRef((props, ref) => <Clear {...props} ref={ref} />),\r\n  Delete: forwardRef((props, ref) => <DeleteOutline {...props} ref={ref} />),\r\n  DetailPanel: forwardRef((props, ref) => <ChevronRight {...props} ref={ref} />),\r\n  Edit: forwardRef((props, ref) => <Edit {...props} ref={ref} />),\r\n  Export: forwardRef((props, ref) => <SaveAlt {...props} ref={ref} />),\r\n  Filter: forwardRef((props, ref) => <FilterList {...props} ref={ref} />),\r\n  FirstPage: forwardRef((props, ref) => <FirstPage {...props} ref={ref} />),\r\n  LastPage: forwardRef((props, ref) => <LastPage {...props} ref={ref} />),\r\n  NextPage: forwardRef((props, ref) => <ChevronRight {...props} ref={ref} />),\r\n  PreviousPage: forwardRef((props, ref) => <ChevronLeft {...props} ref={ref} />),\r\n  ResetSearch: forwardRef((props, ref) => <Clear {...props} ref={ref} />),\r\n  Search: forwardRef((props, ref) => <Search {...props} ref={ref} />),\r\n  SortArrow: forwardRef((props, ref) => <ArrowDownward {...props} ref={ref} />),\r\n  ThirdStateCheck: forwardRef((props, ref) => <Remove {...props} ref={ref} />),\r\n  ViewColumn: forwardRef((props, ref) => <ViewColumn {...props} ref={ref} />)\r\n};\r\n\r\n/**\r\n * Colorized priority according to severity of notice\r\n * @param content\r\n * @return {JSX.Element|string}\r\n */\r\nexport const renderPriority = (content) => {\r\n  // breaking changes: 800 and above\r\n  if ( content >= 800 ) {\r\n      return <p style={{ color: 'red', fontWeight: 'bold' }}>{content}</p>;\r\n  }\r\n\r\n  // non-breaking changes: 600 to 799\r\n  if ( content >= 600 ) {\r\n    return <p style={{ color: 'blue', fontWeight: 'bold' }}>{content}</p>\r\n  }\r\n\r\n  // below 600 are warnings\r\n  return <p style={{ color: 'green', fontWeight: 'bold' }}>{content}</p>;\r\n}\r\n\r\n/**\r\n * creates a link to external URL\r\n * @param link\r\n * @param content\r\n * @return {JSX.Element|string}\r\n */\r\nexport const renderLink = (link, content) => {\r\n  if (link) {\r\n    return <a href={link} target=\"_blank\" rel=\"noopener noreferrer\">{content}</a>\r\n  } else if (content) {\r\n    return `${content}`\r\n  }\r\n  return \"\";\r\n}\r\n\r\n/**\r\n * replaces unicode references with link to webpage describing the character\r\n * @param content\r\n * @return {JSX.Element|string}\r\n */\r\nexport const renderWithUnicodeLink = (content) => {\r\n  if ( !content ) {\r\n    return \"\";\r\n  }\r\n  // find unicode refs that look like '( =D8288/H2060)'\r\n  const getUnicodeRegEx = new RegExp(/=D(\\d+)\\/H(\\w+)\\)/, 'g');\r\n  let match;\r\n  let lastPos = 0;\r\n  const output = [];\r\n  // eslint-disable-next-line no-cond-assign\r\n  while (match = getUnicodeRegEx.exec(content)) {\r\n    if (match.index > 0) {\r\n      output.push(content.substring(lastPos, match.index));\r\n    }\r\n    let matchLen = match[0].length;\r\n    const unicode = match[2];\r\n    output.push (\r\n      <a href={`http://www.fileformat.info/info/unicode/char/${unicode}/index.htm`} target=\"_blank\" rel=\"noopener noreferrer\">U+{unicode}</a>\r\n    )\r\n    lastPos = match.index + matchLen - 1; // update start position\r\n  }\r\n  if (lastPos < content.length) {\r\n    output.push(content.substring(lastPos, content.length));\r\n  }\r\n\r\n  // assemble all the strings and anchors into one segment\r\n  return <> {output} </>\r\n};\r\n\r\nfunction ValidationWarnings({\r\n    results,\r\n    username,\r\n    languageCode,\r\n    bookID,\r\n    rawData\r\n  }) {\r\n\r\n    let mt = util.notices_to_mt(results, username, languageCode, bookID, renderLink, renderWithUnicodeLink, renderPriority, rawData);\r\n    return (\r\n      <Paper>\r\n        <MaterialTable\r\n          icons={tableIcons}\r\n          title={mt.title}\r\n          columns={mt.columns}\r\n          data={mt.data}\r\n          options={mt.options}\r\n        />\r\n      </Paper>\r\n    );\r\n  };\r\n\r\n  ValidationWarnings.propTypes = {\r\n    /** @ignore */\r\n    results: PropTypes.array.isRequired,\r\n  };\r\n\r\n  const styles = theme => ({\r\n    root: {\r\n    },\r\n  });\r\n\r\n  export default withStyles(styles)(ValidationWarnings);\r\n\r\n","import React, { useState, useEffect } from 'react';\r\nimport { Typography } from '@material-ui/core';\r\n\r\nimport { checkBookPackage } from './core/book-package-check';\r\nimport ValidationNotices from './ValidationNotices';\r\nimport { fetchRepositoryZipFile, getFileCached, getFileListFromZip } from \"./core/getApi\";\r\n\r\nfunction BookPackageContentValidator({bookID, username, language_code}) {\r\n    //const username = 'unfoldingword';\r\n    //const language_code = 'en';\r\n    //const branch = 'master';\r\n    // Check a single Bible book across many repositories\r\n    const [result, setResultValue] = useState(\"Waiting-CheckBookPackage\");\r\n\r\n    const checkingOptions = {\r\n      getFile: getFileCached,\r\n      fetchRepositoryZipFile: fetchRepositoryZipFile,\r\n      getFileListFromZip: getFileListFromZip,\r\n      taRepoUsername: username\r\n    };\r\n\r\n    useEffect(() => {\r\n        // Use an IIFE (Immediately Invoked Function Expression)\r\n        //  e.g., see https://medium.com/javascript-in-plain-english/https-medium-com-javascript-in-plain-english-stop-feeling-iffy-about-using-an-iife-7b0292aba174\r\n        (async () => {\r\n\r\n            // Display our \"waiting\" message\r\n            setResultValue(<p style={{ color: 'red' }}>Waiting for check results for {username} {language_code} <b>{bookID}</b> book package</p>);\r\n\r\n            const rawCBPResults = await checkBookPackage(username, language_code, bookID, setResultValue, checkingOptions);\r\n            //console.log(\"rawCBPResults=\", rawCBPResults);\r\n            // Add some extra fields to our rawCBPResults object in case we need this information again later\r\n            rawCBPResults.checkType = 'BookPackage';\r\n            rawCBPResults.username = username;\r\n            rawCBPResults.language_code = language_code;\r\n            rawCBPResults.bookID = bookID;\r\n            rawCBPResults.checkedOptions = checkingOptions;\r\n\r\n            function renderSummary(rawCBPResults) {\r\n                return (\r\n                    <>\r\n                    <Typography>\r\n                        Successfully checked&nbsp;\r\n                        {rawCBPResults.checkedFileCount.toLocaleString()}&nbsp;\r\n                        files in&nbsp;\r\n                        {rawCBPResults.elapsedSeconds}&nbsp;\r\n                        seconds\r\n                    </Typography>\r\n                    <Typography>\r\n                        There were {rawCBPResults.noticeList.length} notices.\r\n                    </Typography>\r\n                </>\r\n            );\r\n            }\r\n\r\n            setResultValue(<>\r\n                {renderSummary(rawCBPResults)}\r\n                {rawCBPResults.noticeList.length ?\r\n                  <ValidationNotices\r\n                    results={rawCBPResults.noticeList}\r\n                    username={username}\r\n                    languageCode={language_code}\r\n                    bookID={bookID}\r\n                    rawData={rawCBPResults}\r\n                  />\r\n                : <br/> }\r\n            </>);\r\n\r\n        })(); // end of async part in unnamedFunction\r\n        // eslint-disable-next-line\r\n    }, []); // end of useEffect part\r\n\r\n    // {/* <div className={classes.root}> */}\r\n    return (\r\n        <div>\r\n        {result}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default BookPackageContentValidator;\r\n","import React from 'react';\r\nimport { forwardRef } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport { withStyles } from '@material-ui/core/styles';\r\n\r\nimport AddBox from '@material-ui/icons/AddBox';\r\nimport ArrowDownward from '@material-ui/icons/ArrowDownward';\r\nimport Check from '@material-ui/icons/Check';\r\nimport ChevronLeft from '@material-ui/icons/ChevronLeft';\r\nimport ChevronRight from '@material-ui/icons/ChevronRight';\r\nimport Clear from '@material-ui/icons/Clear';\r\nimport DeleteOutline from '@material-ui/icons/DeleteOutline';\r\nimport Edit from '@material-ui/icons/Edit';\r\nimport FilterList from '@material-ui/icons/FilterList';\r\nimport FirstPage from '@material-ui/icons/FirstPage';\r\nimport LastPage from '@material-ui/icons/LastPage';\r\nimport Remove from '@material-ui/icons/Remove';\r\nimport SaveAlt from '@material-ui/icons/SaveAlt';\r\nimport Search from '@material-ui/icons/Search';\r\nimport ViewColumn from '@material-ui/icons/ViewColumn';\r\n\r\nimport MaterialTable from 'material-table';\r\n//import localforage from 'localforage';\r\nimport useEffect from 'use-deep-compare-effect';\r\n\r\n\r\nimport * as getApi from './core/getApi';\r\n\r\nconst tableIcons = {\r\n  Add: forwardRef((props, ref) => <AddBox {...props} ref={ref} />),\r\n  Check: forwardRef((props, ref) => <Check {...props} ref={ref} />),\r\n  Clear: forwardRef((props, ref) => <Clear {...props} ref={ref} />),\r\n  Delete: forwardRef((props, ref) => <DeleteOutline {...props} ref={ref} />),\r\n  DetailPanel: forwardRef((props, ref) => <ChevronRight {...props} ref={ref} />),\r\n  Edit: forwardRef((props, ref) => <Edit {...props} ref={ref} />),\r\n  Export: forwardRef((props, ref) => <SaveAlt {...props} ref={ref} />),\r\n  Filter: forwardRef((props, ref) => <FilterList {...props} ref={ref} />),\r\n  FirstPage: forwardRef((props, ref) => <FirstPage {...props} ref={ref} />),\r\n  LastPage: forwardRef((props, ref) => <LastPage {...props} ref={ref} />),\r\n  NextPage: forwardRef((props, ref) => <ChevronRight {...props} ref={ref} />),\r\n  PreviousPage: forwardRef((props, ref) => <ChevronLeft {...props} ref={ref} />),\r\n  ResetSearch: forwardRef((props, ref) => <Clear {...props} ref={ref} />),\r\n  Search: forwardRef((props, ref) => <Search {...props} ref={ref} />),\r\n  SortArrow: forwardRef((props, ref) => <ArrowDownward {...props} ref={ref} />),\r\n  ThirdStateCheck: forwardRef((props, ref) => <Remove {...props} ref={ref} />),\r\n  ViewColumn: forwardRef((props, ref) => <ViewColumn {...props} ref={ref} />)\r\n};\r\n\r\n\r\n\r\nfunction RepoValidation({\r\n    results,\r\n}) \r\n{\r\n    // define the table\r\n    const columns = [\r\n        { title: 'Resource Type', field: 'repoType', editable: 'never' },\r\n        { title: 'Lang', field: 'lang', hidden: true },\r\n        { title: 'Org', field: 'org' },\r\n        { title: 'Repo', field: 'repo' },\r\n        { title: 'Message', field: 'message', editable: 'never', \r\n            cellStyle: {\r\n                fontFamily: \"Ezra, Roboto, Helvetica, Arial, sans-serif\",\r\n                width: `400px`\r\n            },\r\n        },\r\n    ];\r\n    // create a state to persist table data and update it when necessary\r\n    const [data, setData] = React.useState([]);\r\n\r\n    const repoVisual = (\r\n        <Paper>\r\n        <MaterialTable\r\n            icons={tableIcons}\r\n            title=\"Repo Validation\"\r\n            columns={columns}\r\n            data={data}\r\n            options={ {pageSize: 7} }\r\n            cellEditable={{\r\n                onCellEditApproved: (newValue, oldValue, rowData, columnDef) => {\r\n                    console.log(\"onCellEditApproved()\", newValue, oldValue, rowData, columnDef);\r\n                    return new Promise((resolve, reject) => {\r\n                    let _data = data;\r\n                    // first find the matching row\r\n                    for (let i=0; i<_data.length; i++) {\r\n                        if ( _data[i].repoType === rowData.repoType &&\r\n                             _data[i].org      === rowData.org &&\r\n                             _data[i].repo     === rowData.repo \r\n                        ) {\r\n                            if ( columnDef.field === 'repo' ) {\r\n                                _data[i].repo = newValue;\r\n                            } else if ( columnDef.field === 'org' ) {\r\n                                _data[i].org  = newValue;\r\n                            }\r\n                            getApi.setPathForRepo(_data[i].lang, _data[i].repoType, _data[i].org, _data[i].repo);\r\n                            let errors = [];\r\n                            getApi.verifyRepo(_data[i].org,_data[i].repo,errors,_data[i].repoType,_data[i].lang)\r\n                            .then((errors) => {\r\n                                _data[i].message = errors[0].message;\r\n                                results[i].message = errors[0].message;\r\n                                results[i].repository = errors[0].repository;\r\n                                results[i].username = errors[0].username;\r\n                                setData(_data);\r\n                            });\r\n                            break;\r\n                        }\r\n                    }\r\n                    setTimeout(resolve, 1000);\r\n                  });\r\n                }\r\n              }}      \r\n        />\r\n        </Paper>\r\n    );\r\n\r\n    useEffect( () => {\r\n        let _data = [];\r\n        for (let i=0; i<results.length; i++) {\r\n            _data.push({\r\n                repoType: results[i].repoType,\r\n                lang: results[i].language,\r\n                org: results[i].username,\r\n                repo: results[i].repository,\r\n                message: results[i].message,\r\n            });\r\n        }\r\n        setData(_data);\r\n    }, [results]);\r\n\r\n    return repoVisual;\r\n};\r\n\r\nRepoValidation.propTypes = {\r\n/** @ignore */\r\nresults: PropTypes.array.isRequired,\r\n};\r\n\r\nconst styles = theme => ({\r\n    root: {\r\n    },\r\n});\r\n\r\nexport default withStyles(styles)(RepoValidation);\r\n\r\n","import React from 'react';\nimport clsx from 'clsx';\nimport { makeStyles, useTheme, Theme, createStyles } from '@material-ui/core/styles';\nimport Paper from '@material-ui/core/Paper';\nimport Stepper from '@material-ui/core/Stepper';\nimport Step from '@material-ui/core/Step';\nimport StepLabel from '@material-ui/core/StepLabel';\nimport Button from '@material-ui/core/Button';\nimport Typography from '@material-ui/core/Typography';\n\nimport FormLabel from '@material-ui/core/FormLabel';\nimport FormControl from '@material-ui/core/FormControl';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport FormHelperText from '@material-ui/core/FormHelperText';\nimport Checkbox from '@material-ui/core/Checkbox';\n\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport IconButton from '@material-ui/core/IconButton';\nimport MenuIcon from '@material-ui/icons/Menu';\nimport Drawer from '@material-ui/core/Drawer';\nimport Divider from '@material-ui/core/Divider';\nimport ChevronLeftIcon from '@material-ui/icons/ChevronLeft';\nimport ChevronRightIcon from '@material-ui/icons/ChevronRight';\n\nimport * as books from '../src/core/books';\nimport { Container, CssBaseline, Grid, RadioGroup, Radio, CircularProgress } from '@material-ui/core';\n\nimport BookPackageContentValidator from './BookPackageContentValidator';\nimport { clearCaches, PreLoadRepos, verifyReposForLanguages } from './core/getApi';\nimport RepoValidation from './RepoValidation';\n\n// stores repo validation results for each language index by language\nconst languagesValidationResults: { [x: string]: any; } = {};\n\nasync function doInitialization() {\n    //const username = 'unfoldingword';\n    //const language_code = 'en';\n    console.log(\"doInitialization()\");\n    const branch = 'master'\n    await clearCaches();\n\n    // TODO: may need to add prompting for paths, may want to remove this if language list gets too big\n    verifyReposForLanguages('unfoldingword', ['TA', 'TW', 'TN', 'TQ', 'ST', 'LT'], languagesValidationResults).then(() => {\n        if (!languagesValidationResults.success) {\n            console.error(\"Repo verification error - could not find these repos:\", languagesValidationResults);\n        } else {\n            console.log(\"Repo verification - all repos found\");\n        }\n    });\n\n    const success = await PreLoadRepos('unfoldingword', '', branch, [], true);\n    if (!success) {\n        console.log(`Failed to pre-load original language repos`);\n    }\n}\n\nasync function doLanguageInitialization(username: string,language_code: string) {\n    console.log(\"doLanguageInitialization() username, lang:\", username, language_code);\n    const branch = 'master'\n    const success = await PreLoadRepos(username, language_code, branch, ['TA', 'TW', 'TN', 'TQ'], false, true);\n    if (!success) {\n        console.log(`Failed to pre-load all repos`)\n    }\n}\n\nconst drawerWidth = 240;\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      width: '100%',\n      flexGrow: 1,\n      display: 'flex',\n    },\n    menuButton: {\n      marginRight: theme.spacing(2),\n    },\n    appBar: {\n      transition: theme.transitions.create(['margin', 'width'], {\n        easing: theme.transitions.easing.sharp,\n        duration: theme.transitions.duration.leavingScreen,\n      }),\n    },\n    appBarShift: {\n      width: `calc(100% - ${drawerWidth}px)`,\n      marginLeft: drawerWidth,\n      transition: theme.transitions.create(['margin', 'width'], {\n        easing: theme.transitions.easing.easeOut,\n        duration: theme.transitions.duration.enteringScreen,\n      }),\n    },\n    title: {\n      flexGrow: 1,\n    },\n    formControl: {\n      margin: theme.spacing(3),\n    },\n    button: {\n      marginRight: theme.spacing(1),\n    },\n    instructions: {\n      marginTop: theme.spacing(1),\n      marginBottom: theme.spacing(1),\n    },\n    hide: {\n      display: 'none',\n    },\n    drawer: {\n      width: drawerWidth,\n      flexShrink: 0,\n    },\n    drawerPaper: {\n      width: drawerWidth,\n    },\n    drawerHeader: {\n      display: 'flex',\n      alignItems: 'center',\n      padding: theme.spacing(0, 1),\n      ...theme.mixins.toolbar,\n      justifyContent: 'flex-end',\n    },\n    content: {\n      flexGrow: 1,\n      padding: theme.spacing(3),\n      transition: theme.transitions.create('margin', {\n        easing: theme.transitions.easing.sharp,\n        duration: theme.transitions.duration.leavingScreen,\n      }),\n      marginLeft: -drawerWidth,\n    },\n    contentShift: {\n      transition: theme.transitions.create('margin', {\n        easing: theme.transitions.easing.easeOut,\n        duration: theme.transitions.duration.enteringScreen,\n      }),\n      marginLeft: 0,\n    },\n    alignItemsAndJustifyContent: {\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n    },\n    offset: {...theme.mixins.toolbar},\n  }),\n);\n\ninterface bpStateIF { [x: string]: boolean[]; };\n\nfunction joinBookIds(state: bpStateIF ): string[] {\n  const x = Object.keys(state);\n  let y: string[] = [];\n  for (let i=0; i<x.length; i++) {\n    if ( state[x[i]][0] ) {\n      y.push(books.bookIdByTitle(x[i]));\n    }\n  }\n  return y;\n}\n\n\nfunction getSteps() {\n  return ['Select Organization and Language', 'Repo Validation', 'Select Books', 'Content Validation Details'];\n}\n\nfunction getStepContent(step: number) {\n  switch (step) {\n    case 0:\n      return 'Select Organization and Language';\n    case 1:\n      return 'Repo Validation';\n    case 2:\n      return 'Select books, then click Next to generate book package details';\n    case 3:\n      return 'Content Validation Results';\n    default:\n      return 'Unknown step';\n  }\n}\n\n// A custom hook that builds on useLocation to parse\n// the query string for you.\nlet queryProcessedOnce = false;\nfunction useQuery() {\n  let search = window.location.search;\n  //console.log(\"url=\",window.location.origin,window.location.pathname)\n  return new URLSearchParams(search);\n}\n\nexport default function App() {\n  const [state, setState] = React.useState({ ...books.titlesToBoolean() });\n  const [activeStep, setActiveStep] = React.useState(0);\n  const [skipped, setSkipped] = React.useState(new Set<number>());\n  const [org, setOrg]   = React.useState('unfoldingword');\n  const [lang, setLang] = React.useState('en');\n  const [repoValidation, setRepoValidation] = React.useState(<CircularProgress/>)\n  React.useEffect( () => {\n    if (activeStep !== 1) {return;}\n    if ( languagesValidationResults.finished ) {\n      setRepoValidation( <RepoValidation results={languagesValidationResults[lang].errors} /> );\n    } else {\n      setRepoValidation(<CircularProgress/>);\n    }\n  }, [lang, activeStep]); \n\n  /* ----------------------------------------------------------\n      Prefetch the orginal languages, which are in\n      org=unfoldingword and lang is ignored; since they are\n      in a fixed location.\n  */\n  //console.log(\"Prefetching Original Language Repos!\");\n  //clearCacheAndPreloadRepos('unfoldingword', 'en', ['rut','jud'], 'master', []);\n\n  /* ----------------------------------------------------------\n      Stepper\n  */\n  const steps = getSteps();\n\n  const isStepOptional = (step: number) => {\n    return false;\n  };\n\n  const isStepSkipped = (step: number) => {\n    return skipped.has(step);\n  };\n\n\n  const handleBack = () => {\n    setActiveStep(prevActiveStep => prevActiveStep - 1);\n  };\n\n  const handleSkip = () => {\n    if (!isStepOptional(activeStep)) {\n      // You probably want to guard against something like this,\n      // it should never occur unless someone's actively trying to break something.\n      throw new Error(\"You can't skip a step that isn't optional.\");\n    }\n\n    setActiveStep(prevActiveStep => prevActiveStep + 1);\n    setSkipped(prevSkipped => {\n      const newSkipped = new Set(prevSkipped.values());\n      newSkipped.add(activeStep);\n      return newSkipped;\n    });\n  };\n\n  const handleNext = () => {\n    let newSkipped = skipped;\n    if (isStepSkipped(activeStep)) {\n      newSkipped = new Set(newSkipped.values());\n      newSkipped.delete(activeStep);\n    }\n    if ( activeStep === 0 ) {\n      // time to preload cache!\n      doLanguageInitialization(org, lang);\n    }\n\n    // TODO: need to add step for validation\n    if ( activeStep === 1 ) {\n      // in case they updated the org or repo values, just run again\n      // if no changes then it will be quick\n      doLanguageInitialization(org, lang);\n      /*\n      const languageValidation = languagesValidationResults[lang];\n      if (languageValidation && languageValidation.finished) {\n          console.log(`Validation for '${lang}' completed before going to book selection`, languageValidation);\n          if (languageValidation.errors.length) {\n              console.log(`missing repos for '${lang}'!`, languageValidation.errors);\n          }\n      } else {\n          console.log(`Validation for '${lang}' did not complete before going to book selection`);\n      }\n      */\n    }\n    setActiveStep(prevActiveStep => prevActiveStep + 1);\n    setSkipped(newSkipped);\n  };\n\n  let query = useQuery();\n  if ( activeStep === 0 && queryProcessedOnce === false ) {\n    doInitialization();\n    queryProcessedOnce = true;\n    let bks   = query.get(\"books\");\n    if ( bks !== null ) {\n      // user has launched the app with URL query parameters\n      let barrayIds = bks.split(',');\n      let barrayTitles: string[] = [];\n      for ( let i=0; i < barrayIds.length; i++ ) {\n        let x = books.bookTitleById(barrayIds[i]);\n        if ( x === \"\" ) {\n          alert(\"Invalid Book Id:\"+barrayIds[i]);\n          break;\n        }\n        barrayTitles.push(x);\n      }\n      for( let i=0; i < barrayTitles.length; i++) {\n        let name = barrayTitles[i];\n        console.log(\"name:\",name)\n        // set the state variables\n        state[name][0] = true;\n        state[name][1] = false;\n        let b: boolean[] = [];\n        b[0] = true;\n        b[1] = false;\n      }\n      handleNext();\n    }\n  }\n\n\n  const classes = useStyles();\n  const theme = useTheme();\n\n  /* ----------------------------------------------------------\n      Menu drawer\n  */\n  const [open, setOpen] = React.useState(false);\n\n  const handleDrawerOpen = () => {\n    setOpen(true);\n  };\n\n  const handleDrawerClose = () => {\n    setOpen(false);\n  };\n\n  const handleSelectNoneOt = () => {\n    let states = books.oldTestament();\n    for( let i=0; i < states.length; i++) {\n      state[states[i]][0] = false;\n      state[states[i]][1] = false;\n      let name = states[i];\n      let b: boolean[] = [];\n      b[0] = false;\n      b[1] = false;\n      setState({ ...state, [name]: b });\n    }\n  };\n\n  const handleSelectAllOt = () => {\n    let states = books.oldTestament();\n    for( let i=0; i < states.length; i++) {\n      state[states[i]][0] = true;\n      state[states[i]][1] = false;\n      let name = states[i];\n      let b: boolean[] = [];\n      b[0] = true;\n      b[1] = false;\n      setState({ ...state, [name]: b });\n    }\n  };\n\n  const handleSelectNoneNt = () => {\n    let states = books.newTestament();\n    for( let i=0; i < states.length; i++) {\n      state[states[i]][0] = false;\n      state[states[i]][1] = false;\n      let name = states[i];\n      let b: boolean[] = [];\n      b[0] = false;\n      b[1] = false;\n      setState({ ...state, [name]: b });\n    }\n  };\n\n  const handleSelectAllNt = () => {\n    let states = books.newTestament();\n    for( let i=0; i < states.length; i++) {\n      state[states[i]][0] = true;\n      state[states[i]][1] = false;\n      let name = states[i];\n      let b: boolean[] = [];\n      b[0] = true;\n      b[1] = false;\n      setState({ ...state, [name]: b });\n    }\n  };\n\n\n  /* ----------------------------------------------------------\n      Form/checkbox stuff\n  */\n  // these are for the initial book selection\n  const handleChange = (name: string) => (event: React.ChangeEvent<HTMLInputElement>) => {\n    let b: boolean[] = [];\n    b[0] = event.target.checked;\n    b[1] = false;\n    setState({ ...state, [name]: b });\n  };\n\n  /* as of 2020-09-21:\n  The languages/orgs are:\n    Russian (RU)/ru_gl\n    Hindi (HI)/translationCore-Create-BCS\n    Kannada (KN)/translationCore-Create-BCS\n    Latin-American Spanish (ES-419)/Es-419_gl\n  */\n  const handleOrgLangChange = () => (event: React.ChangeEvent<HTMLInputElement>) => {\n    let val = (event.target as HTMLInputElement).value;\n    let org  = 'unfoldingword';\n    let lang = 'en';\n    if ( val === 'ru' ) {\n      org  = 'ru_gl';\n      lang = 'ru';\n    } else if ( val === 'hi' ) {\n      org  = 'translationCore-Create-BCS';\n      lang = 'hi';\n    } else if ( val === 'kn' ) {\n      org  = 'translationCore-Create-BCS';\n      lang = 'kn';\n    } else if ( val === 'es-419' ) {\n      org = 'Es-419_gl';\n      lang = 'es-419';\n    }\n    setOrg(org);\n    setLang(lang);\n  };\n\n  return (\n    <div className={classes.root}>\n      <CssBaseline />\n      <AppBar position=\"fixed\"\n          className={clsx(classes.appBar, {[classes.appBarShift]: open })}>\n        <Toolbar>\n          <IconButton\n            color=\"inherit\"\n            aria-label=\"open drawer\"\n            onClick={handleDrawerOpen}\n            edge=\"start\"\n            className={clsx(classes.menuButton, open && classes.hide)}\n          >\n            <MenuIcon />\n          </IconButton>\n          <Typography variant=\"h6\" className={classes.title}>\n            Book Package Content Validation\n          </Typography>\n        </Toolbar>\n      </AppBar>\n      <Drawer\n        className={classes.drawer}\n        variant=\"persistent\"\n        anchor=\"left\"\n        open={open}\n        classes={{\n          paper: classes.drawerPaper,\n        }}\n      >\n        <div className={classes.drawerHeader}>\n          <IconButton onClick={handleDrawerClose}>\n            {theme.direction === 'ltr' ? <ChevronLeftIcon /> : <ChevronRightIcon />}\n          </IconButton>\n        </div>\n        <Divider />\n          <Typography>Nothing here to see!</Typography>\n        <Divider />\n      </Drawer>\n      <Paper>\n        <Typography> <br/> <br/> </Typography>\n        <Stepper activeStep={activeStep}>\n          {steps.map((label, index) => {\n            const stepProps: { completed?: boolean } = {};\n            const labelProps: { optional?: React.ReactNode } = {};\n            if (isStepOptional(index)) {\n              labelProps.optional = <Typography variant=\"caption\">Optional</Typography>;\n            }\n            if (isStepSkipped(index)) {\n              stepProps.completed = false;\n            }\n            return (\n              <Step key={label} {...stepProps}>\n                <StepLabel {...labelProps}>{label}</StepLabel>\n              </Step>\n            );\n          })}\n        </Stepper>\n        <Container>\n          <div className={classes.alignItemsAndJustifyContent}>\n          <Typography className={classes.instructions}>{getStepContent(activeStep)}</Typography>\n          </div>\n\n          <div className={classes.alignItemsAndJustifyContent}>\n            <Button disabled={activeStep === 0} onClick={handleBack} color=\"primary\" variant=\"contained\" className={classes.button}>\n              Back\n            </Button>\n\n            {isStepOptional(activeStep) && (\n              <Button variant=\"contained\" color=\"primary\" onClick={handleSkip} className={classes.button}>\n                Skip\n              </Button>\n            )}\n\n            <Button disabled={activeStep === 3} variant=\"contained\" color=\"primary\" onClick={handleNext} className={classes.button}>\n              Next\n            </Button>\n\n          </div>\n\n          <div className={classes.alignItemsAndJustifyContent}>\n\n          {(activeStep === 0) && (\n              <>\n              <div>\n                <Paper>\n                  <FormControl component=\"fieldset\">\n                    <FormLabel component=\"legend\">Languages</FormLabel>\n                    <RadioGroup aria-label=\"orgLang\" name=\"orgLang\" value={lang} onChange={handleOrgLangChange()}>\n                      <FormControlLabel value=\"en\" control={<Radio />} label=\"English (unfoldingWord)\" />\n                      <FormControlLabel value=\"ru\" control={<Radio />} label=\"Russian (ru_gl)\" />\n                      <FormControlLabel value=\"hi\" control={<Radio />} label=\"Hindi (translationCore-Create-BCS)\" />\n                      <FormControlLabel value=\"kn\" control={<Radio />} label=\"Kannada (translationCore-Create-BCS)\" />\n                      <FormControlLabel value=\"es-419\" control={<Radio />} label=\"Latin-American Spanish (Es-419_gl)\" />\n                    </RadioGroup>\n                  </FormControl>\n                </Paper>\n              </div>\n              </>\n            )}\n\n            {(activeStep === 1) && (\n              <Paper>{repoValidation}</Paper>\n            )}\n\n            {(activeStep === 2) && (\n              <Grid container spacing={3}>\n                <Grid item xs={6}>\n                  <Paper>\n                    <Typography> <br/> </Typography>\n                    <div>\n                    <Button onClick={handleSelectAllOt} color=\"primary\" variant=\"contained\" className={classes.button}>\n                      Select All\n                    </Button>\n                    <Button onClick={handleSelectNoneOt} color=\"primary\" variant=\"contained\" className={classes.button}>\n                      Select None\n                    </Button>\n                    </div>\n                    <FormControl required component=\"fieldset\" className={classes.formControl}>\n                    <FormLabel component=\"legend\">Old Testament</FormLabel>\n                    <FormGroup>\n                      {books.oldTestament().map(t =>\n                        <FormControlLabel\n                          control={<Checkbox checked={state[t][0]} onChange={handleChange(t)} value={t} />}\n                          label={t} key={t}\n                        />\n                      )}\n                    </FormGroup>\n                    <FormHelperText />\n                    </FormControl>\n                  </Paper>\n                </Grid>\n                <Grid item xs={6}>\n                  <Paper>\n                    <Typography> <br/> </Typography>\n                    <div>\n                    <Button onClick={handleSelectAllNt} color=\"primary\" variant=\"contained\" className={classes.button}>\n                      Select All\n                    </Button>\n                    <Button onClick={handleSelectNoneNt} color=\"primary\" variant=\"contained\" className={classes.button}>\n                      Select None\n                    </Button>\n                    </div>\n\n                    <FormControl required component=\"fieldset\" className={classes.formControl}>\n                    <FormLabel component=\"legend\">New Testament</FormLabel>\n                    <FormGroup>\n                      {books.newTestament().map(t =>\n                        <FormControlLabel\n                          control={<Checkbox checked={state[t][0]} onChange={handleChange(t)} value={t} />}\n                          label={t} key={t}\n                        />\n                      )}\n                    </FormGroup>\n                    <FormHelperText />\n                    </FormControl>\n                  </Paper>\n                </Grid>\n              </Grid>\n            )}\n\n\n            {(activeStep === 3) && (\n              <>\n              <div>\n                <Paper>\n                {\n                  joinBookIds(state).map(id =>\n                    <div id={id} >\n                    <Typography variant=\"h6\" >Book Package for {books.bookTitleById(id)} </Typography>\n                    <BookPackageContentValidator bookID={id} key={id} username={org} language_code={lang} />\n                    </div>\n                  ) \n                }\n                </Paper>\n              </div>\n              </>\n            )}\n\n\n          </div>\n        </Container>\n      </Paper>\n    </div>\n  );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport './fonts/SILEOTSR.ttf';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","export const BibleBookData = { \"gen\": {\"id\": \"gen\", \"title\": \"Genesis\", \"usfm\": \"01-GEN\", \"testament\": \"old\", \"verseCount\": 1533, \"chapters\": [31, 25, 24, 26, 32, 22, 24, 22, 29, 32, 32, 20, 18, 24, 21, 16, 27, 33, 38, 18, 34, 24, 20, 67, 34, 35, 46, 22, 35, 43, 55, 32, 20, 31, 29, 43, 36, 30, 23, 23, 57, 38, 34, 34, 28, 34, 31, 22, 33, 26]},\r\n\"exo\": {\"id\": \"exo\", \"title\": \"Exodus\", \"usfm\": \"02-EXO\", \"testament\": \"old\", \"verseCount\": 1213, \"chapters\": [22, 25, 22, 31, 23, 30, 25, 32, 35, 29, 10, 51, 22, 31, 27, 36, 16, 27, 25, 26, 36, 31, 33, 18, 40, 37, 21, 43, 46, 38, 18, 35, 23, 35, 35, 38, 29, 31, 43, 38]},\r\n\"lev\": {\"id\": \"lev\", \"title\": \"Leviticus\", \"usfm\": \"03-LEV\", \"testament\": \"old\", \"verseCount\": 859, \"chapters\": [17, 16, 17, 35, 19, 30, 38, 36, 24, 20, 47, 8, 59, 57, 33, 34, 16, 30, 37, 27, 24, 33, 44, 23, 55, 46, 34]},\r\n\"num\": {\"id\": \"num\", \"title\": \"Numbers\", \"usfm\": \"04-NUM\", \"testament\": \"old\", \"verseCount\": 1288, \"chapters\": [54, 34, 51, 49, 31, 27, 89, 26, 23, 36, 35, 16, 33, 45, 41, 50, 13, 32, 22, 29, 35, 41, 30, 25, 18, 65, 23, 31, 40, 16, 54, 42, 56, 29, 34, 13]},\r\n\"deu\": {\"id\": \"deu\", \"title\": \"Deuteronomy\", \"usfm\": \"05-DEU\", \"testament\": \"old\", \"verseCount\": 959, \"chapters\": [46, 37, 29, 49, 33, 25, 26, 20, 29, 22, 32, 32, 18, 29, 23, 22, 20, 22, 21, 20, 23, 30, 25, 22, 19, 19, 26, 68, 29, 20, 30, 52, 29, 12]},\r\n\"jos\": {\"id\": \"jos\", \"title\": \"Joshua\", \"usfm\": \"06-JOS\", \"testament\": \"old\", \"verseCount\": 658, \"chapters\": [18, 24, 17, 24, 15, 27, 26, 35, 27, 43, 23, 24, 33, 15, 63, 10, 18, 28, 51, 9, 45, 34, 16, 33]},\r\n\"jdg\": {\"id\": \"jdg\", \"title\": \"Judges\", \"usfm\": \"07-JDG\", \"testament\": \"old\", \"verseCount\": 618, \"chapters\": [36, 23, 31, 24, 31, 40, 25, 35, 57, 18, 40, 15, 25, 20, 20, 31, 13, 31, 30, 48, 25]},\r\n\"rut\": {\"id\": \"rut\", \"title\": \"Ruth\", \"usfm\": \"08-RUT\", \"testament\": \"old\", \"verseCount\": 85, \"chapters\": [22, 23, 18, 22]},\r\n\"1sa\": {\"id\": \"1sa\", \"title\": \"1 Samuel\", \"usfm\": \"09-1SA\", \"testament\": \"old\", \"verseCount\": 810, \"chapters\": [28, 36, 21, 22, 12, 21, 17, 22, 27, 27, 15, 25, 23, 52, 35, 23, 58, 30, 24, 42, 15, 23, 29, 22, 44, 25, 12, 25, 11, 31, 13]},\r\n\"2sa\": {\"id\": \"2sa\", \"title\": \"2 Samuel\", \"usfm\": \"10-2SA\", \"testament\": \"old\", \"verseCount\": 695, \"chapters\": [27, 32, 39, 12, 25, 23, 29, 18, 13, 19, 27, 31, 39, 33, 37, 23, 29, 33, 43, 26, 22, 51, 39, 25]},\r\n\"1ki\": {\"id\": \"1ki\", \"title\": \"1 Kings\", \"usfm\": \"11-1KI\", \"testament\": \"old\", \"verseCount\": 816, \"chapters\": [53, 46, 28, 34, 18, 38, 51, 66, 28, 29, 43, 33, 34, 31, 34, 34, 24, 46, 21, 43, 29, 53]},\r\n\"2ki\": {\"id\": \"2ki\", \"title\": \"2 Kings\", \"usfm\": \"12-2KI\", \"testament\": \"old\", \"verseCount\": 719, \"chapters\": [18, 25, 27, 44, 27, 33, 20, 29, 37, 36, 21, 21, 25, 29, 38, 20, 41, 37, 37, 21, 26, 20, 37, 20, 30]},\r\n\"1ch\": {\"id\": \"1ch\", \"title\": \"1 Chronicles\", \"usfm\": \"13-1CH\", \"testament\": \"old\", \"verseCount\": 942, \"chapters\": [54, 55, 24, 43, 26, 81, 40, 40, 44, 14, 47, 40, 14, 17, 29, 43, 27, 17, 19, 8, 30, 19, 32, 31, 31, 32, 34, 21, 30]},\r\n\"2ch\": {\"id\": \"2ch\", \"title\": \"2 Chronicles\", \"usfm\": \"14-2CH\", \"testament\": \"old\", \"verseCount\": 822, \"chapters\": [17, 18, 17, 22, 14, 42, 22, 18, 31, 19, 23, 16, 22, 15, 19, 14, 19, 34, 11, 37, 20, 12, 21, 27, 28, 23, 9, 27, 36, 27, 21, 33, 25, 33, 27, 23]},\r\n\"ezr\": {\"id\": \"ezr\", \"title\": \"Ezra\", \"usfm\": \"15-EZR\", \"testament\": \"old\", \"verseCount\": 280, \"chapters\": [11, 70, 13, 24, 17, 22, 28, 36, 15, 44]},\r\n\"neh\": {\"id\": \"neh\", \"title\": \"Nehemiah\", \"usfm\": \"16-NEH\", \"testament\": \"old\", \"verseCount\": 406, \"chapters\": [11, 20, 32, 23, 19, 19, 73, 18, 38, 39, 36, 47, 31]},\r\n\"est\": {\"id\": \"est\", \"title\": \"Esther\", \"usfm\": \"17-EST\", \"testament\": \"old\", \"verseCount\": 167, \"chapters\": [22, 23, 15, 17, 14, 14, 10, 17, 32, 3]},\r\n\"job\": {\"id\": \"job\", \"title\": \"Job\", \"usfm\": \"18-JOB\", \"testament\": \"old\", \"verseCount\": 1070, \"chapters\": [22, 13, 26, 21, 27, 30, 21, 22, 35, 22, 20, 25, 28, 22, 35, 22, 16, 21, 29, 29, 34, 30, 17, 25, 6, 14, 23, 28, 25, 31, 40, 22, 33, 37, 16, 33, 24, 41, 30, 24, 34, 17]},\r\n\"psa\": {\"id\": \"psa\", \"title\": \"Psalms\", \"usfm\": \"19-PSA\", \"testament\": \"old\", \"verseCount\": 2461, \"chapters\": [6, 12, 8, 8, 12, 10, 17, 9, 20, 18, 7, 8, 6, 7, 5, 11, 15, 50, 14, 9, 13, 31, 6, 10, 22, 12, 14, 9, 11, 12, 24, 11, 22, 22, 28, 12, 40, 22, 13, 17, 13, 11, 5, 26, 17, 11, 9, 14, 20, 23, 19, 9, 6, 7, 23, 13, 11, 11, 17, 12, 8, 12, 11, 10, 13, 20, 7, 35, 36, 5, 24, 20, 28, 23, 10, 12, 20, 72, 13, 19, 16, 8, 18, 12, 13, 17, 7, 18, 52, 17, 16, 15, 5, 23, 11, 13, 12, 9, 9, 5, 8, 28, 22, 35, 45, 48, 43, 13, 31, 7, 10, 10, 9, 8, 18, 19, 2, 29, 176, 7, 8, 9, 4, 8, 5, 6, 5, 6, 8, 8, 3, 18, 3, 3, 21, 26, 9, 8, 24, 13, 10, 7, 12, 15, 21, 10, 20, 14, 9, 6]},\r\n\"pro\": {\"id\": \"pro\", \"title\": \"Proverbs\", \"usfm\": \"20-PRO\", \"testament\": \"old\", \"verseCount\": 915, \"chapters\": [33, 22, 35, 27, 23, 35, 27, 36, 18, 32, 31, 28, 25, 35, 33, 33, 28, 24, 29, 30, 31, 29, 35, 34, 28, 28, 27, 28, 27, 33, 31]},\r\n\"ecc\": {\"id\": \"ecc\", \"title\": \"Ecclesiastes\", \"usfm\": \"21-ECC\", \"testament\": \"old\", \"verseCount\": 222, \"chapters\": [18, 26, 22, 16, 20, 12, 29, 17, 18, 20, 10, 14]},\r\n\"sng\": {\"id\": \"sng\", \"title\": \"Song of Songs\", \"usfm\": \"22-SNG\", \"testament\": \"old\", \"verseCount\": 117, \"chapters\": [17, 17, 11, 16, 16, 13, 13, 14]},\r\n\"isa\": {\"id\": \"isa\", \"title\": \"Isaiah\", \"usfm\": \"23-ISA\", \"testament\": \"old\", \"verseCount\": 1292, \"chapters\": [31, 22, 26, 6, 30, 13, 25, 22, 21, 34, 16, 6, 22, 32, 9, 14, 14, 7, 25, 6, 17, 25, 18, 23, 12, 21, 13, 29, 24, 33, 9, 20, 24, 17, 10, 22, 38, 22, 8, 31, 29, 25, 28, 28, 25, 13, 15, 22, 26, 11, 23, 15, 12, 17, 13, 12, 21, 14, 21, 22, 11, 12, 19, 12, 25, 24]},\r\n\"jer\": {\"id\": \"jer\", \"title\": \"Jeremiah\", \"usfm\": \"24-JER\", \"testament\": \"old\", \"verseCount\": 1364, \"chapters\": [19, 37, 25, 31, 31, 30, 34, 22, 26, 25, 23, 17, 27, 22, 21, 21, 27, 23, 15, 18, 14, 30, 40, 10, 38, 24, 22, 17, 32, 24, 40, 44, 26, 22, 19, 32, 21, 28, 18, 16, 18, 22, 13, 30, 5, 28, 7, 47, 39, 46, 64, 34]},\r\n\"lam\": {\"id\": \"lam\", \"title\": \"Lamentations\", \"usfm\": \"25-LAM\", \"testament\": \"old\", \"verseCount\": 154, \"chapters\": [22, 22, 66, 22, 22]},\r\n\"ezk\": {\"id\": \"ezk\", \"title\": \"Ezekiel\", \"usfm\": \"26-EZK\", \"testament\": \"old\", \"verseCount\": 1273, \"chapters\": [28, 10, 27, 17, 17, 14, 27, 18, 11, 22, 25, 28, 23, 23, 8, 63, 24, 32, 14, 49, 32, 31, 49, 27, 17, 21, 36, 26, 21, 26, 18, 32, 33, 31, 15, 38, 28, 23, 29, 49, 26, 20, 27, 31, 25, 24, 23, 35]},\r\n\"dan\": {\"id\": \"dan\", \"title\": \"Daniel\", \"usfm\": \"27-DAN\", \"testament\": \"old\", \"verseCount\": 357, \"chapters\": [21, 49, 30, 37, 31, 28, 28, 27, 27, 21, 45, 13]},\r\n\"hos\": {\"id\": \"hos\", \"title\": \"Hosea\", \"usfm\": \"28-HOS\", \"testament\": \"old\", \"verseCount\": 197, \"chapters\": [11, 23, 5, 19, 15, 11, 16, 14, 17, 15, 12, 14, 16, 9]},\r\n\"jol\": {\"id\": \"jol\", \"title\": \"Joel\", \"usfm\": \"29-JOL\", \"testament\": \"old\", \"verseCount\": 73, \"chapters\": [20, 32, 21]},\r\n\"amo\": {\"id\": \"amo\", \"title\": \"Amos\", \"usfm\": \"30-AMO\", \"testament\": \"old\", \"verseCount\": 146, \"chapters\": [15, 16, 15, 13, 27, 14, 17, 14, 15]},\r\n\"oba\": {\"id\": \"oba\", \"title\": \"Obadiah\", \"usfm\": \"31-OBA\", \"testament\": \"old\", \"verseCount\": 21, \"chapters\": [21]},\r\n\"jon\": {\"id\": \"jon\", \"title\": \"Jonah\", \"usfm\": \"32-JON\", \"testament\": \"old\", \"verseCount\": 48, \"chapters\": [17, 10, 10, 11]},\r\n\"mic\": {\"id\": \"mic\", \"title\": \"Micah\", \"usfm\": \"33-MIC\", \"testament\": \"old\", \"verseCount\": 105, \"chapters\": [16, 13, 12, 13, 15, 16, 20]},\r\n\"nam\": {\"id\": \"nam\", \"title\": \"Nahum\", \"usfm\": \"34-NAM\", \"testament\": \"old\", \"verseCount\": 47, \"chapters\": [15, 13, 19]},\r\n\"hab\": {\"id\": \"hab\", \"title\": \"Habakkuk\", \"usfm\": \"35-HAB\", \"testament\": \"old\", \"verseCount\": 56, \"chapters\": [17, 20, 19]},\r\n\"zep\": {\"id\": \"zep\", \"title\": \"Zephaniah\", \"usfm\": \"36-ZEP\", \"testament\": \"old\", \"verseCount\": 53, \"chapters\": [18, 15, 20]},\r\n\"hag\": {\"id\": \"hag\", \"title\": \"Haggai\", \"usfm\": \"37-HAG\", \"testament\": \"old\", \"verseCount\": 38, \"chapters\": [15, 23]},\r\n\"zec\": {\"id\": \"zec\", \"title\": \"Zechariah\", \"usfm\": \"38-ZEC\", \"testament\": \"old\", \"verseCount\": 211, \"chapters\": [21, 13, 10, 14, 11, 15, 14, 23, 17, 12, 17, 14, 9, 21]},\r\n\"mal\": {\"id\": \"mal\", \"title\": \"Malachi\", \"usfm\": \"39-MAL\", \"testament\": \"old\", \"verseCount\": 55, \"chapters\": [14, 17, 18, 6]},\r\n\"mat\": {\"id\": \"mat\", \"title\": \"Matthew\", \"usfm\": \"41-MAT\", \"testament\": \"new\", \"verseCount\": 1071, \"chapters\": [25, 23, 17, 25, 48, 34, 29, 34, 38, 42, 30, 50, 58, 36, 39, 28, 27, 35, 30, 34, 46, 46, 39, 51, 46, 75, 66, 20]},\r\n\"mrk\": {\"id\": \"mrk\", \"title\": \"Mark\", \"usfm\": \"42-MRK\", \"testament\": \"new\", \"verseCount\": 678, \"chapters\": [45, 28, 35, 41, 43, 56, 37, 38, 50, 52, 33, 44, 37, 72, 47, 20]},\r\n\"luk\": {\"id\": \"luk\", \"title\": \"Luke\", \"usfm\": \"43-LUK\", \"testament\": \"new\", \"verseCount\": 1151, \"chapters\": [80, 52, 38, 44, 39, 49, 50, 56, 62, 42, 54, 59, 35, 35, 32, 31, 37, 43, 48, 47, 38, 71, 56, 53]},\r\n\"jhn\": {\"id\": \"jhn\", \"title\": \"John\", \"usfm\": \"44-JHN\", \"testament\": \"new\", \"verseCount\": 879, \"chapters\": [51, 25, 36, 54, 47, 71, 53, 59, 41, 42, 57, 50, 38, 31, 27, 33, 26, 40, 42, 31, 25]},\r\n\"act\": {\"id\": \"act\", \"title\": \"Acts\", \"usfm\": \"45-ACT\", \"testament\": \"new\", \"verseCount\": 1007, \"chapters\": [26, 47, 26, 37, 42, 15, 60, 40, 43, 48, 30, 25, 52, 28, 41, 40, 34, 28, 41, 38, 40, 30, 35, 27, 27, 32, 44, 31]},\r\n\"rom\": {\"id\": \"rom\", \"title\": \"Romans\", \"usfm\": \"46-ROM\", \"testament\": \"new\", \"verseCount\": 433, \"chapters\": [32, 29, 31, 25, 21, 23, 25, 39, 33, 21, 36, 21, 14, 23, 33, 27]},\r\n\"1co\": {\"id\": \"1co\", \"title\": \"1 Corinthians\", \"usfm\": \"47-1CO\", \"testament\": \"new\", \"verseCount\": 437, \"chapters\": [31, 16, 23, 21, 13, 20, 40, 13, 27, 33, 34, 31, 13, 40, 58, 24]},\r\n\"2co\": {\"id\": \"2co\", \"title\": \"2 Corinthians\", \"usfm\": \"48-2CO\", \"testament\": \"new\", \"verseCount\": 257, \"chapters\": [24, 17, 18, 18, 21, 18, 16, 24, 15, 18, 33, 21, 14]},\r\n\"gal\": {\"id\": \"gal\", \"title\": \"Galations\", \"usfm\": \"49-GAL\", \"testament\": \"new\", \"verseCount\": 149, \"chapters\": [24, 21, 29, 31, 26, 18]},\r\n\"eph\": {\"id\": \"eph\", \"title\": \"Ephesians\", \"usfm\": \"50-EPH\", \"testament\": \"new\", \"verseCount\": 155, \"chapters\": [23, 22, 21, 32, 33, 24]},\r\n\"php\": {\"id\": \"php\", \"title\": \"Phillipians\", \"usfm\": \"51-PHP\", \"testament\": \"new\", \"verseCount\": 104, \"chapters\": [30, 30, 21, 23]},\r\n\"col\": {\"id\": \"col\", \"title\": \"Colossians\", \"usfm\": \"52-COL\", \"testament\": \"new\", \"verseCount\": 95, \"chapters\": [29, 23, 25, 18]},\r\n\"1th\": {\"id\": \"1th\", \"title\": \"1 Thessalonians\", \"usfm\": \"53-1TH\", \"testament\": \"new\", \"verseCount\": 89, \"chapters\": [10, 20, 13, 18, 28]},\r\n\"2th\": {\"id\": \"2th\", \"title\": \"2 Thessalonians\", \"usfm\": \"54-2TH\", \"testament\": \"new\", \"verseCount\": 47, \"chapters\": [12, 17, 18]},\r\n\"1ti\": {\"id\": \"1ti\", \"title\": \"1 Timothy\", \"usfm\": \"55-1TI\", \"testament\": \"new\", \"verseCount\": 113, \"chapters\": [20, 15, 16, 16, 25, 21]},\r\n\"2ti\": {\"id\": \"2ti\", \"title\": \"2 Timothy\", \"usfm\": \"56-2TI\", \"testament\": \"new\", \"verseCount\": 83, \"chapters\": [18, 26, 17, 22]},\r\n\"tit\": {\"id\": \"tit\", \"title\": \"Titus\", \"usfm\": \"57-TIT\", \"testament\": \"new\", \"verseCount\": 46, \"chapters\": [16, 15, 15]},\r\n\"phm\": {\"id\": \"phm\", \"title\": \"Philemon\", \"usfm\": \"58-PHM\", \"testament\": \"new\", \"verseCount\": 25, \"chapters\": [25]},\r\n\"heb\": {\"id\": \"heb\", \"title\": \"Hebrews\", \"usfm\": \"59-HEB\", \"testament\": \"new\", \"verseCount\": 303, \"chapters\": [14, 18, 19, 16, 14, 20, 28, 13, 28, 39, 40, 29, 25]},\r\n\"jas\": {\"id\": \"jas\", \"title\": \"James\", \"usfm\": \"60-JAS\", \"testament\": \"new\", \"verseCount\": 108, \"chapters\": [27, 26, 18, 17, 20]},\r\n\"1pe\": {\"id\": \"1pe\", \"title\": \"1 Peter\", \"usfm\": \"61-1PE\", \"testament\": \"new\", \"verseCount\": 105, \"chapters\": [25, 25, 22, 19, 14]},\r\n\"2pe\": {\"id\": \"2pe\", \"title\": \"2 Peter\", \"usfm\": \"62-2PE\", \"testament\": \"new\", \"verseCount\": 61, \"chapters\": [21, 22, 18]},\r\n\"1jn\": {\"id\": \"1jn\", \"title\": \"1 John\", \"usfm\": \"63-1JN\", \"testament\": \"new\", \"verseCount\": 105, \"chapters\": [10, 29, 24, 21, 21]},\r\n\"2jn\": {\"id\": \"2jn\", \"title\": \"2 John\", \"usfm\": \"64-2JN\", \"testament\": \"new\", \"verseCount\": 13, \"chapters\": [13]},\r\n\"3jn\": {\"id\": \"3jn\", \"title\": \"3 John\", \"usfm\": \"65-3JN\", \"testament\": \"new\", \"verseCount\": 15, \"chapters\": [15]},\r\n\"jud\": {\"id\": \"jud\", \"title\": \"Jude\", \"usfm\": \"66-JUD\", \"testament\": \"new\", \"verseCount\": 25, \"chapters\": [25]},\r\n\"rev\": {\"id\": \"rev\", \"title\": \"Revelation\", \"usfm\": \"67-REV\", \"testament\": \"new\", \"verseCount\": 404, \"chapters\": [20, 29, 22, 11, 14, 17, 17, 13, 21, 11, 19, 17, 18, 20, 8, 21, 18, 24, 21, 15, 27, 21]}\r\n}\r\n\r\nconst oftenMissingBCVList = [\r\n  // See https://en.wikipedia.org/wiki/List_of_New_Testament_verses_not_included_in_modern_English_translations\r\n  ['NEH', 7, 68], // ?\r\n  ['MAT', 16, 3],\r\n  ['MAT', 17, 21],\r\n  ['MAT', 18, 11],\r\n  // ['MAT', 20, 16b],\r\n  ['MAT', 23, 14],\r\n  // ['MRK', 6, 11b],\r\n  ['MRK', 7, 16],\r\n  ['MRK', 9, 44], ['MRK', 9, 46],\r\n  ['MRK', 11, 26],\r\n  ['MRK', 15, 28],\r\n  ['MRK', 16, 9], ['MRK', 16, 10], ['MRK', 16, 11], ['MRK', 16, 12], ['MRK', 16, 13], ['MRK', 16, 14],\r\n    ['MRK', 16, 15], ['MRK', 16, 16], ['MRK', 16, 17], ['MRK', 16, 18], ['MRK', 16, 19], ['MRK', 16, 20],\r\n  // ['LUK', 4, 8b],\r\n  // ['LUK', 9, 55], ['LUK', 9, 56],\r\n  ['LUK', 17, 36],\r\n  ['LUK', 22, 43], // ?\r\n  ['LUK', 22, 44], // ?\r\n  ['LUK', 23, 17],\r\n  ['JHN', 5, 3], ['JHN', 5, 4],\r\n  ['JHN', 7, 53], // ?\r\n  ['JHN', 8, 1], // ?\r\n  ['ACT', 8, 37],\r\n  // ['ACT', 9, 5], ['ACT', 9, 6],\r\n  // ['ACT', 13, 42],\r\n  ['ACT', 15, 34],\r\n  // ['ACT', 23, 9b],\r\n  ['ACT', 24, 6], ['ACT', 24, 7], ['ACT', 24, 8],\r\n  ['ACT', 28, 29],\r\n  ['ROM', 16, 24],\r\n  ['2CO', 13, 14], // ?\r\n  ['1JN', 5, 7], ['1JN', 5, 8],\r\n];\r\n\r\n\r\n// import * as opt from './optimize'\r\n\r\n// export interface bookDataIF {\r\n//   \"id\";\r\n//   \"title\";\r\n//   \"usfm\";\r\n//   \"testament\";\r\n//   \"verseCount\": number;\r\n//   \"chapters\": number[];\r\n// }\r\n\r\nconst extraBookList = ['FRT','BAK'];\r\nexport const isValidBookID = (bookId) => {\r\n  return bookId.toLowerCase() in BibleBookData || extraBookList.includes(bookId);\r\n}\r\nexport const isOptionalValidBookID = (bookId) => {\r\n  return !bookId || bookId.toLowerCase() in BibleBookData || extraBookList.includes(bookId);\r\n}\r\nexport const isExtraBookID = (bookId) => {\r\n  return extraBookList.includes(bookId);\r\n}\r\n\r\n\r\nexport const usfmNumberName = (bookId) => {\r\n  try {return BibleBookData[bookId.toLowerCase()].usfm;}\r\n  catch(err) {throw new Error(`usfmNumberName() given invalid bookId: '${bookId}'`);}\r\n}\r\n\r\nexport const chaptersInBook = (bookId) => {\r\n  // console.assert(bookId.toLowerCase() !== 'obs', `chaptersInBook shouldnt be passed '${bookId}'`);\r\n  let chapters;\r\n  try {\r\n    chapters = BibleBookData[bookId.toLowerCase()].chapters;\r\n  } catch (err) {\r\n    throw new Error(`chaptersInBook() given invalid bookId: '${bookId}'`);\r\n  }\r\n  if (chapters === undefined) {\r\n    throw new Error(`chaptersInBook(): Invalid bookId: '${bookId}'`);\r\n  }\r\n  return chapters;\r\n};\r\n\r\nexport const versesInChapter = (bookId, chapter) => {\r\n  // console.assert(bookId.toLowerCase() !== 'obs', `versesInChapter shouldnt be passed '${bookId}'`);\r\n  const verses = chaptersInBook(bookId)[chapter - 1];\r\n  if (verses === undefined) {\r\n    throw new Error(`versesInChapter(${bookId}) given invalid chapter: ${chapter}`);\r\n  }\r\n  return verses;\r\n};\r\n\r\nexport const testament = (bookId) => {\r\n  const _testament = BibleBookData[bookId.toLowerCase()].testament;\r\n  return _testament;\r\n};\r\n\r\nexport function getEnglishBookName(bookId) {\r\n  return BibleBookData[bookId.toLowerCase()].title;\r\n}\r\n\r\nexport function isGoodEnglishBookName(givenBookName) {\r\n  // console.log(`isGoodEnglishBookName(${givenBookName})`);\r\n  const partialMatches = [];\r\n  const givenBookNameLower = givenBookName.toLowerCase();\r\n  for (const bk in BibleBookData) {\r\n    const thisBookName = BibleBookData[bk].title;\r\n    // console.log(\"thisBookName\", thisBookName);\r\n    if (thisBookName===givenBookName) return true;\r\n    const thisBookNameLower = thisBookName.toLowerCase();\r\n    if (thisBookNameLower===givenBookNameLower) return 1;\r\n    if (thisBookNameLower.startsWith(givenBookNameLower)) partialMatches.push(thisBookName);\r\n  }\r\n  if (partialMatches.length === 1) return 2; // We got an unambiguous partial match, e.g., Gen for Genesis\r\n  return false;\r\n}\r\n\r\nexport function isOftenMissing(bookID,C,V) {\r\n  function matchBCV(entry) { return entry[0]===bookID && entry[1]===C && entry[2]===V; }\r\n\r\n  return oftenMissingBCVList.find(matchBCV) !== undefined;\r\n}\r\n","export * from './core';\r\n"],"sourceRoot":""}