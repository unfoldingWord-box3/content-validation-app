{"version":3,"sources":["../node_modules/jspdf/dist sync","fonts/SILEOTSR.ttf","core/books.ts","core/getApi.js","core/book-package-check.js","core/utilities.ts","ValidationNotices.js","BookPackageContentValidator.js","App.tsx","serviceWorker.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","bookData","bookId","data","filter","row","testament","toLowerCase","newTestament","list","i","length","push","title","oldTestament","titlesToBoolean","ob","bookDataTitles","forEach","v","k","bookIdByTitle","bookTitleById","extraBookList","isOptionalValidBookID","indexOf","isValidBookID","_id","__id","toUpperCase","usfmNumberNameById","usfm","baseURL","failedStore","localforage","createInstance","driver","INDEXEDDB","name","zipStore","cacheStore","unzipStore","Door43Api","setup","cache","store","maxAge","exclude","query","key","serialized","params","URLSearchParams","toString","JSON","stringify","url","getUnZippedFile","path","a","getItem","contents","getFileCached","username","repository","branch","getUserNameOverrideForRepo","filePath","Path","join","getFileFromZip","fetchFileFromServer","setItem","console","log","cachedGetManifest","manifestContents","formData","yaml","parse","yamlError","error","message","cachedGetBookFilenameFromManifest","bookID","manifestJSON","projects","projectEntry","identifier","bookPath","startsWith","substring","clearCaches","clear","formRepoName","languageCode","repoCode","repo_languageCode","repo","originalUsername","includes","addIfMissing","repos","newRepo","addToStart","unshift","PreLoadRepos","loadOriginalLangs","loadUltAndUst","success","repos_","map","origLangBibles","ST","repoName","fetchRepositoryZipFile","zipFetchSucceeded","repositoryExists","uri","cachedGet","getUID","user","uid","q","limit","get","forceLoad","getZipFromStore","zipUri","fetch","response","status","arrayBuffer","zipArrayBuffer","getFileListFromZip","optionalPrefix","zipBlob","pathList","JSZip","loadAsync","relativePath","endsWith","zip","zipPath","file","async","checkRepo","givenLocation","setResultValue","checkingOptions","addSuccessMessage","addNoticePartial","ourCheckRepoFileContents","bookOrFileCode","cfBookID","filename","file_content","fileLocation","optionalCheckingOptions","assert","undefined","checkFileContents","cfcResultObject","noticeList","cfcNoticeEntry","extra","noticeObject","priority","books","C","V","characterIndex","extract","location","checkRepoResult","successString","successList","startTime","Date","split","checkedFileCount","checkedFilenames","checkedFilenameExtensions","ourLocation","style","color","fetchRepositoryZipFile_","getFileListFromZip_","countString","toLocaleString","Set","totalCheckedSize","thisFilepath","thisFilename","pop","thisFilenameExtension","ourBookID","getFile_","getFile","repoFileContent","replace","add","checkedFilesizes","checkedRepoNames","elapsedSeconds","fileContent","ourCFLocation","filenameMain","checkTN_TSVText","checkFileResult","checkUSFMText","checkMarkdownText","checkPlainText","checkManifestText","checkYAMLText","checkedFilename","checkedFilesize","checkedOptions","checkTQbook","ourCheckTQFileContents","cfFilename","cfResultObject","noticeEntry","ctqResult","generalLocation","bookIdLc","Array","isArray","thisPath","pathParts","slice","tqFileContent","checkBookPackage","ourCheckBPFileContents","checkBookPackageResult","newCheckingOptions","originalLanguageRepoUsername","taRepoUsername","bookNumberAndName","whichTestament","repoCodeList","repoLocation","tqResultObject","concat","stringToNumber","value","num","parseInt","isNaN","NaN","somewhatNumericalSort","b","aNum","bNum","aStr","bStr","notices_to_mt","renderLink","renderWithUnicodeLink","renderPriority","mt","columns","field","render","rowData","customSort","results","sortChapterVerse","link","lineNumber","cellStyle","fontFamily","excerpt","width","Object","_location","_link","lineNum","extension","view","namePrefix","repoUC","getLink","rowID","charPos","fieldName","details","sort","rows","newColumns","column","hasData","trimColumns","options","sorting","exportButton","exportAllData","columnsButton","filtering","pageSize","tableIcons","Add","forwardRef","props","ref","Check","Clear","Delete","DetailPanel","Edit","Export","Filter","FirstPage","LastPage","NextPage","PreviousPage","ResetSearch","Search","SortArrow","ThirdStateCheck","ViewColumn","content","fontWeight","href","target","rel","match","getUnicodeRegEx","RegExp","lastPos","output","exec","index","matchLen","unicode","withStyles","theme","root","util","Paper","icons","BookPackageContentValidator","language_code","useState","result","getFilelistFromZip","useEffect","renderSummary","rawCBPResults","Typography","checkType","ValidationNotices","useStyles","makeStyles","createStyles","flexGrow","display","menuButton","marginRight","spacing","appBar","transition","transitions","create","easing","sharp","duration","leavingScreen","appBarShift","marginLeft","easeOut","enteringScreen","formControl","margin","button","instructions","marginTop","marginBottom","hide","drawer","flexShrink","drawerPaper","drawerHeader","alignItems","padding","mixins","toolbar","justifyContent","contentShift","alignItemsAndJustifyContent","offset","queryProcessedOnce","App","React","state","setState","activeStep","setActiveStep","skipped","setSkipped","org","setOrg","lang","setLang","steps","isStepSkipped","step","has","handleNext","newSkipped","values","delete","doLanguageInitialization","prevActiveStep","search","window","useQuery","doInitialization","bks","barrayIds","barrayTitles","x","alert","classes","useTheme","open","setOpen","handleChange","event","checked","className","CssBaseline","AppBar","position","clsx","Toolbar","IconButton","aria-label","onClick","edge","variant","Drawer","anchor","paper","direction","Divider","Stepper","label","stepProps","labelProps","completed","Step","StepLabel","Container","getStepContent","Button","disabled","FormControl","component","FormLabel","RadioGroup","onChange","val","FormControlLabel","control","Radio","Grid","container","item","xs","states","required","FormGroup","t","Checkbox","FormHelperText","y","joinBookIds","Boolean","hostname","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.fccc86fe.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 405;","module.exports = __webpack_public_path__ + \"static/media/SILEOTSR.a5284649.ttf\";","import data from './books.json';\r\n\r\nexport interface bookDataIF {\r\n  \"id\": string;\r\n  \"title\": string;\r\n  \"usfm\": string;\r\n  \"testament\": string;\r\n  \"verseCount\": number;\r\n  \"chapters\": number[];\r\n}\r\n\r\ninterface bpStateIF { [x: string]: boolean[]; };\r\n\r\nexport const chaptersInBook = (bookId: string) => {\r\n    let chapters: number[];\r\n    chapters = bookData(bookId).chapters;\r\n    if ( chapters === undefined ) {\r\n      throw new Error(\"Error: chaptersInBook(): Invalid bookId\");\r\n    }\r\n    return chapters;\r\n};\r\n\r\nexport const versesInChapter = (bookId: string, chapter: number) => {\r\n  const verses = chaptersInBook(bookId)[chapter - 1];\r\n  return verses;\r\n};\r\n\r\nexport const bookData = (bookId: string) => {\r\n  const _bookData: bookDataIF = data.filter(row => row.id === bookId)[0];\r\n  return _bookData;\r\n};\r\n\r\nexport const testament = (bookId: string) => {\r\n    bookId = bookId.toLowerCase();\r\n    const _testament = bookData(bookId).testament;\r\n  return _testament;\r\n};\r\n\r\nexport const newTestament = () => {\r\n  let list: string[] = [];\r\n  for (let i=0; i < data.length; i++) {\r\n    if ( data[i].testament === \"new\" ) {\r\n      list.push( data[i].title )\r\n    }\r\n  }\r\n  return list;\r\n}\r\n\r\nexport const oldTestament = () => {\r\n  let list: string[] = [];\r\n  for (let i=0; i < data.length; i++) {\r\n    if ( data[i].testament === \"old\" ) {\r\n      list.push( data[i].title )\r\n    }\r\n  }\r\n  return list;\r\n}\r\n\r\nexport const bookDataTitles = () => {\r\n  let list: string[] = [];\r\n  for (let i=0; i < data.length; i++) {\r\n      list.push( data[i].title )\r\n  }\r\n  return list;\r\n}\r\n\r\nexport const titlesToBoolean = () => {\r\n  let ob: bpStateIF = {};\r\n  let list = bookDataTitles();\r\n  list.forEach((v,k) => {ob[v]= [false,false]});\r\n  return ob;\r\n}\r\n\r\nexport const bookIdByTitle = (title: string) => {\r\n    for (let i=0; i < data.length; i++) {\r\n    if ( data[i].title === title ) {\r\n      return data[i].id;\r\n    }\r\n  }\r\n  return \"\";\r\n}\r\n\r\nexport const bookTitleById = (id: string) => {\r\n    id = id.toLowerCase();\r\n    for (let i=0; i < data.length; i++) {\r\n    if ( data[i].id === id ) {\r\n      return data[i].title;\r\n    }\r\n  }\r\n  return \"\";\r\n}\r\n\r\nconst extraBookList = ['FRT','BAK'];\r\n\r\nexport const isOptionalValidBookID = (bookId: string) => {\r\n  return !bookId || bookId.toLowerCase() in data || extraBookList.indexOf(bookId) >= 0;\r\n}\r\nexport const isValidBookID = (id: string) => {\r\n  const _id = id.toLowerCase();\r\n  for (let i=0; i < data.length; i++) {\r\n    if ( data[i].id === _id ) {\r\n      return true;\r\n    }\r\n  }\r\n  const __id = id.toUpperCase();\r\n  for (let i=0; i < extraBookList.length; i++) {\r\n    if ( extraBookList[i] === __id ) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\nexport const usfmNumberNameById = (id: string) => {\r\n  id = id.toLowerCase();\r\n  for (let i=0; i < data.length; i++) {\r\n    if ( data[i].id === id ) {\r\n      return data[i].usfm;\r\n    }\r\n  }\r\n  throw new Error(`usfmNumberName() given invalid bookId: '${id}'`);\r\n}\r\n\r\n","import Path from 'path';\r\nimport yaml from 'yaml';\r\nimport localforage from 'localforage';\r\nimport { setup } from 'axios-cache-adapter';\r\nimport JSZip from 'jszip';\r\n\r\nconst baseURL = 'https://git.door43.org/';\r\nconst apiPath = 'api/v1';\r\n\r\n// caches failed http file fetches so we don't waste time with repeated attempts\r\nconst failedStore = localforage.createInstance({\r\n  driver: [localforage.INDEXEDDB],\r\n  name: 'failed-store',\r\n});\r\n\r\n// caches zip file fetches done by fetchRepositoryZipFile()\r\nconst zipStore = localforage.createInstance({\r\n  driver: [localforage.INDEXEDDB],\r\n  name: 'zip-store',\r\n});\r\n\r\n// caches http file fetches done by fetchFileFromServer()\r\nconst cacheStore = localforage.createInstance({\r\n  driver: [localforage.INDEXEDDB],\r\n  name: 'web-cache',\r\n});\r\n\r\n// caches the unzipped files requested so we don't do repeated unzipping of the same file which is slow in JS\r\nconst unzipStore = localforage.createInstance({\r\n  driver: [localforage.INDEXEDDB],\r\n  name: 'unzip-store',\r\n});\r\n\r\n// API for http requests\r\nconst Door43Api = setup({\r\n  baseURL: baseURL,\r\n  cache: {\r\n    store: cacheStore,\r\n    maxAge: 5 * 60 * 1000, // 5-minutes\r\n    exclude: { query: false },\r\n    key: req => {\r\n      // if (req.params) debugger\r\n      let serialized = req.params instanceof URLSearchParams ?\r\n        req.params.toString() : JSON.stringify(req.params) || '';\r\n      return req.url + serialized;\r\n    },\r\n  },\r\n});\r\n\r\n/**\r\n * try to get previously unzipped file from cache\r\n * @param {string} path\r\n * @return {Promise<unknown>} resolves to file contents or null if not found\r\n */\r\nexport async function getUnZippedFile(path) {\r\n  // console.log(`getUnZippedFile(${path})`);\r\n  const contents = await unzipStore.getItem(path.toLowerCase());\r\n  return contents;\r\n}\r\n\r\n/**\r\n * searches for files in this order:\r\n *   - cache of uncompressed files (unzipStore)\r\n *   - cache of zipped repos (zipStore)\r\n *   - and finally calls fetchFileFromServer() which firts checks in cacheStore to see if already fetched.\r\n * @param {String} username\r\n * @param {String} repository\r\n * @param {String} path\r\n * @param {String} branch\r\n * @return {Promise<*>}\r\n */\r\nexport async function getFileCached({ username, repository, path, branch }) {\r\n\r\n  username = getUserNameOverrideForRepo(username, repository);\r\n\r\n  const filePath = Path.join(username, repository, path, branch);\r\n  // console.log(`getFileCached(${username}, ${repository}, ${path}, ${branch})…`);\r\n  let contents = await getUnZippedFile(filePath);\r\n  if (contents) {\r\n    // console.log(`in cache - ${filePath}`);\r\n    return contents;\r\n  }\r\n\r\n  contents = await getFileFromZip({ username, repository, path, branch });\r\n  if (!contents) {\r\n    contents = await fetchFileFromServer({ username, repository, path, branch });\r\n  }\r\n\r\n  if (contents) {\r\n    // save unzipped file in cache to speed later retrieval\r\n    await unzipStore.setItem(filePath.toLowerCase(), contents);\r\n    // console.log(`saving to cache - ${filePath}`);\r\n  } else {\r\n    console.log(`getFileCached(${username}, ${repository}, ${path}, ${branch}) - failed to get file`);\r\n  }\r\n\r\n  return contents;\r\n}\r\n\r\n/**\r\n * Retrieve manifest.yaml from requested repo\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} branch\r\n * @return {Promise<[]|*[]>} resolves to manifest contents if downloaded (else undefined)\r\n */\r\nasync function cachedGetManifest({ username, repository, branch }) {\r\n  // console.log(`cachedGetManifest(${username}, ${repository}, ${branch})…`);\r\n\r\n  const manifestContents = await getFileCached({ username, repository, path: 'manifest.yaml', branch });\r\n  let formData;\r\n  try {\r\n    formData = yaml.parse(manifestContents);\r\n    // console.log(\"yaml.parse(YAMLText) got formData\", JSON.stringify(formData));\r\n  }\r\n  catch (yamlError) {\r\n    console.error(`${username} ${repository} ${branch} manifest yaml parse error: ${yamlError.message}`);\r\n  }\r\n  return formData;\r\n}\r\n\r\n\r\n/**\r\n * Retrieve manifest.yaml from requested repo\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} branch\r\n * @param {string} bookID -- 3-character USFM book code\r\n * @return {Promise<[]|*[]>} resolves to filename from the manifest for the book (else undefined)\r\n */\r\nexport async function cachedGetBookFilenameFromManifest({ username, repository, branch, bookID }) {\r\n  // console.log(`cachedGetBookFilenameFromManifest(${username}, ${repository}, ${branch}, ${bookID})…`);\r\n  const manifestJSON = await cachedGetManifest({ username, repository, branch });\r\n  for (const projectEntry of manifestJSON.projects) {\r\n    if (projectEntry.identifier === bookID) {\r\n      let bookPath = projectEntry.path;\r\n      if (bookPath.startsWith('./')) bookPath = bookPath.substring(2);\r\n      return bookPath;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * clear all the stores\r\n * @return {Promise<void>}\r\n */\r\nexport async function clearCaches() {\r\n  console.log(\"Clearing localforage.INDEXEDDB zipStore, cacheStore, etc. caches…\");\r\n  // const tasks = [zipStore, cacheStore].map(localforage.clear);\r\n  // const results = await Promise.all(tasks);\r\n  // results.forEach(x => console.log(\"Done it\", x));\r\n  await failedStore.clear();\r\n  await zipStore.clear();\r\n  await cacheStore.clear();\r\n  await unzipStore.clear();\r\n}\r\n\r\n/**\r\n * @description - Forms and returns a Door43 repoName string\r\n * @param {String} languageCode - the language code, e.g., 'en'\r\n * @param {String} repoCode - the repo code, e.g., 'TQ'\r\n * @return {String} - the Door43 repoName string\r\n */\r\nexport function formRepoName(languageCode, repoCode) {\r\n  //    console.log(`formRepoName('${languageCode}', '${repoCode}')…`);\r\n\r\n  // TODO: Should we also check the username 'unfoldingWord' and/or 'Door43-Catalog' here???\r\n  //        (We don't currently have the username available in this function.)\r\n  if (repoCode === 'LT') repoCode = languageCode === 'en' ? 'ULT' : 'GLT';\r\n  if (repoCode === 'ST') repoCode = languageCode === 'en' ? 'UST' : 'GST';\r\n\r\n  let repo_languageCode = languageCode;\r\n  if (repoCode === 'UHB') repo_languageCode = 'hbo';\r\n  else if (repoCode === 'UGNT') repo_languageCode = 'el-x-koine';\r\n  const repoName = `${repo_languageCode}_${repoCode.toLowerCase()}`;\r\n  return repoName;\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} username\r\n * @param {string} repo\r\n * @return {string} username to use\r\n */\r\nexport function getUserNameOverrideForRepo(username, repo) {\r\n  //    console.log(`getUserNameOverrideForRepo('${username}', '${repo}')…`);\r\n  const originalUsername = username;\r\n  if (['el-x-koine_ugnt', 'hbo_uhb'].includes(repo)) {\r\n    username = 'unfoldingWord';\r\n  } else {\r\n    if ((repo.indexOf('_glt') > 0)  || (repo.indexOf('_gst') > 0)) {\r\n      username = 'STR';\r\n    }\r\n  }\r\n  if (username.toLowerCase() !== originalUsername.toLowerCase()) {\r\n    console.log(`getUserNameOverrideForRepo('${originalUsername}', '${repo}') - changing username to ${username}`);\r\n  }\r\n  return username;\r\n}\r\n/**\r\n * add new repo to list if missing\r\n * @param {string} repos\r\n * @param {string} newRepo\r\n * @param {boolean} addToStart - if true add to start\r\n */\r\nfunction addIfMissing(repos, newRepo, addToStart = true) {\r\n  if (!repos.includes(newRepo)) {\r\n    if (addToStart) {\r\n      repos.unshift(newRepo);\r\n    } else {\r\n      repos.push(newRepo);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * preloads repo zips, before running book package checks.\r\n *   TRICKY: note that even if the user is super fast in selecting books and clicking next, it will not hurt anything.  getFile() would just be fetching files directly from repo until the zips are loaded.  After that the files would be pulled out of zipStore.\r\n * @param {string} username\r\n * @param {string} languageCode\r\n * @param {string} branch - optional, defaults to master\r\n * @param {Array} repos - optional, list of additional repos to pre-load\r\n * @param {boolean} loadOriginalLangs - if true will download original language books\r\n * @param {boolean} loadUltAndUst\r\n * @return {Promise<Boolean>} resolves to true if file loads are successful\r\n */\r\nexport async function PreLoadRepos(username, languageCode, branch = 'master', repos = [],\r\n                                   loadOriginalLangs = false,\r\n                                   loadUltAndUst = false) {\r\n  console.log(`PreLoadRepos(${username}, ${languageCode}, ${branch}, ${repos}, ${loadOriginalLangs})…`);\r\n\r\n  let success = true;\r\n  const repos_ = repos.map((repo) => (formRepoName(languageCode, repo)));\r\n\r\n  if (loadOriginalLangs) {\r\n    // make sure we have the original languages needed\r\n    for (const origLangBibles of [ 'UHB', 'UGNT' ]) {\r\n      addIfMissing(repos_, formRepoName(languageCode, origLangBibles), true);\r\n    }\r\n  }\r\n\r\n  if (loadUltAndUst) {\r\n    const LT = languageCode === 'en' ? 'ULT' : 'GLT';\r\n    const ST = languageCode === 'en' ? 'UST' : 'GST';\r\n    addIfMissing(repos_, formRepoName(languageCode, LT), false);\r\n    addIfMissing(repos_, formRepoName(languageCode, ST), false);\r\n  }\r\n\r\n  // load all the repos needed\r\n  for (const repoName of repos_) {\r\n    console.log(`PreLoadRepos: preloading zip file for ${repoName}…`);\r\n    const zipFetchSucceeded = await fetchRepositoryZipFile({ username, repository: repoName, branch });\r\n    if (!zipFetchSucceeded) {\r\n      console.log(`PreLoadRepos: misfetched zip file for ${repoName} repo with ${zipFetchSucceeded}`);\r\n      success = false;\r\n    }\r\n  }\r\n\r\n  return success;\r\n}\r\n\r\n/**\r\n * does http file fetch from server  uses cacheStore to minimize repeated fetches of same file\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} path\r\n * @param {string} branch\r\n * @return {Promise<null|any>} resolves to file content\r\n */\r\nasync function fetchFileFromServer({ username, repository, path, branch = 'master' }) {\r\n  console.log(`fetchFileFromServer(${username}, ${repository}, ${path}, ${branch})…`);\r\n  const repoExists = await repositoryExists({ username, repository });\r\n  let uri;\r\n  if (repoExists) {\r\n    uri = Path.join(username, repository, 'raw/branch', branch, path);\r\n    const failMessage = await failedStore.getItem(uri.toLowerCase());\r\n    if (failMessage) {\r\n      // console.log(`fetchFileFromServer failed previously for ${uri}: ${failMessage}`);\r\n      return null;\r\n    }\r\n    try {\r\n      // console.log(\"URI=\",uri);\r\n      const data = await cachedGet({ uri });\r\n      // console.log(\"Got data\", data);\r\n      return data;\r\n    }\r\n    catch (fffsError) {\r\n      console.log(`ERROR: fetchFileFromServer could not fetch ${path}: ${fffsError}`)\r\n      /* await */ failedStore.setItem(uri.toLowerCase(), fffsError.message);\r\n      return null;\r\n    }\r\n  } else {\r\n    console.log(`ERROR: fetchFileFromServer repo '${repository}' does not exist!`);\r\n    /* await */ failedStore.setItem(uri.toLowerCase(), `Repo '${repository}' does not exist!`);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n *  older getFile without that doesn't use the unzipStore\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} path\r\n * @param {string} branch\r\n * @return {Promise<*>}\r\n */\r\nasync function getFile({ username, repository, path, branch }) {\r\n  console.log(`getFile(${username}, ${repository}, ${path}, ${branch})…`);\r\n  let file;\r\n  file = await getFileFromZip({ username, repository, path, branch });\r\n  if (!file) {\r\n    file = await fetchFileFromServer({ username, repository, path, branch });\r\n  }\r\n  return file;\r\n}\r\n\r\nasync function getUID({ username }) {\r\n  // console.log(`getUID(${username})…`);\r\n  const uri = Path.join(apiPath, 'users', username);\r\n  // console.log(`getUID uri=${uri}`);\r\n  const user = await cachedGet({ uri });\r\n  // console.log(`getUID user=${user}`);\r\n  const { id: uid } = user;\r\n  // console.log(`  getUID returning: ${uid}`);\r\n  return uid;\r\n}\r\n\r\n/**\r\n * check server to see if repository exists on server.  Do this before we try to download\r\n * @param {string} username\r\n * @param {string} repository\r\n * @return {Promise<boolean>}\r\n */\r\nasync function repositoryExists({ username, repository }) {\r\n  // console.log(`repositoryExists(${username}, ${repository})…`);\r\n  const uid = await getUID({ username });\r\n  // console.log(`repositoryExists uid=${uid}`);\r\n  // Default limit is 10 -- way too small\r\n  // TODO: we probably want to change this to do paging since we cannot be sure of future size limits on fetches\r\n  const params = { q: repository, limit: 500, uid }; // Documentation says limit is 50, but larger numbers seem to work ok\r\n  // console.log(`repositoryExists params=${JSON.stringify(params)}`);\r\n  const uri = Path.join(apiPath, 'repos', `search`);\r\n  // console.log(`repositoryExists uri=${uri}`);\r\n  const { data: repos } = await cachedGet({ uri, params });\r\n  // console.log(`repositoryExists repos (${repos.length})=${repos}`);\r\n  // for (const thisRepo of repos) console.log(`  thisRepo (${JSON.stringify(Object.keys(thisRepo))}) =${JSON.stringify(thisRepo.name)}`);\r\n  const repo = repos.filter(repo => repo.name === repository)[0];\r\n  // console.log(`repositoryExists repo=${repo}`);\r\n  // console.log(`  repositoryExists returning: ${!!repo}`);\r\n  return !!repo;\r\n};\r\n\r\nasync function cachedGet({ uri, params }) {\r\n  // console.log(`cachedGet(${uri}, ${JSON.stringify(params)})…`);\r\n  // console.log(`  get querying: ${baseURL+uri}`);\r\n  const { data } = await Door43Api.get(baseURL + uri, { params });\r\n  // console.log(`  cachedGet returning: ${JSON.stringify(data)}`);\r\n  return data;\r\n};\r\n\r\nexport async function cachedGetURL({ uri, params }) {\r\n  // console.log(`cachedGetURL(${uri}, ${params})…`);\r\n  const { data } = await Door43Api.get(uri, { params });\r\n  // console.log(`  cachedGetURL returning: ${data}`);\r\n  return data;\r\n};\r\n\r\n/*\r\nfunction fetchRepositoriesZipFiles({username, languageId, branch}) {\r\n  const repositories = resourceRepositories({languageId});\r\n  const promises = Object.values(repositories).map(repository => {\r\n    return fetchRepositoryZipFile({username, repository, branch});\r\n  });\r\n  const zipArray = await Promise.all(promises);\r\n  return zipArray;\r\n};\r\n*/\r\n\r\n\r\n/**\r\n * retrieve repo as zip file\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} branch\r\n * @param {boolean} forceLoad - if not true, then use existing repo in zipstore\r\n * @return {Promise<[]|*[]>} resolves to true if downloaded\r\n */\r\nexport async function fetchRepositoryZipFile({ username, repository, branch }, forceLoad = false) {\r\n  // https://git.door43.org/{username}/{repository}/archive/{branch}.zip\r\n  console.log(`fetchRepositoryZipFile(${username}, ${repository}, ${branch})…`);\r\n\r\n  username = getUserNameOverrideForRepo(username, repository);\r\n\r\n  if (!forceLoad) { // see if we already have in zipStore\r\n    const zipBlob = await getZipFromStore(username, repository, branch);\r\n    if (zipBlob) {\r\n      console.log(`fetchRepositoryZipFile(${username}, ${repository}, ${branch})… - already loaded`);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  const repoExists = await repositoryExists({ username, repository });\r\n  if (!repoExists) {\r\n    console.log(`fetchRepositoryZipFile(${username}, ${repository}, ${branch}) - repo doesn't exist`, { username, repository });\r\n    return false;\r\n  }\r\n\r\n  const uri = zipUri({ username, repository, branch });\r\n  const response = await fetch(uri);\r\n  if (response.status === 200 || response.status === 0) {\r\n    const zipArrayBuffer = await response.arrayBuffer(); // blob storage not supported on mobile\r\n    console.log(`fetchRepositoryZipFile(${username}, ${repository}, ${branch}) - saving zip: ${uri}`);\r\n    await zipStore.setItem(uri.toLowerCase(), zipArrayBuffer);\r\n    return true;\r\n  } else {\r\n    console.log(`fetchRepositoryZipFile(${username}, ${repository}, ${branch}) - got response status: ${response.status}`);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * pull repo from zipstore and get a file list\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} branch\r\n * @param {string} optionalPrefix - to filter by book, etc.\r\n * @return {Promise<[]|*[]>}  resolves to file list\r\n */\r\nexport async function getFileListFromZip({ username, repository, branch, optionalPrefix }) {\r\n  // console.log(`getFileListFromZip(${username}, ${repository}, ${branch}, ${optionalPrefix})…`);\r\n\r\n  username = getUserNameOverrideForRepo(username, repository);\r\n\r\n  const uri = zipUri({ username, repository, branch });\r\n  let zipBlob = await getZipFromStore(username, repository, branch);\r\n\r\n  if (!zipBlob) { // Seems that we need to load the zip file first\r\n    const response = await fetch(uri);\r\n    if (response.status === 200 || response.status === 0) {\r\n      const zipArrayBuffer = await response.arrayBuffer(); // blob storage not supported on mobile\r\n      zipBlob = await zipStore.setItem(uri.toLowerCase(), zipArrayBuffer);\r\n    } else {\r\n      console.log(`ERROR: getFilelistFromZip got response status: ${response.status}`);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  const pathList = [];\r\n  try {\r\n    if (zipBlob) {\r\n      // console.log(`  Got zipBlob for uri=${uri}`);\r\n      const zip = await JSZip.loadAsync(zipBlob);\r\n      // console.log(`  Got zip`);\r\n      // Now we need to fetch the list of files from the repo\r\n      // zip.forEach(function (relativePath, fileObject) {\r\n      zip.forEach(function (relativePath) {\r\n        // console.log(`relPath=${relativePath}`)\r\n        // consoleLogObject('fileObject', fileObject);\r\n        if (!relativePath.endsWith('/')) // it's not a folder\r\n        {\r\n          if (relativePath.startsWith(`${repository}/`)) // remove repo name prefix\r\n            relativePath = relativePath.substring(repository.length + 1);\r\n          if (relativePath.length\r\n            && !relativePath.startsWith('.git') // skips files in these folders\r\n            && !relativePath.startsWith('.apps') // skips files in this folder\r\n            && (!optionalPrefix || relativePath.startsWith(optionalPrefix))) // it's the correct prefix\r\n            pathList.push(relativePath);\r\n        }\r\n      })\r\n    }\r\n    // else console.log(\"  getFileListFromZip: No zipBlob\");\r\n  } catch (error) {\r\n    console.log(`ERROR: getFilelistFromZip got: ${error.message}`);\r\n  }\r\n\r\n  // console.log(`getFileListFromZip is returning (${pathList.length}) entries: ${pathList}`);\r\n  return pathList;\r\n}\r\n\r\n/**\r\n * try to get zip file from cache\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} branch\r\n * @return {Promise<unknown>} resolves to null if not found\r\n */\r\nexport async function getZipFromStore(username, repository, branch) {\r\n  const uri = zipUri({username, repository, branch});\r\n  const zipBlob = await zipStore.getItem(uri.toLowerCase());\r\n  // console.log(`getZipFromStore(${uri} - empty: ${!zipBlob}`);\r\n  return zipBlob;\r\n}\r\n\r\n/**\r\n * pull repo from zipstore and get the unzipped file\r\n * @param {string} username\r\n * @param {string} repository\r\n * @param {string} branch\r\n * @param {object} optionalPrefix\r\n * @return {Promise<[]|*[]>} resolves to unzipped file if found or null\r\n */\r\nasync function getFileFromZip({ username, repository, path, branch }) {\r\n  // console.log(`getFileFromZip(${username}, ${repository}, ${path}, ${branch})…`);\r\n  let file;\r\n  const zipBlob = await getZipFromStore(username, repository, branch);\r\n  try {\r\n    if (zipBlob) {\r\n      // console.log(`  Got zipBlob for uri=${uri}`);\r\n      const zip = await JSZip.loadAsync(zipBlob);\r\n      const zipPath = Path.join(repository.toLowerCase(), path);\r\n      // console.log(`  zipPath=${zipPath}`);\r\n      file = await zip.file(zipPath).async('string');\r\n      // console.log(`    Got zipBlob ${file.length} bytes`);\r\n    }\r\n    // else console.log(\"  No zipBlob\");\r\n  } catch (error) {\r\n    console.log(`ERROR: getFileFromZip for ${username} ${repository} ${path} ${branch} got: ${error.message}`);\r\n    file = null;\r\n  }\r\n  return file;\r\n};\r\n\r\n\r\nexport function zipUri({ username, repository, branch = 'master' }) {\r\n  // console.log(`zipUri(${username}, ${repository}, ${branch})…`);\r\n  const zipPath = Path.join(username, repository, 'archive', `${branch}.zip`);\r\n  const zipUri = baseURL + zipPath;\r\n  return zipUri;\r\n};\r\n\r\n\r\nexport async function fetchTree({ username, repository, sha = 'master' }) {\r\n  // console.log(`fetchTree(${username}, ${repository}, ${sha})…`);\r\n  let data;\r\n  try {\r\n    const uri = Path.join('api/v1/repos', username, repository, 'git/trees', sha);\r\n    // console.log(`  uri='${uri}'`);\r\n    data = await cachedGet({ uri });\r\n    // console.log(`  data (${typeof data})`);\r\n    return data;\r\n    // const tree = JSON.parse(data); // RJH: Why was this here???\r\n    // console.log(`  tree (${typeof tree})`);\r\n    // return tree;\r\n  } catch (error) {\r\n    console.log(`ERROR: fetchTree got: ${error.message}`);\r\n    console.log(`  Data was: ${JSON.stringify(data)}`);\r\n    return null;\r\n  }\r\n};\r\n\r\n\r\n/*\r\nasync function recursiveTree({username, repository, path, sha}) {\r\n  console.log(\"recurse tree args:\",username,repository,path,sha)\r\n  let tree = {};\r\n  const pathArray = path.split();\r\n  const results = fetchTree({username, repository, sha});\r\n  const result = results.tree.filter(item => item.path === pathArray[0])[0];\r\n  if (result) {\r\n    if (result.type === 'tree') {\r\n      const childPath = pathArray.slice(1).join('/');\r\n      const children = recursiveTree({username, repository, path: childPath, sha: result.sha});\r\n      tree[result.path] = children;\r\n    } else if (result.type === 'blob') {\r\n      tree[result.path] = true;\r\n    }\r\n  }\r\n};\r\n\r\nasync function fileExists({username, repository, path, branch}) {\r\n  // get root listing\r\n  recursiveTree()\r\n  // get recursive path listing\r\n}\r\n*/\r\n","import React from 'react';\r\nimport * as books from './books';\r\nimport {\r\n  cachedGetBookFilenameFromManifest,\r\n  formRepoName, getFileListFromZip,\r\n  getFileCached,\r\n  fetchRepositoryZipFile\r\n} from './getApi';\r\n\r\nimport {\r\n  checkManifestText,\r\n  checkMarkdownText,\r\n  checkPlainText,\r\n  checkTN_TSVText,\r\n  checkUSFMText,\r\n  checkYAMLText\r\n} from 'uw-content-validation';\r\n\r\n/*\r\n    checkRepo\r\n*/\r\nexport async function checkRepo(username, repoName, branch, givenLocation, setResultValue, checkingOptions) {\r\n  /*\r\n  checkRepo DOES NOT USE the Gitea React Toolkit to fetch the repo\r\n\r\n  It returns an object containing:\r\n      successList: an array of strings to tell the use exactly what has been checked\r\n      noticeList: an array of 9 (i.e., with extra bookOrFileCode parameter at end) notice components\r\n  */\r\n  // console.log(`checkRepo(${username}, ${repoName}, ${branch}, ${givenLocation}, (fn), ${JSON.stringify(checkingOptions)})…`);\r\n  const startTime = new Date();\r\n\r\n  const languageCode = repoName.split('_')[0];\r\n  // console.log(\"checkRepo languageCode\", languageCode);\r\n\r\n  if (branch === undefined) branch = 'master'; // Ideally we should ask what the default branch is\r\n\r\n  let checkRepoResult = {\r\n    successList: [], noticeList: [],\r\n    checkedFileCount: 0, checkedFilenames: [], checkedFilenameExtensions: []\r\n  };\r\n\r\n  function addSuccessMessage(successString) {\r\n    // Adds the message to the result that we will later return\r\n    // console.log(`checkRepo success: ${successString}`);\r\n    checkRepoResult.successList.push(successString);\r\n  }\r\n  function addNoticePartial(noticeObject) {\r\n    // Adds the notices to the result that we will later return\r\n    // bookID is a three-character UPPERCASE USFM book identifier or 'OBS'.\r\n    // Note that bookID,C,V might all be empty strings (as some repos don't have BCV)\r\n    // console.log(`checkRepo addNoticePartial: ${noticeObject.priority}:${noticeObject.message} ${noticeObject.bookID} ${noticeObject.C}:${noticeObject.V} ${noticeObject.filename}:${noticeObject.lineNumber} ${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : \"\"}${noticeObject.extract ? ` ${noticeObject.extract}` : \"\"}${noticeObject.location}`);\r\n    console.assert(noticeObject.priority !== undefined, \"cR addNoticePartial: 'priority' parameter should be defined\");\r\n    console.assert(typeof noticeObject.priority === 'number', `cR addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}'`);\r\n    console.assert(noticeObject.message !== undefined, \"cR addNoticePartial: 'message' parameter should be defined\");\r\n    console.assert(typeof noticeObject.message === 'string', `cR addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}'`);\r\n    // console.assert(bookID !== undefined, \"cR addNoticePartial: 'bookID' parameter should be defined\");\r\n    if (noticeObject.bookID) {\r\n      console.assert(typeof noticeObject.bookID === 'string', `cR addNoticePartial: 'bookID' parameter should be a string not a '${typeof noticeObject.bookID}'`);\r\n      console.assert(noticeObject.bookID.length === 3, `cR addNoticePartial: 'bookID' parameter should be three characters long not ${noticeObject.bookID.length}`);\r\n      console.assert(books.isOptionalValidBookID(noticeObject.bookID), `cR addNoticePartial: '${noticeObject.bookID}' is not a valid USFM book identifier`);\r\n    }\r\n    // console.assert(C !== undefined, \"cR addNoticePartial: 'C' parameter should be defined\");\r\n    if (noticeObject.C) console.assert(typeof noticeObject.C === 'string', `cR addNoticePartial: 'C' parameter should be a string not a '${typeof noticeObject.C}'`);\r\n    // console.assert(V !== undefined, \"cR addNoticePartial: 'V' parameter should be defined\");\r\n    if (noticeObject.V) console.assert(typeof noticeObject.V === 'string', `cR addNoticePartial: 'V' parameter should be a string not a '${typeof noticeObject.V}'`);\r\n    // console.assert(characterIndex !== undefined, \"cR addNoticePartial: 'characterIndex' parameter should be defined\");\r\n    if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cR addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}'`);\r\n    // console.assert(extract !== undefined, \"cR addNoticePartial: 'extract' parameter should be defined\");\r\n    if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cR addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}'`);\r\n    console.assert(noticeObject.location !== undefined, \"cR addNoticePartial: 'location' parameter should be defined\");\r\n    console.assert(typeof noticeObject.location === 'string', `cR addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}'`);\r\n    console.assert(noticeObject.extra !== undefined, \"cR addNoticePartial: 'extra' parameter should be defined\");\r\n    console.assert(typeof noticeObject.extra === 'string', `cR addNoticePartial: 'extra' parameter should be a string not a '${typeof noticeObject.extra}'`);\r\n    // Add in the repoName from the outer scope\r\n    checkRepoResult.noticeList.push({ ...noticeObject, repoName });\r\n  }\r\n\r\n\r\n  async function ourCheckRepoFileContents(bookOrFileCode, cfBookID, filename, file_content, fileLocation, optionalCheckingOptions) {\r\n    // We assume that checking for compulsory fields is done elsewhere\r\n    // console.log(`checkRepo ourCheckRepoFileContents(${filename})…`);\r\n\r\n    // Updates the global list of notices\r\n    console.assert(bookOrFileCode !== undefined, \"ourCheckRepoFileContents: 'bookOrFileCode' parameter should be defined\");\r\n    console.assert(typeof bookOrFileCode === 'string', `ourCheckRepoFileContents: 'bookOrFileCode' parameter should be a string not a '${typeof bookOrFileCode}'`);\r\n    console.assert(cfBookID !== undefined, \"ourCheckRepoFileContents: 'cfBookID' parameter should be defined\");\r\n    console.assert(typeof cfBookID === 'string', `ourCheckRepoFileContents: 'cfBookID' parameter should be a string not a '${typeof cfBookID}'`);\r\n    console.assert(filename !== undefined, \"ourCheckRepoFileContents: 'filename' parameter should be defined\");\r\n    console.assert(typeof filename === 'string', `ourCheckRepoFileContents: 'filename' parameter should be a string not a '${typeof filename}'`);\r\n    console.assert(file_content !== undefined, \"ourCheckRepoFileContents: 'file_content' parameter should be defined\");\r\n    console.assert(typeof file_content === 'string', `ourCheckRepoFileContents: 'file_content' parameter should be a string not a '${typeof file_content}'`);\r\n    console.assert(fileLocation !== undefined, \"ourCheckRepoFileContents: 'fileLocation' parameter should be defined\");\r\n    console.assert(typeof fileLocation === 'string', `ourCheckRepoFileContents: 'fileLocation' parameter should be a string not a '${typeof fileLocation}'`);\r\n\r\n    const cfcResultObject = await checkFileContents(languageCode, filename, file_content, fileLocation, optionalCheckingOptions);\r\n    // console.log(\"checkFileContents() returned\", resultObject.successList.length, \"success message(s) and\", resultObject.noticeList.length, \"notice(s)\");\r\n    // for (const successEntry of resultObject.successList)\r\n    //     console.log(\"  \", successEntry);\r\n\r\n    // Process results line by line,  appending the bookOrFileCode as an extra field as we go\r\n    for (const cfcNoticeEntry of cfcResultObject.noticeList)\r\n      // We add the bookOrFileCode as an extra value\r\n      addNoticePartial({ ...cfcNoticeEntry, bookID: cfBookID, extra: bookOrFileCode });\r\n  }\r\n  // end of ourCheckRepoFileContents function\r\n\r\n\r\n  // Main code for checkRepo()\r\n  // Put all this in a try/catch block coz otherwise it's difficult to debug/view errors\r\n  try {\r\n    let ourLocation = givenLocation;\r\n    if (ourLocation && ourLocation[0] !== ' ') ourLocation = ` ${ourLocation}`;\r\n    // if (ourLocation.indexOf(username) < 0)\r\n    // ourLocation = ` in ${username} ${repoName} ${givenLocation}`\r\n\r\n    // Update our \"waiting\" message\r\n    setResultValue(<p style={{ color: 'magenta' }}>Fetching zipped files from <b>{username}/{repoName}</b> repository…</p>);\r\n\r\n    // Let's fetch the zipped repo since it should be much more efficient than individual fetches\r\n    // console.log(`checkRepo: fetch zip file for ${repoName}…`);\r\n    const fetchRepositoryZipFile_ = (checkingOptions && checkingOptions.fetchRepositoryZipFile) ? checkingOptions.fetchRepositoryZipFile : fetchRepositoryZipFile;\r\n    const zipFetchSucceeded = await fetchRepositoryZipFile_({ username, repository: repoName, branch });\r\n    if (!zipFetchSucceeded) {\r\n      console.error(`checkRepo: misfetched zip file for repo with ${zipFetchSucceeded}`);\r\n      setResultValue(<p style={{ color: 'red' }}>Failed to fetching zipped files from <b>{username}/{repoName}</b> repository</p>);\r\n      addNoticePartial({ priority: 999, message: \"Failed to find/load repository\", location: ourLocation });\r\n      return checkRepoResult;\r\n    }\r\n\r\n    // Now we need to fetch the list of files from the repo\r\n    setResultValue(<p style={{ color: 'magenta' }}>Preprocessing file list from <b>{username}/{repoName}</b> repository…</p>);\r\n    // const pathList = await getFileListFromFetchedTreemaps(username, repoName, branch);\r\n    const getFileListFromZip_ = checkingOptions && checkingOptions.getFileListFromZip ? checkingOptions.getFileListFromZip : getFileListFromZip;\r\n    const pathList = await getFileListFromZip_({ username, repository: repoName, branch });\r\n    // console.log(`Got pathlist (${pathList.length}) = ${pathList}`);\r\n\r\n    // So now we want to work through checking all the files in this repo\r\n    const countString = `${pathList.length.toLocaleString()} file${pathList.length === 1 ? '' : 's'}`;\r\n    let checkedFileCount = 0, checkedFilenames = [], checkedFilenameExtensions = new Set(), totalCheckedSize = 0;\r\n    for (const thisFilepath of pathList) {\r\n      // console.log(`At top of loop: thisFilepath='${thisFilepath}'`);\r\n\r\n      // Update our \"waiting\" message\r\n      setResultValue(<p style={{ color: 'magenta' }}>Checking <b>{username}/{repoName}</b> repo: checked {checkedFileCount.toLocaleString()}/{countString}…</p>);\r\n\r\n      const thisFilename = thisFilepath.split('/').pop();\r\n      // console.log(`thisFilename=${thisFilename}`);\r\n      const thisFilenameExtension = thisFilename.split('.').pop();\r\n      // console.log(`thisFilenameExtension=${thisFilenameExtension}`);\r\n\r\n      // Default to the main filename without the extensions\r\n      let bookOrFileCode = thisFilename.substring(0, thisFilename.length - thisFilenameExtension.length - 1);\r\n      let ourBookID = \"\";\r\n      if (thisFilenameExtension === 'usfm') {\r\n        // const filenameMain = thisFilename.substring(0, thisFilename.length - 5); // drop .usfm\r\n        // console.log(`Have USFM filenameMain=${bookOrFileCode}`);\r\n        const bookID = bookOrFileCode.substring(bookOrFileCode.length - 3);\r\n        // console.log(`Have USFM bookcode=${bookID}`);\r\n        console.assert(books.isValidBookID(bookID), `checkRepo: '${bookID}' is not a valid USFM book identifier`);\r\n        bookOrFileCode = bookID;\r\n        ourBookID = bookID;\r\n      }\r\n      else if (thisFilenameExtension === 'tsv') {\r\n        // const filenameMain = thisFilename.substring(0, thisFilename.length - 4); // drop .tsv\r\n        // console.log(`Have TSV filenameMain=${bookOrFileCode}`);\r\n        const bookID = bookOrFileCode.substring(bookOrFileCode.length - 3);\r\n        // console.log(`Have TSV bookcode=${bookID}`);\r\n        console.assert(books.isValidBookID(bookID), `checkRepo: '${bookID}' is not a valid USFM book identifier`);\r\n        bookOrFileCode = bookID;\r\n        ourBookID = bookID;\r\n      }\r\n\r\n      // console.log(\"checkRepo: Try to load\", username, repoName, thisFilepath, branch);\r\n      const getFile_ = (checkingOptions && checkingOptions.getFile) ? checkingOptions.getFile : getFileCached;\r\n      let repoFileContent;\r\n      try {\r\n        repoFileContent = await getFile_({ username, repository: repoName, path: thisFilepath, branch });\r\n        // console.log(\"Fetched file_content for\", repoName, thisPath, typeof repoFileContent, repoFileContent.length);\r\n      } catch (cRgfError) {\r\n        console.error(\"Failed to load\", username, repoName, thisFilepath, branch, `${cRgfError}`);\r\n        addNoticePartial({ priority: 996, message: \"Failed to load\", bookID: ourBookID, filename: thisFilename, location: `${givenLocation} ${thisFilepath}: ${cRgfError}`, extra: repoName });\r\n        return;\r\n      }\r\n      if (repoFileContent) {\r\n        // console.log(`checkRepo for ${repoName} checking ${thisFilename}`);\r\n        await ourCheckRepoFileContents(bookOrFileCode, ourBookID,\r\n          // OBS has many files with the same name, so we have to give some of the path as well\r\n          repoName.endsWith('_obs') ? thisFilepath.replace('content/', '') : thisFilename,\r\n          repoFileContent, ourLocation, checkingOptions);\r\n        checkedFileCount += 1;\r\n        checkedFilenames.push(thisFilename);\r\n        checkedFilenameExtensions.add(thisFilenameExtension);\r\n        totalCheckedSize += repoFileContent.length;\r\n        // console.log(`checkRepo checked ${thisFilename}`);\r\n        if (thisFilenameExtension !== 'md') // There's often far, far too many of these\r\n          addSuccessMessage(`Checked ${bookOrFileCode.toUpperCase()} file: ${thisFilename}`);\r\n      }\r\n    }\r\n\r\n    // Check that we processed a license and a manifest\r\n    if (checkedFilenames.indexOf('LICENSE.md') < 0)\r\n      addNoticePartial({ priority: 946, message: \"Missing LICENSE.md\", location: ourLocation, extra: 'LICENSE' });\r\n    if (checkedFilenames.indexOf('manifest.yaml') < 0)\r\n      addNoticePartial({ priority: 947, message: \"Missing manifest.yaml\", location: ourLocation, extra: 'MANIFEST' });\r\n\r\n    // Add some extra fields to our checkRepoResult object\r\n    //  in case we need this information again later\r\n    checkRepoResult.checkedFileCount = checkedFileCount;\r\n    checkRepoResult.checkedFilenames = checkedFilenames;\r\n    checkRepoResult.checkedFilenameExtensions = [...checkedFilenameExtensions]; // convert Set to Array\r\n    checkRepoResult.checkedFilesizes = totalCheckedSize;\r\n    checkRepoResult.checkedRepoNames = [`${username}/${repoName}`];\r\n    // checkRepoResult.checkedOptions = checkingOptions; // This is done at the caller level\r\n\r\n    addSuccessMessage(`Checked ${username} repo: ${repoName}`);\r\n    // console.log(`checkRepo() is returning ${checkRepoResult.successList.length.toLocaleString()} success message(s) and ${checkRepoResult.noticeList.length.toLocaleString()} notice(s)`);\r\n  } catch (cRerror) {\r\n    console.error(`checkRepo main code block got error: ${cRerror.message}`);\r\n    setResultValue(<>\r\n      <p style={{ color: 'red' }}>checkRepo main code block got error: <b>{cRerror.message}</b></p>\r\n    </>);\r\n\r\n  }\r\n  checkRepoResult.elapsedSeconds = (new Date() - startTime) / 1000; // seconds\r\n  // console.log(`checkRepo() returning ${JSON.stringify(checkRepoResult)}`);\r\n  return checkRepoResult;\r\n};\r\n// end of checkRepo()\r\n\r\n\r\n/*\r\n    checkFileContents\r\n*/\r\nexport async function checkFileContents(languageCode, filename, fileContent, givenLocation, checkingOptions) {\r\n  // Determine the file type from the filename extension\r\n  //  and return the results of checking that kind of file text\r\n  // console.log(`checkFileContents(${languageCode}, ${filename}, ${fileContent.length} chars, ${givenLocation}, ${JSON.stringify(checkingOptions)})…`);\r\n  const startTime = new Date();\r\n\r\n  let ourCFLocation = givenLocation;\r\n  if (ourCFLocation[0] !== ' ') ourCFLocation = ' ' + ourCFLocation;\r\n\r\n  let checkFileResult;\r\n  if (filename.toLowerCase().endsWith('.tsv')) {\r\n    const filenameMain = filename.substring(0, filename.length - 4); // drop .tsv\r\n    // console.log(`Have TSV filenameMain=${filenameMain}`);\r\n    const bookID = filenameMain.substring(filenameMain.length - 3);\r\n    // console.log(`Have TSV bookcode=${bookID}`);\r\n    console.assert(books.isValidBookID(bookID), `checkFileContents: '${bookID}' is not a valid USFM book identifier`);\r\n    checkFileResult = await checkTN_TSVText(languageCode, bookID, filename, fileContent, ourCFLocation, checkingOptions);\r\n  }\r\n  else if (filename.toLowerCase().endsWith('.usfm')) {\r\n    const filenameMain = filename.substring(0, filename.length - 5); // drop .usfm\r\n    // console.log(`Have USFM filenameMain=${filenameMain}`);\r\n    const bookID = filenameMain.substring(filenameMain.length - 3);\r\n    // console.log(`Have USFM bookcode=${bookID}`);\r\n    console.assert(books.isValidBookID(bookID), `checkFileContents: '${bookID}' is not a valid USFM book identifier`);\r\n    checkFileResult = checkUSFMText(languageCode, bookID, filename, fileContent, ourCFLocation, checkingOptions);\r\n  } else if (filename.toLowerCase().endsWith('.sfm')) {\r\n    const filenameMain = filename.substring(0, filename.length - 4); // drop .sfm\r\n    console.log(`Have SFM filenameMain=${filenameMain}`);\r\n    const bookID = filenameMain.substring(2, 5);\r\n    console.log(`Have SFM bookcode=${bookID}`);\r\n    console.assert(books.isValidBookID(bookID), `checkFileContents: '${bookID}' is not a valid USFM book identifier`);\r\n    checkFileResult = checkUSFMText(languageCode, bookID, filename, fileContent, ourCFLocation, checkingOptions);\r\n  } else if (filename.toLowerCase().endsWith('.md'))\r\n    checkFileResult = checkMarkdownText(filename, fileContent, ourCFLocation, checkingOptions);\r\n  else if (filename.toLowerCase().endsWith('.txt'))\r\n    checkFileResult = checkPlainText(filename, fileContent, ourCFLocation, checkingOptions);\r\n  else if (filename.toLowerCase() === 'manifest.yaml')\r\n    checkFileResult = checkManifestText(filename, fileContent, ourCFLocation, checkingOptions);\r\n  else if (filename.toLowerCase().endsWith('.yaml'))\r\n    checkFileResult = checkYAMLText(filename, fileContent, ourCFLocation, checkingOptions);\r\n  else {\r\n    checkFileResult = checkPlainText(filename, fileContent, ourCFLocation, checkingOptions);\r\n    checkFileResult.noticeList.unshift({ priority: 995, message: \"File extension is not recognized, so treated as plain text.\", filename, location: filename });\r\n  }\r\n  // console.log(`checkFileContents got initial results with ${checkFileResult.successList.length} success message(s) and ${checkFileResult.noticeList.length} notice(s)`);\r\n\r\n  // Add some extra fields to our checkFileResult object\r\n  //  in case we need this information again later\r\n  checkFileResult.checkedFileCount = 1;\r\n  checkFileResult.checkedFilename = filename;\r\n  checkFileResult.checkedFilesize = fileContent.length;\r\n  checkFileResult.checkedOptions = checkingOptions;\r\n\r\n  checkFileResult.elapsedSeconds = (new Date() - startTime) / 1000; // seconds\r\n  // console.log(`checkFileContents() returning ${JSON.stringify(checkFileResult)}`);\r\n  return checkFileResult;\r\n};\r\n// end of checkFileContents()\r\n\r\n\r\n/*\r\n    checkTQbook\r\n*/\r\nexport async function checkTQbook(username, languageCode, repoName, branch, bookID, checkingOptions) {\r\n  // console.log(`checkTQbook(${username}, ${repoName}, ${branch}, ${bookID}, ${JSON.stringify(checkingOptions)})…`)\r\n  const repoCode = 'TQ';\r\n  const generalLocation = ` in ${username} (${branch})`;\r\n\r\n  const ctqResult = { successList: [], noticeList: [] };\r\n\r\n  function addSuccessMessage(successString) {\r\n    // console.log(`checkBookPackage success: ${successString}`);\r\n    ctqResult.successList.push(successString);\r\n  }\r\n\r\n  function addNoticePartial(noticeObject) {\r\n    // bookID is a three-character UPPERCASE USFM book identifier or 'OBS'.\r\n    // console.log(`checkTQbook addNoticePartial: ${noticeObject.priority}:${noticeObject.message} ${noticeObject.bookID} ${noticeObject.C}:${noticeObject.V} ${noticeObject.filename}:${noticeObject.lineNumber} ${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : \"\"}${noticeObject.extract ? ` ${noticeObject.extract}` : \"\"}${noticeObject.location}`);\r\n    console.assert(noticeObject.priority !== undefined, \"cTQ addNoticePartial: 'priority' parameter should be defined\");\r\n    console.assert(typeof noticeObject.priority === 'number', `cTQ addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}'`);\r\n    console.assert(noticeObject.message !== undefined, \"cTQ addNoticePartial: 'message' parameter should be defined\");\r\n    console.assert(typeof noticeObject.message === 'string', `cTQ addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}'`);\r\n    console.assert(noticeObject.bookID !== undefined, \"cTQ addNoticePartial: 'bookID' parameter should be defined\");\r\n    console.assert(typeof noticeObject.bookID === 'string', `cTQ addNoticePartial: 'bookID' parameter should be a string not a '${typeof noticeObject.bookID}'`);\r\n    console.assert(noticeObject.bookID.length === 3, `cTQ addNoticePartial: 'bookID' parameter should be three characters long not ${noticeObject.bookID.length}`);\r\n    console.assert(books.isValidBookID(noticeObject.bookID), `cTQ addNoticePartial: '${noticeObject.bookID}' is not a valid USFM book identifier`);\r\n    // console.assert(C !== undefined, \"cTQ addNoticePartial: 'C' parameter should be defined\");\r\n    if (noticeObject.C) console.assert(typeof noticeObject.C === 'string', `cTQ addNoticePartial: 'C' parameter should be a string not a '${typeof noticeObject.C}'`);\r\n    // console.assert(V !== undefined, \"cTQ addNoticePartial: 'V' parameter should be defined\");\r\n    if (noticeObject.V) console.assert(typeof noticeObject.V === 'string', `cTQ addNoticePartial: 'V' parameter should be a string not a '${typeof noticeObject.V}'`);\r\n    // console.assert(characterIndex !== undefined, \"cTQ addNoticePartial: 'characterIndex' parameter should be defined\");\r\n    if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cTQ addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}'`);\r\n    // console.assert(extract !== undefined, \"cTQ addNoticePartial: 'extract' parameter should be defined\");\r\n    if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cTQ addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}'`);\r\n    console.assert(noticeObject.location !== undefined, \"cTQ addNoticePartial: 'location' parameter should be defined\");\r\n    console.assert(typeof noticeObject.location === 'string', `cTQ addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}'`);\r\n    console.assert(noticeObject.extra !== undefined, \"cTQ addNoticePartial: 'extra' parameter should be defined\");\r\n    console.assert(typeof noticeObject.extra === 'string', `cTQ addNoticePartial: 'extra' parameter should be a string not a '${typeof noticeObject.extra}'`);\r\n    ctqResult.noticeList.push({ ...noticeObject, repoName, bookID });\r\n  }\r\n\r\n\r\n  async function ourCheckTQFileContents(repoCode, bookID, C, V, cfFilename, file_content, fileLocation, optionalCheckingOptions) {\r\n    // console.log(`checkBookPackage ourCheckTQFileContents(${cfFilename})`);\r\n\r\n    // Updates the global list of notices\r\n    console.assert(repoCode !== undefined, \"cTQ ourCheckTQFileContents: 'repoCode' parameter should be defined\");\r\n    console.assert(typeof repoCode === 'string', `cTQ ourCheckTQFileContents: 'repoCode' parameter should be a string not a '${typeof repoCode}'`);\r\n    console.assert(cfFilename !== undefined, \"cTQ ourCheckTQFileContents: 'cfFilename' parameter should be defined\");\r\n    console.assert(typeof cfFilename === 'string', `cTQ ourCheckTQFileContents: 'cfFilename' parameter should be a string not a '${typeof cfFilename}'`);\r\n    console.assert(file_content !== undefined, \"cTQ ourCheckTQFileContents: 'file_content' parameter should be defined\");\r\n    console.assert(typeof file_content === 'string', `cTQ ourCheckTQFileContents: 'file_content' parameter should be a string not a '${typeof file_content}'`);\r\n    console.assert(fileLocation !== undefined, \"cTQ ourCheckTQFileContents: 'fileLocation' parameter should be defined\");\r\n    console.assert(typeof fileLocation === 'string', `cTQ ourCheckTQFileContents: 'fileLocation' parameter should be a string not a '${typeof fileLocation}'`);\r\n\r\n    const cfResultObject = await checkFileContents(languageCode, cfFilename, file_content, fileLocation, optionalCheckingOptions);\r\n    // console.log(\"checkFileContents() returned\", cfResultObject.successList.length, \"success message(s) and\", cfResultObject.noticeList.length, \"notice(s)\");\r\n    // for (const successEntry of cfResultObject.successList) console.log(\"  ourCheckTQFileContents:\", successEntry);\r\n\r\n    // Process results line by line,  appending the repoCode as an extra field as we go\r\n    for (const noticeEntry of cfResultObject.noticeList) {\r\n      // noticeEntry is an array of eight fields: 1=priority, 2=bookID, 3=C, 4=V, 5=msg, 6=characterIndex, 7=extract, 8=location\r\n      // console.assert(Object.keys(noticeEntry).length === 5, `cTQ ourCheckTQFileContents notice length=${Object.keys(noticeEntry).length}`);\r\n      // We add the repoCode as an extra value\r\n      addNoticePartial({ ...noticeEntry, bookID, C, V, extra: repoCode });\r\n    }\r\n  }\r\n  // end of ourCheckTQFileContents function\r\n\r\n\r\n  // Main code for checkTQbook\r\n  // We need to find an check all the markdown folders/files for this book\r\n  let checkedFileCount = 0, checkedFilenames = [], checkedFilenameExtensions = new Set(['md']), totalCheckedSize = 0;\r\n  const getFileListFromZip_ = checkingOptions && checkingOptions.getFileListFromZip ? checkingOptions.getFileListFromZip : getFileListFromZip;\r\n  const bookIdLc = bookID.toLowerCase();\r\n  let pathList = await getFileListFromZip_({ username, repository: repoName, branch, optionalPrefix: `${bookIdLc}/` });\r\n  if (!Array.isArray(pathList) || !pathList.length) {\r\n    console.error(\"checkTQrepo failed to load\", username, repoName, branch);\r\n    addNoticePartial({ priority: 996, message: \"Failed to load\", bookID, location: generalLocation, extra: repoCode });\r\n  } else {\r\n\r\n    // console.log(`  Got ${pathList.length} pathList entries`)\r\n    for (const thisPath of pathList) {\r\n      // console.log(\"checkTQbook: Try to load\", username, repoName, thisPath, branch);\r\n\r\n      console.assert(thisPath.endsWith('.md'), `Expected ${thisPath} to end with .md`);\r\n      const filename = thisPath.split('/').pop();\r\n      const pathParts = thisPath.slice(0, -3).split('/');\r\n      const C = pathParts[pathParts.length - 2].replace(/^0+(?=\\d)/, ''); // Remove leading zeroes\r\n      const V = pathParts[pathParts.length - 1].replace(/^0+(?=\\d)/, ''); // Remove leading zeroes\r\n\r\n      const getFile_ = (checkingOptions && checkingOptions.getFile) ? checkingOptions.getFile : getFileCached;\r\n      let tqFileContent;\r\n      try {\r\n        tqFileContent = await getFile_({ username, repository: repoName, path: thisPath, branch });\r\n        // console.log(\"Fetched file_content for\", repoName, thisPath, typeof tqFileContent, tqFileContent.length);\r\n        checkedFilenames.push(thisPath);\r\n        totalCheckedSize += tqFileContent.length;\r\n      } catch (tQerror) {\r\n        console.error(\"checkTQbook failed to load\", username, repoName, thisPath, branch, tQerror + '');\r\n        addNoticePartial({ priority: 996, message: \"Failed to load\", bookID, C, V, location: `${generalLocation} ${thisPath}: ${tQerror}`, extra: repoCode });\r\n        continue;\r\n      }\r\n\r\n      // We use the generalLocation here (does not include repo name)\r\n      //  so that we can adjust the returned strings ourselves\r\n      await ourCheckTQFileContents(repoCode, bookID, C, V, filename, tqFileContent, generalLocation, checkingOptions); // Adds the notices to checkBookPackageResult\r\n      checkedFileCount += 1;\r\n      // addSuccessMessage(`Checked ${repoCode.toUpperCase()} file: ${thisPath}`);\r\n    }\r\n    addSuccessMessage(`Checked ${checkedFileCount.toLocaleString()} ${repoCode.toUpperCase()} file${checkedFileCount === 1 ? '' : 's'}`);\r\n  }\r\n\r\n  ctqResult.checkedFileCount = checkedFileCount;\r\n  ctqResult.checkedFilenames = checkedFilenames;\r\n  ctqResult.checkedFilenameExtensions = [...checkedFilenameExtensions]; // convert Set to Array\r\n  ctqResult.checkedFilesizes = totalCheckedSize;\r\n  // console.log(`  checkTQbook returning ${JSON.stringify(ctqResult)}`);\r\n  return ctqResult;\r\n}\r\n// end of checkTQbook function\r\n\r\n\r\n/*\r\n    checkBookPackage\r\n*/\r\n/**\r\n *\r\n * @param {string} username\r\n * @param {string} languageCode\r\n * @param {string} bookID\r\n * @param {Function} setResultValue\r\n * @param {Object} checkingOptions\r\n */\r\nexport async function checkBookPackage(username, languageCode, bookID, setResultValue, checkingOptions) {\r\n  /*\r\n  Note: You may want to run clearCaches() before running this function???\r\n\r\n  Note that bookID here can also be the 'OBS' pseudo bookID.\r\n  */\r\n  // console.log(`checkBookPackage(${username}, ${languageCode}, ${bookID}, …, ${JSON.stringify(checkingOptions)})…`)\r\n  const startTime = new Date();\r\n  bookID = bookID.toUpperCase(); // normalise to USFM standard\r\n\r\n  let checkBookPackageResult = { successList: [], noticeList: [] };\r\n\r\n  const newCheckingOptions = checkingOptions ? { ...checkingOptions } : {}; // clone before modify\r\n  const getFile_ = newCheckingOptions.getFile ? newCheckingOptions.getFile : getFileCached; // default to using caching of files\r\n  newCheckingOptions.getFile = getFile_; // use same getFile_ when we call core functions\r\n  if (!newCheckingOptions.originalLanguageRepoUsername) newCheckingOptions.originalLanguageRepoUsername = username;\r\n  if (!newCheckingOptions.taRepoUsername) newCheckingOptions.taRepoUsername = username;\r\n\r\n  // No point in passing the branch through as a parameter\r\n  //  coz if it's not 'master', it's unlikely to be common for all the repos\r\n  const branch = 'master';\r\n\r\n  const generalLocation = ` in ${languageCode} ${bookID} book package from ${username} ${branch} branch`;\r\n\r\n\r\n  function addSuccessMessage(successString) {\r\n    // console.log(`checkBookPackage success: ${successString}`);\r\n    checkBookPackageResult.successList.push(successString);\r\n  }\r\n\r\n  function addNoticePartial(noticeObject) {\r\n    // bookID is a three-character UPPERCASE USFM book identifier or 'OBS'.\r\n    // console.log(`checkBookPackage addNoticePartial: (priority=${noticeObject.priority}) ${noticeObject.bookID} ${noticeObject.C}:${noticeObject.V} ${noticeObject.message}${noticeObject.characterIndex > 0 ? ` (at character ${noticeObject.characterIndex})` : \"\"}${extract ? ` ${extract}` : \"\"}${location}`);\r\n    console.assert(noticeObject.priority !== undefined, \"cBP addNoticePartial: 'priority' parameter should be defined\");\r\n    console.assert(typeof noticeObject.priority === 'number', `cBP addNoticePartial: 'priority' parameter should be a number not a '${typeof noticeObject.priority}'`);\r\n    console.assert(noticeObject.message !== undefined, \"cBP addNoticePartial: 'message' parameter should be defined\");\r\n    console.assert(typeof noticeObject.message === 'string', `cBP addNoticePartial: 'message' parameter should be a string not a '${typeof noticeObject.message}'`);\r\n    // console.assert(bookID !== undefined, \"cBP addNoticePartial: 'bookID' parameter should be defined\");\r\n    if (noticeObject.bookID) {\r\n      console.assert(typeof noticeObject.bookID === 'string', `cBP addNoticePartial: 'bookID' parameter should be a string not a '${typeof noticeObject.bookID}'`);\r\n      console.assert(noticeObject.bookID.length === 3, `cBP addNoticePartial: 'bookID' parameter should be three characters long not ${noticeObject.bookID.length}`);\r\n      console.assert(books.isValidBookID(noticeObject.bookID), `cBP addNoticePartial: '${noticeObject.bookID}' is not a valid USFM book identifier`);\r\n    }\r\n    // console.assert(C !== undefined, \"cBP addNoticePartial: 'C' parameter should be defined\");\r\n    if (noticeObject.C) console.assert(typeof noticeObject.C === 'string', `cBP addNoticePartial: 'C' parameter should be a string not a '${typeof noticeObject.C}'`);\r\n    // console.assert(V !== undefined, \"cBP addNoticePartial: 'V' parameter should be defined\");\r\n    if (noticeObject.V) console.assert(typeof noticeObject.V === 'string', `cBP addNoticePartial: 'V' parameter should be a string not a '${typeof noticeObject.V}'`);\r\n    // console.assert(characterIndex !== undefined, \"cBP addNoticePartial: 'characterIndex' parameter should be defined\");\r\n    if (noticeObject.characterIndex) console.assert(typeof noticeObject.characterIndex === 'number', `cBP addNoticePartial: 'characterIndex' parameter should be a number not a '${typeof noticeObject.characterIndex}'`);\r\n    // console.assert(extract !== undefined, \"cBP addNoticePartial: 'extract' parameter should be defined\");\r\n    if (noticeObject.extract) console.assert(typeof noticeObject.extract === 'string', `cBP addNoticePartial: 'extract' parameter should be a string not a '${typeof noticeObject.extract}'`);\r\n    console.assert(noticeObject.location !== undefined, \"cBP addNoticePartial: 'location' parameter should be defined\");\r\n    console.assert(typeof noticeObject.location === 'string', `cBP addNoticePartial: 'location' parameter should be a string not a '${typeof noticeObject.location}'`);\r\n    console.assert(noticeObject.extra !== undefined, \"cBP addNoticePartial: 'extra' parameter should be defined\");\r\n    console.assert(typeof noticeObject.extra === 'string', `cBP addNoticePartial: 'extra' parameter should be a string not a '${typeof noticeObject.extra}'`);\r\n    checkBookPackageResult.noticeList.push({ ...noticeObject, bookID });\r\n  }\r\n\r\n\r\n  async function ourCheckBPFileContents(repoCode, cfFilename, file_content, fileLocation, optionalCheckingOptions) {\r\n    // console.log(`checkBookPackage ourCheckBPFileContents(${repoCode}, ${cfFilename}, ${file_content.length}, ${fileLocation}, ${JSON.stringify(optionalCheckingOptions)})…`);\r\n\r\n    // Updates the global list of notices\r\n    console.assert(repoCode !== undefined, \"cBP ourCheckBPFileContents: 'repoCode' parameter should be defined\");\r\n    console.assert(typeof repoCode === 'string', `cBP ourCheckBPFileContents: 'repoCode' parameter should be a string not a '${typeof repoCode}'`);\r\n    console.assert(cfFilename !== undefined, \"cBP ourCheckBPFileContents: 'cfFilename' parameter should be defined\");\r\n    console.assert(typeof cfFilename === 'string', `cBP ourCheckBPFileContents: 'cfFilename' parameter should be a string not a '${typeof cfFilename}'`);\r\n    console.assert(file_content !== undefined, \"cBP ourCheckBPFileContents: 'file_content' parameter should be defined\");\r\n    console.assert(typeof file_content === 'string', `cBP ourCheckBPFileContents: 'file_content' parameter should be a string not a '${typeof file_content}'`);\r\n    console.assert(fileLocation !== undefined, \"cBP ourCheckBPFileContents: 'fileLocation' parameter should be defined\");\r\n    console.assert(typeof fileLocation === 'string', `cBP ourCheckBPFileContents: 'fileLocation' parameter should be a string not a '${typeof fileLocation}'`);\r\n\r\n    const cfcResultObject = await checkFileContents(languageCode, cfFilename, file_content, fileLocation, optionalCheckingOptions);\r\n    // console.log(\"checkFileContents() returned\", cfResultObject.successList.length, \"success message(s) and\", cfResultObject.noticeList.length, \"notice(s)\");\r\n    // for (const successEntry of cfResultObject.successList) console.log(\"  ourCheckBPFileContents:\", successEntry);\r\n    // console.log(\"cfcResultObject\", JSON.stringify(cfcResultObject));\r\n\r\n    // Process results line by line,  appending the repoCode as an extra field as we go\r\n    for (const cfcNoticeEntry of cfcResultObject.noticeList)\r\n      // noticeEntry is an object\r\n      // We add the repoCode as an extra value\r\n      addNoticePartial({ ...cfcNoticeEntry, filename: cfFilename, extra: repoCode });\r\n  }\r\n  // end of ourCheckBPFileContents function\r\n\r\n\r\n  // Main code for checkBookPackage()\r\n  // console.log(\"checkBookPackage() main code…\");\r\n  if (bookID === 'OBS') {\r\n    // We use the generalLocation here (does not include repo name)\r\n    //  so that we can adjust the returned strings ourselves\r\n    // console.log(\"Calling OBS checkRepo()…\");\r\n    checkBookPackageResult = await checkRepo(username, `${languageCode}_obs`, branch, generalLocation, setResultValue, newCheckingOptions); // Adds the notices to checkBookPackageResult\r\n    // console.log(`checkRepo() returned ${checkBookPackageResult.successList.length} success message(s) and ${checkBookPackageResult.noticeList.length} notice(s)`);\r\n    // console.log(\"crResultObject keys\", JSON.stringify(Object.keys(checkBookPackageResult)));\r\n\r\n    // Concat is faster if we don't need to process each notice individually\r\n    // checkBookPackageResult.successList = checkBookPackageResult.successList.concat(crResultObject.successList);\r\n    // checkBookPackageResult.noticeList = checkBookPackageResult.noticeList.concat(crResultObject.noticeList);\r\n    // checkedFileCount += crResultObject.fileCount;\r\n    addSuccessMessage(`Checked ${languageCode} OBS repo from ${username}`);\r\n  } else { // not OBS\r\n    // We also need to know the number for USFM books\r\n    let bookNumberAndName, whichTestament;\r\n    try {\r\n      bookNumberAndName = books.usfmNumberNameById(bookID);\r\n      whichTestament = books.testament(bookID); // returns 'old' or 'new'\r\n    } catch (bNNerror) {\r\n      if (books.isValidBookID(bookID)) // must be in FRT, BAK, etc.\r\n        whichTestament = 'other'\r\n      else {\r\n        addNoticePartial({ priority: 902, message: \"Bad function call: should be given a valid book abbreviation\", extract: bookID, location: ` (not '${bookID}')${generalLocation}` }); return checkBookPackageResult;\r\n      }\r\n    }\r\n    // console.log(`checkBookPackage: bookNumberAndName='${bookNumberAndName}' (${whichTestament} testament)`);\r\n\r\n    // So now we want to work through checking this one specified Bible book in various repos:\r\n    //  UHB/UGNT, ULT/GLT, UST/GST, TN, TQ\r\n    const getFile_ = (newCheckingOptions && newCheckingOptions.getFile) ? newCheckingOptions.getFile : getFileCached;\r\n    let checkedFileCount = 0, checkedFilenames = [], checkedFilenameExtensions = new Set(), totalCheckedSize = 0, checkedRepoNames = [];\r\n    const origLang = whichTestament === 'old' ? 'UHB' : 'UGNT';\r\n\r\n    const repoCodeList = [origLang, 'LT', 'ST', 'TN', 'TQ'];\r\n    for (const repoCode of repoCodeList) {\r\n      // console.log(`checkBookPackage: check ${bookID} in ${repoCode} (${languageCode} ${bookID} from ${username})`);\r\n      const repoLocation = ` in ${repoCode.toUpperCase()}${generalLocation}`;\r\n      const repoName = formRepoName(languageCode, repoCode);\r\n\r\n      // Update our \"waiting\" message\r\n      setResultValue(<p style={{ color: 'magenta' }}>Checking {username} {languageCode} <b>{bookID}</b> book package in <b>{repoCode}</b> (checked <b>{checkedRepoNames.length.toLocaleString()}</b>/{repoCodeList.length} repos)…</p>);\r\n\r\n      let filename;\r\n      if (repoCode === 'UHB' || repoCode === 'UGNT' || repoCode === 'LT' || repoCode === 'ST') {\r\n        // TODO: Might we need specific releases/tags for some of these (e.g., from the TN manifest)???\r\n        // TODO: Do we need to hard-code where to find the UHB and UGNT???\r\n        filename = `${bookNumberAndName}.usfm`;\r\n        checkedFilenameExtensions.add('usfm');\r\n      }\r\n      else if (repoCode === 'TN') {\r\n        try {\r\n        filename = await cachedGetBookFilenameFromManifest({ username, repository: repoName, branch, bookID: bookID.toLowerCase() });\r\n        console.assert(filename.startsWith(`${languageCode}_`), `Expected TN filename '${filename}' to start with the language code '${languageCode}_'`);\r\n        } catch (e) {\r\n          console.error(`cachedGetBookFilenameFromManifest failed with: ${e}`);\r\n          filename = `${languageCode}_tn_${bookNumberAndName}.tsv`;\r\n        }\r\n        console.assert(filename.endsWith('.tsv'), `Expected TN filename '${filename}' to end with '.tsv'`);\r\n        checkedFilenameExtensions.add('tsv');\r\n      }\r\n\r\n      if (repoCode === 'TQ') {\r\n        // This resource might eventually be converted to TSV tables\r\n        const tqResultObject = await checkTQbook(username, languageCode, repoName, branch, bookID, newCheckingOptions);\r\n        checkBookPackageResult.successList = checkBookPackageResult.successList.concat(tqResultObject.successList);\r\n        checkBookPackageResult.noticeList = checkBookPackageResult.noticeList.concat(tqResultObject.noticeList);\r\n        checkedFilenames = checkedFilenames.concat(tqResultObject.checkedFilenames);\r\n        checkedFilenameExtensions = new Set([...checkedFilenameExtensions, ...tqResultObject.checkedFilenameExtensions]);\r\n        checkedFileCount += tqResultObject.checkedFileCount;\r\n        totalCheckedSize += tqResultObject.totalCheckedSize;\r\n        checkedRepoNames.push(repoCode);\r\n      } else { // For repos other than TQ, we only have one file to check\r\n        // console.log(\"Try to load\", username, repoName, filename, branch);\r\n        let repoFileContent;\r\n        try {\r\n          // console.log(\"checkBookPackage about to fetch file_content for\", username, repoName, branch, filename);\r\n          repoFileContent = await getFile_({ username, repository: repoName, path: filename, branch });\r\n          // console.log(\"checkBookPackage fetched file_content for\", username, repoName, branch, filename, typeof repoFileContent, repoFileContent.length);\r\n          checkedFilenames.push(filename);\r\n          totalCheckedSize += repoFileContent.length;\r\n          checkedRepoNames.push(repoCode);\r\n        } catch (cBPgfError) {\r\n          console.error(\"Failed to load\", username, repoName, filename, branch, cBPgfError + '');\r\n          addNoticePartial({ priority: 996, message: \"Failed to load\", repoName, filename, location: `${repoLocation}: ${cBPgfError}`, extra: repoCode });\r\n          continue;\r\n        }\r\n\r\n        // We use the generalLocation here (does not include repo name)\r\n        //  so that we can adjust the returned strings ourselves\r\n        await ourCheckBPFileContents(repoCode, filename, repoFileContent, generalLocation, newCheckingOptions); // Adds the notices to checkBookPackageResult\r\n        checkedFileCount += 1;\r\n        addSuccessMessage(`Checked ${repoCode.toUpperCase()} file: ${filename}`);\r\n      }\r\n    }\r\n\r\n    // Add some extra fields to our checkFileResult object\r\n    //  in case we need this information again later\r\n    checkBookPackageResult.checkedFileCount = checkedFileCount;\r\n    checkBookPackageResult.checkedFilenames = checkedFilenames;\r\n    checkBookPackageResult.checkedFilenameExtensions = [...checkedFilenameExtensions]; // convert Set to Array\r\n    checkBookPackageResult.checkedFilesizes = totalCheckedSize;\r\n    checkBookPackageResult.checkedRepoNames = checkedRepoNames;\r\n    // checkBookPackageResult.checkedOptions = newCheckingOptions; // This is done at the caller level\r\n  }\r\n\r\n  checkBookPackageResult.elapsedSeconds = (new Date() - startTime) / 1000; // seconds\r\n  // console.log(\"checkBookPackageResult:\", JSON.stringify(checkBookPackageResult));\r\n  console.log(`checkBookPackageResult(${bookID}): elapsedSeconds = ${checkBookPackageResult.elapsedSeconds}, notices count = ${checkBookPackageResult.noticeList.length}`);\r\n  return checkBookPackageResult;\r\n};\r\n// end of checkBookPackage()\r\n","// utilities\r\nimport * as books from 'uw-content-validation';\r\n\r\n// function to convert an array to an object\r\n// with keys being 0..n\r\nexport const array_to_obj = ( (ar: any) => {\r\n    const ob = {};\r\n    Object.assign(ob,ar);\r\n    return ob;\r\n});\r\n\r\n// function to convert map to object\r\nexport const map_to_obj = ( (mp: any[]) => {\r\n    const ob: any = {};\r\n    mp.forEach((v: any,k: any) => {ob[k]=v});\r\n    return ob;\r\n});\r\n\r\n// function to convert object to a map\r\nexport const obj_to_map = ( (ob: { [x: string]: any; }) => {\r\n    const mp = new Map();\r\n    Object.keys ( ob ).forEach (k => { mp.set(k, ob[k]) });\r\n    return mp;\r\n});\r\n\r\n\r\ninterface ObjectLiteral {\r\n    [key: string]: any;\r\n}\r\n\r\n/**\r\n * create link to repo\r\n * @param repo\r\n * @param username\r\n * @param languageCode\r\n * @param bookID\r\n * @param lineNum\r\n * @param branch\r\n */\r\nexport const getLink = (repo: string, username: string, languageCode: string, bookID: string, lineNum: string, branch = `master`) => {\r\n    let repoName = `${languageCode.toLowerCase()}_${repo.toLowerCase()}`;\r\n    let extension = 'usfm';\r\n    let view = 'src';\r\n    let namePrefix = '';\r\n    let repoUC = repo.toUpperCase();\r\n    if (repoUC === 'UHB') {\r\n        repoName = 'hbo_uhb';\r\n    }\r\n    if (repoUC === 'UGNT') {\r\n        repoName = 'el-x-koine_ugnt';\r\n    }\r\n    if (repoUC === 'TN') {\r\n        view = 'blame';\r\n        extension = 'tsv';\r\n        namePrefix = `${repoName}_`;\r\n    }\r\n    if (['TN', 'UHB', 'UGNT', 'ULT', 'UST'].includes(repoUC)) {\r\n        let bookNumberAndName;\r\n        try {\r\n            bookNumberAndName = books.usfmNumberName(bookID).toUpperCase();\r\n            let link = `https://git.door43.org/${username}/${repoName}/${view}/branch/${branch}/${namePrefix}${bookNumberAndName}.${extension}`;\r\n            if (lineNum) {\r\n                link += `#L${lineNum}`;\r\n            }\r\n            return link;\r\n            // const anchor = `<a href=\"${link}\" target=\"_blank\">${lineNum}</a>`;\r\n            // return anchor;\r\n        } catch (e) {}\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * remove columns that don't have any data\r\n * @param rows\r\n * @param columns\r\n */\r\nexport const trimColumns = (rows: any[], columns: any[]) => {\r\n    const newColumns = [];\r\n    for (let column of columns) {\r\n        const { field, title } = column;\r\n        let hasData = false;\r\n\r\n        for (let row of rows) {\r\n            const cellData = row[field]\r\n            if (cellData) {\r\n                hasData = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (hasData) {\r\n            newColumns.push(column);\r\n        } else {\r\n            console.log(`Removing column \"${title}\" because no data found`);\r\n        }\r\n    }\r\n    return newColumns;\r\n}\r\n\r\n/**\r\n * converts strings to numbers\r\n * @param value\r\n */\r\nexport const stringToNumber = (value: any) => {\r\n    if (typeof value === 'string') {\r\n        const num = parseInt(value, 10);\r\n        if (!isNaN(num)) {\r\n            return num;\r\n        }\r\n    }\r\n    return NaN;\r\n}\r\n\r\n/**\r\n * string compare that attempts to do numerical sorting fist and then will sort by string\r\n * @param a\r\n * @param b\r\n */\r\nexport const somewhatNumericalSort = (a: any, b: any) => {\r\n    const aNum = stringToNumber(a);\r\n    const bNum = stringToNumber(b);\r\n    const aStr = a || \"\";\r\n    const bStr = b || \"\";\r\n\r\n    if (!isNaN(aNum) && !isNaN(bNum)) { // if both are numbers then do numerical compare\r\n        return aNum - bNum;\r\n    }\r\n\r\n    if (isNaN(aNum) && isNaN(bNum)) { // if both are not numbers then do a string compare\r\n        return aStr > bStr ? 1 : ( aStr === bStr ? 0 : -1);\r\n    }\r\n\r\n    if (isNaN(aNum)) {\r\n        return -1;  // non-numeric strings less than numbers\r\n    }\r\n    return 1;\r\n}\r\n\r\n/**\r\n * sort by chapter first and then by verse if same chapter\r\n * @param a\r\n * @param b\r\n */\r\nexport const sortChapterVerse = (a: any, b: any) => {\r\n    let results = somewhatNumericalSort(a.C, b.C);\r\n    if (results === 0) { // if chapters are same, then sort on verse\r\n        results = somewhatNumericalSort(a.V, b.V);\r\n    }\r\n    return results;\r\n}\r\n\r\n/* Sample of Warnings List:\r\n    C: \"1\"\r\n    V: \"1\"\r\n    bookID: \"2PE\"\r\n    characterIndex: undefined\r\n    extract: undefined\r\n    lineNumber: 4\r\n    location: \" with ID 'n1di' en 2pe book package from unfoldingword\"\r\n    message: \"TN Missing OrigQuote field\"\r\n    priority: 276\r\n*/\r\n// function to convert word frequency map\r\n// to an object suitable for MaterialTable\r\nexport const notices_to_mt = ( ob: { [x: string]: any; }, username: string, languageCode: string, bookID: string, \r\n    renderLink: any, renderWithUnicodeLink: any, renderPriority: any) => \r\n{\r\n    let mt: ObjectLiteral = {};\r\n    mt.title = \"Validation Notices\";\r\n    mt.columns = [\r\n        { title: 'Repo', field: 'extra' },\r\n        { \r\n            title: 'Pri', \r\n            field: 'priority',\r\n            render: (rowData: any) => (renderPriority(rowData.priority))\r\n        },\r\n        {\r\n            title: 'Ch',\r\n            field: 'C',\r\n            customSort: (a: any, b: any) => sortChapterVerse(a, b)\r\n        },\r\n        {\r\n            title: 'Vs',\r\n            field: 'V',\r\n            customSort: (a: any, b: any) => somewhatNumericalSort(a.V, b.V)\r\n        },\r\n        {\r\n            title: 'Line',\r\n            field: 'lineNumber',\r\n            render: (rowData: any) => (renderLink(rowData.link, rowData.lineNumber))\r\n        },\r\n        { title: 'Row ID', field: 'rowID' },\r\n        { title: 'Field Name', field: 'fieldName' },\r\n        { title: 'Details', field: 'details' },\r\n        { title: 'Char Pos', field: 'charPos' },\r\n        {\r\n            title: 'Excerpt',\r\n            field: 'excerpt',\r\n            cellStyle: {\r\n                fontFamily: \"Ezra, Roboto, Helvetica, Arial, sans-serif\"\r\n            },\r\n            render: (rowData: any) => (renderWithUnicodeLink(rowData.excerpt))\r\n        },\r\n        {\r\n            title: 'Message',\r\n            field: 'message',\r\n            cellStyle: {\r\n                fontFamily: \"Ezra, Roboto, Helvetica, Arial, sans-serif\",\r\n                width: `400px`\r\n            },\r\n        },\r\n        { title: 'Location', field: 'location' },\r\n    ];\r\n    mt.data = [];\r\n    Object.keys(ob).forEach ( key => {\r\n        const rowData = ob[key];\r\n        let _location = rowData.location;\r\n        _location = _location.replace(/en ... book package from unfoldingword/, '' );\r\n        let _link = getLink(rowData.extra, username, languageCode, bookID, rowData.lineNumber);\r\n        mt.data.push({\r\n            extra: rowData.extra,\r\n            priority: rowData.priority,\r\n            C: rowData.C,\r\n            V: rowData.V,\r\n            lineNumber: rowData.lineNumber,\r\n            rowID: rowData.rowID,\r\n            charPos: rowData.characterIndex,\r\n            excerpt: rowData.extract,\r\n            link: _link,\r\n            location: _location,\r\n            message: rowData.message,\r\n            fieldName: rowData.fieldName,\r\n            details: rowData.details,\r\n        })\r\n    })\r\n\r\n    // @ts-ignore\r\n    mt.data = mt.data.sort((a: object, b: object) => (a.priority > b.priority ? -1 : 1) ); // sort highest priority to the top of the table\r\n\r\n    mt.columns = trimColumns(mt.data, mt.columns);\r\n\r\n    mt.options = {\r\n        sorting: true,\r\n        // padding: 'dense',\r\n        exportButton: true,\r\n        exportAllData: true,\r\n        // tableLayout: 'auto',\r\n        columnsButton: true,\r\n        filtering: true,\r\n        pageSize: 10,\r\n    };\r\n\r\n    return mt;\r\n};\r\n\r\n/*\r\n// function to convert an array of words to\r\n// an object suitable for MaterialTable\r\nexport const aw_to_mt = ( ar => {\r\n    // first convert array to object\r\n    const ob = array_to_obj(ar);\r\n    const mt = {};\r\n    mt.title = \"All Words in Text Order\";\r\n    mt.columns = [\r\n        { title: 'Order', field: 'order' , type: 'numeric'},\r\n        { title: 'Word', field: 'word' },\r\n    ];\r\n    mt.data = [];\r\n    Object.keys(ob).forEach ( n => {\r\n        mt.data.push({ order: n, word: ob[n] })\r\n    });\r\n\r\n    mt.options = { sorting: true };\r\n\r\n    return mt;\r\n});\r\n*/","import React from 'react';\r\nimport { forwardRef } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport { withStyles } from '@material-ui/core/styles';\r\n\r\nimport AddBox from '@material-ui/icons/AddBox';\r\nimport ArrowDownward from '@material-ui/icons/ArrowDownward';\r\nimport Check from '@material-ui/icons/Check';\r\nimport ChevronLeft from '@material-ui/icons/ChevronLeft';\r\nimport ChevronRight from '@material-ui/icons/ChevronRight';\r\nimport Clear from '@material-ui/icons/Clear';\r\nimport DeleteOutline from '@material-ui/icons/DeleteOutline';\r\nimport Edit from '@material-ui/icons/Edit';\r\nimport FilterList from '@material-ui/icons/FilterList';\r\nimport FirstPage from '@material-ui/icons/FirstPage';\r\nimport LastPage from '@material-ui/icons/LastPage';\r\nimport Remove from '@material-ui/icons/Remove';\r\nimport SaveAlt from '@material-ui/icons/SaveAlt';\r\nimport Search from '@material-ui/icons/Search';\r\nimport ViewColumn from '@material-ui/icons/ViewColumn';\r\n\r\nimport MaterialTable from 'material-table';\r\nimport * as util from './core/utilities.ts';\r\n\r\nconst tableIcons = {\r\n  Add: forwardRef((props, ref) => <AddBox {...props} ref={ref} />),\r\n  Check: forwardRef((props, ref) => <Check {...props} ref={ref} />),\r\n  Clear: forwardRef((props, ref) => <Clear {...props} ref={ref} />),\r\n  Delete: forwardRef((props, ref) => <DeleteOutline {...props} ref={ref} />),\r\n  DetailPanel: forwardRef((props, ref) => <ChevronRight {...props} ref={ref} />),\r\n  Edit: forwardRef((props, ref) => <Edit {...props} ref={ref} />),\r\n  Export: forwardRef((props, ref) => <SaveAlt {...props} ref={ref} />),\r\n  Filter: forwardRef((props, ref) => <FilterList {...props} ref={ref} />),\r\n  FirstPage: forwardRef((props, ref) => <FirstPage {...props} ref={ref} />),\r\n  LastPage: forwardRef((props, ref) => <LastPage {...props} ref={ref} />),\r\n  NextPage: forwardRef((props, ref) => <ChevronRight {...props} ref={ref} />),\r\n  PreviousPage: forwardRef((props, ref) => <ChevronLeft {...props} ref={ref} />),\r\n  ResetSearch: forwardRef((props, ref) => <Clear {...props} ref={ref} />),\r\n  Search: forwardRef((props, ref) => <Search {...props} ref={ref} />),\r\n  SortArrow: forwardRef((props, ref) => <ArrowDownward {...props} ref={ref} />),\r\n  ThirdStateCheck: forwardRef((props, ref) => <Remove {...props} ref={ref} />),\r\n  ViewColumn: forwardRef((props, ref) => <ViewColumn {...props} ref={ref} />)\r\n};\r\n\r\n/**\r\n * Colorized priority according to severity of notice\r\n * @param content\r\n * @return {JSX.Element|string}\r\n */\r\nexport const renderPriority = (content) => {\r\n  // breaking changes: 800 and above\r\n  if ( content >= 800 ) {\r\n      return <p style={{ color: 'red', fontWeight: 'bold' }}>{content}</p>;\r\n  }\r\n\r\n  // non-breaking changes: 600 to 799\r\n  if ( content >= 600 ) {\r\n    return <p style={{ color: 'blue', fontWeight: 'bold' }}>{content}</p>\r\n  }\r\n\r\n  // below 600 are warnings\r\n  return <p style={{ color: 'green', fontWeight: 'bold' }}>{content}</p>;\r\n}\r\n\r\n/**\r\n * creates a link to external URL\r\n * @param link\r\n * @param content\r\n * @return {JSX.Element|string}\r\n */\r\nexport const renderLink = (link, content) => {\r\n  if (link) {\r\n    return <a href={link} target=\"_blank\" rel=\"noopener noreferrer\">{content}</a>\r\n  } else if (content) {\r\n    return `${content}`\r\n  }\r\n  return \"\";\r\n}\r\n\r\n/**\r\n * replaces unicode references with link to webpage describing the character\r\n * @param content\r\n * @return {JSX.Element|string}\r\n */\r\nexport const renderWithUnicodeLink = (content) => {\r\n  if ( !content ) {\r\n    return \"\";\r\n  }\r\n  // find unicode refs that look like '( =D8288/H2060)'\r\n  const getUnicodeRegEx = new RegExp(/=D(\\d+)\\/H(\\w+)\\)/, 'g');\r\n  let match;\r\n  let lastPos = 0;\r\n  const output = [];\r\n  // eslint-disable-next-line no-cond-assign\r\n  while (match = getUnicodeRegEx.exec(content)) {\r\n    if (match.index > 0) {\r\n      output.push(content.substring(lastPos, match.index));\r\n    }\r\n    let matchLen = match[0].length;\r\n    const unicode = match[2];\r\n    output.push (\r\n      <a href={`http://www.fileformat.info/info/unicode/char/${unicode}/index.htm`} target=\"_blank\" rel=\"noopener noreferrer\">U+{unicode}</a>\r\n    )\r\n    lastPos = match.index + matchLen - 1; // update start position\r\n  }\r\n  if (lastPos < content.length) {\r\n    output.push(content.substring(lastPos, content.length));\r\n  }\r\n\r\n  // assemble all the strings and anchors into one segment\r\n  return <> {output} </>\r\n};\r\n\r\nfunction ValidationWarnings({\r\n    results,\r\n    username,\r\n    languageCode,\r\n    bookID,\r\n  }) {\r\n\r\n    let mt = util.notices_to_mt(results, username, languageCode, bookID, renderLink, renderWithUnicodeLink, renderPriority);\r\n    return (\r\n      <Paper>\r\n        <MaterialTable\r\n          icons={tableIcons}\r\n          title={mt.title}\r\n          columns={mt.columns}\r\n          data={mt.data}\r\n          options={mt.options}\r\n        />\r\n      </Paper>\r\n    );\r\n  };\r\n\r\n  ValidationWarnings.propTypes = {\r\n    /** @ignore */\r\n    results: PropTypes.array.isRequired,\r\n  };\r\n\r\n  const styles = theme => ({\r\n    root: {\r\n    },\r\n  });\r\n\r\n  export default withStyles(styles)(ValidationWarnings);\r\n\r\n","import React, { useState, useEffect } from 'react';\r\nimport { Typography } from '@material-ui/core';\r\n\r\nimport { checkBookPackage } from './core/book-package-check';\r\nimport ValidationNotices from './ValidationNotices';\r\nimport { fetchRepositoryZipFile, getFileCached, getFileListFromZip } from \"./core/getApi\";\r\n\r\nfunction BookPackageContentValidator({bookID, username, language_code}) {\r\n    //const username = 'unfoldingword';\r\n    //const language_code = 'en';\r\n    //const branch = 'master';\r\n    // Check a single Bible book across many repositories\r\n    const [result, setResultValue] = useState(\"Waiting-CheckBookPackage\");\r\n\r\n    const checkingOptions = {\r\n      getFile: getFileCached,\r\n      fetchRepositoryZipFile: fetchRepositoryZipFile,\r\n      getFilelistFromZip: getFileListFromZip,\r\n      taRepoUsername: username\r\n    };\r\n\r\n    useEffect(() => {\r\n        // Use an IIFE (Immediately Invoked Function Expression)\r\n        //  e.g., see https://medium.com/javascript-in-plain-english/https-medium-com-javascript-in-plain-english-stop-feeling-iffy-about-using-an-iife-7b0292aba174\r\n        (async () => {\r\n\r\n            // Display our \"waiting\" message\r\n            setResultValue(<p style={{ color: 'red' }}>Waiting for check results for {username} {language_code} <b>{bookID}</b> book package…</p>);\r\n\r\n            const rawCBPResults = await checkBookPackage(username, language_code, bookID, setResultValue, checkingOptions);\r\n            //console.log(\"rawCBPResults=\", rawCBPResults);\r\n            // Add some extra fields to our rawCBPResults object in case we need this information again later\r\n            rawCBPResults.checkType = 'BookPackage';\r\n            rawCBPResults.username = username;\r\n            rawCBPResults.language_code = language_code;\r\n            rawCBPResults.bookID = bookID;\r\n            rawCBPResults.checkedOptions = checkingOptions;\r\n\r\n            function renderSummary(rawCBPResults) {\r\n                return (\r\n                    <>\r\n                    <Typography>\r\n                        Successfully checked&nbsp;\r\n                        {rawCBPResults.checkedFileCount.toLocaleString()}&nbsp;\r\n                        files in&nbsp;\r\n                        {rawCBPResults.elapsedSeconds}&nbsp;\r\n                        seconds\r\n                    </Typography>\r\n                    <Typography>\r\n                        There were {rawCBPResults.noticeList.length} notices.\r\n                    </Typography>\r\n                </>\r\n            );\r\n            }\r\n\r\n            setResultValue(<>\r\n                {renderSummary(rawCBPResults)}\r\n                {rawCBPResults.noticeList.length ?\r\n                  <ValidationNotices\r\n                    results={rawCBPResults.noticeList}\r\n                    username={username}\r\n                    languageCode={language_code}\r\n                    bookID={bookID}\r\n                  />\r\n                : <br/> }\r\n            </>);\r\n\r\n        })(); // end of async part in unnamedFunction\r\n        // eslint-disable-next-line\r\n    }, []); // end of useEffect part\r\n\r\n    // {/* <div className={classes.root}> */}\r\n    return (\r\n        <div>\r\n        {result}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default BookPackageContentValidator;\r\n","import React from 'react';\nimport clsx from 'clsx';\n//import { withStyles, makeStyles, useTheme, Theme, createStyles } from '@material-ui/core/styles';\nimport { makeStyles, useTheme, Theme, createStyles } from '@material-ui/core/styles';\nimport Paper from '@material-ui/core/Paper';\nimport Stepper from '@material-ui/core/Stepper';\nimport Step from '@material-ui/core/Step';\nimport StepLabel from '@material-ui/core/StepLabel';\nimport Button from '@material-ui/core/Button';\nimport Typography from '@material-ui/core/Typography';\n//import CircularProgress from '@material-ui/core/CircularProgress';\n//import Popover from '@material-ui/core/Popover';\n\nimport FormLabel from '@material-ui/core/FormLabel';\nimport FormControl from '@material-ui/core/FormControl';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport FormHelperText from '@material-ui/core/FormHelperText';\n//import Checkbox, { CheckboxProps } from '@material-ui/core/Checkbox';\nimport Checkbox from '@material-ui/core/Checkbox';\n\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport IconButton from '@material-ui/core/IconButton';\nimport MenuIcon from '@material-ui/icons/Menu';\nimport Drawer from '@material-ui/core/Drawer';\nimport Divider from '@material-ui/core/Divider';\nimport ChevronLeftIcon from '@material-ui/icons/ChevronLeft';\nimport ChevronRightIcon from '@material-ui/icons/ChevronRight';\n\n\n//import { green } from '@material-ui/core/colors';\nimport * as books from '../src/core/books';\nimport { Container, CssBaseline, Grid, RadioGroup, Radio } from '@material-ui/core';\n\nimport BookPackageContentValidator from './BookPackageContentValidator';\nimport { clearCaches, PreLoadRepos } from './core/getApi';\n\nasync function doInitialization() {\n    //const username = 'unfoldingword';\n    //const language_code = 'en';\n    console.log(\"doInitialization()\");\n    const branch = 'master'\n    await clearCaches();\n    const success = await PreLoadRepos('unfoldingword', '', branch, [], true);\n    if (!success) {\n        console.log(`Failed to pre-load original language repos`)\n    }\n}\n\nasync function doLanguageInitialization(username: string,language_code: string) {\n    //const username = 'unfoldingword';\n    //const language_code = 'en';\n    console.log(\"doLanguageInitialization() username, lang:\", username, language_code);\n    const branch = 'master'\n    const success = await PreLoadRepos(username, language_code, branch, ['TA', 'TW', 'TN', 'TQ'], false, true);\n    if (!success) {\n        console.log(`Failed to pre-load all repos`)\n    }\n}\n\nconst drawerWidth = 240;\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      width: '100%',\n      flexGrow: 1,\n      display: 'flex',\n    },\n    menuButton: {\n      marginRight: theme.spacing(2),\n    },\n    appBar: {\n      transition: theme.transitions.create(['margin', 'width'], {\n        easing: theme.transitions.easing.sharp,\n        duration: theme.transitions.duration.leavingScreen,\n      }),\n    },\n    appBarShift: {\n      width: `calc(100% - ${drawerWidth}px)`,\n      marginLeft: drawerWidth,\n      transition: theme.transitions.create(['margin', 'width'], {\n        easing: theme.transitions.easing.easeOut,\n        duration: theme.transitions.duration.enteringScreen,\n      }),\n    },\n    title: {\n      flexGrow: 1,\n    },\n    formControl: {\n      margin: theme.spacing(3),\n    },\n    button: {\n      marginRight: theme.spacing(1),\n    },\n    instructions: {\n      marginTop: theme.spacing(1),\n      marginBottom: theme.spacing(1),\n    },\n    hide: {\n      display: 'none',\n    },\n    drawer: {\n      width: drawerWidth,\n      flexShrink: 0,\n    },\n    drawerPaper: {\n      width: drawerWidth,\n    },\n    drawerHeader: {\n      display: 'flex',\n      alignItems: 'center',\n      padding: theme.spacing(0, 1),\n      ...theme.mixins.toolbar,\n      justifyContent: 'flex-end',\n    },\n    content: {\n      flexGrow: 1,\n      padding: theme.spacing(3),\n      transition: theme.transitions.create('margin', {\n        easing: theme.transitions.easing.sharp,\n        duration: theme.transitions.duration.leavingScreen,\n      }),\n      marginLeft: -drawerWidth,\n    },\n    contentShift: {\n      transition: theme.transitions.create('margin', {\n        easing: theme.transitions.easing.easeOut,\n        duration: theme.transitions.duration.enteringScreen,\n      }),\n      marginLeft: 0,\n    },\n    alignItemsAndJustifyContent: {\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n    },\n    offset: {...theme.mixins.toolbar},\n  }),\n);\n\ninterface bpStateIF { [x: string]: boolean[]; };\n\nfunction joinBookIds(state: bpStateIF ): string[] {\n  const x = Object.keys(state);\n  let y: string[] = [];\n  for (let i=0; i<x.length; i++) {\n    if ( state[x[i]][0] ) {\n      y.push(books.bookIdByTitle(x[i]));\n    }\n  }\n  return y;\n}\n\n\nfunction getSteps() {\n  return ['Select Organization and Language', 'Select Books', 'Content Validation Details'];\n}\n\nfunction getStepContent(step: number) {\n  switch (step) {\n    case 0:\n      return 'Select Organization and Language';\n    case 1:\n      return 'Select books, then click Next to generate book package details';\n    case 2:\n      return 'Content Validation Results';\n    default:\n      return 'Unknown step';\n  }\n}\n\n// A custom hook that builds on useLocation to parse\n// the query string for you.\nlet queryProcessedOnce = false;\nfunction useQuery() {\n  let search = window.location.search;\n  //console.log(\"url=\",window.location.origin,window.location.pathname)\n  return new URLSearchParams(search);\n}\n\nexport default function App() {\n  const [state, setState] = React.useState({ ...books.titlesToBoolean() });\n  const [activeStep, setActiveStep] = React.useState(0);\n  const [skipped, setSkipped] = React.useState(new Set<number>());\n  const [org, setOrg]   = React.useState('unfoldingword');\n  const [lang, setLang] = React.useState('en');\n\n  /* ----------------------------------------------------------\n      Prefetch the orginal languages, which are in\n      org=unfoldingword and lang is ignored; since they are\n      in a fixed location.\n  */\n  //console.log(\"Prefetching Original Language Repos!\");\n  //clearCacheAndPreloadRepos('unfoldingword', 'en', ['rut','jud'], 'master', []);\n\n  /* ----------------------------------------------------------\n      Stepper\n  */\n  const steps = getSteps();\n\n  const isStepOptional = (step: number) => {\n    return false;\n  };\n\n  const isStepSkipped = (step: number) => {\n    return skipped.has(step);\n  };\n\n\n  const handleBack = () => {\n    setActiveStep(prevActiveStep => prevActiveStep - 1);\n  };\n\n  const handleSkip = () => {\n    if (!isStepOptional(activeStep)) {\n      // You probably want to guard against something like this,\n      // it should never occur unless someone's actively trying to break something.\n      throw new Error(\"You can't skip a step that isn't optional.\");\n    }\n\n    setActiveStep(prevActiveStep => prevActiveStep + 1);\n    setSkipped(prevSkipped => {\n      const newSkipped = new Set(prevSkipped.values());\n      newSkipped.add(activeStep);\n      return newSkipped;\n    });\n  };\n\n  const handleNext = () => {\n    let newSkipped = skipped;\n    if (isStepSkipped(activeStep)) {\n      newSkipped = new Set(newSkipped.values());\n      newSkipped.delete(activeStep);\n    }\n    if ( activeStep === 0 ) {\n      // time to preload cache!\n        doLanguageInitialization(org, lang);\n    }\n    setActiveStep(prevActiveStep => prevActiveStep + 1);\n    setSkipped(newSkipped);\n  };\n\n  let query = useQuery();\n  if ( activeStep === 0 && queryProcessedOnce === false ) {\n    doInitialization();\n    queryProcessedOnce = true;\n    let bks   = query.get(\"books\");\n    if ( bks !== null ) {\n      // user has launched the app with URL query parameters\n      let barrayIds = bks.split(',');\n      let barrayTitles: string[] = [];\n      for ( let i=0; i < barrayIds.length; i++ ) {\n        let x = books.bookTitleById(barrayIds[i]);\n        if ( x === \"\" ) {\n          alert(\"Invalid Book Id:\"+barrayIds[i]);\n          break;\n        }\n        barrayTitles.push(x);\n      }\n      for( let i=0; i < barrayTitles.length; i++) {\n        let name = barrayTitles[i];\n        console.log(\"name:\",name)\n        // set the state variables\n        state[name][0] = true;\n        state[name][1] = false;\n        let b: boolean[] = [];\n        b[0] = true;\n        b[1] = false;\n      }\n      handleNext();\n    }\n  }\n\n\n  const classes = useStyles();\n  const theme = useTheme();\n\n  /* ----------------------------------------------------------\n      Menu drawer\n  */\n  const [open, setOpen] = React.useState(false);\n\n  const handleDrawerOpen = () => {\n    setOpen(true);\n  };\n\n  const handleDrawerClose = () => {\n    setOpen(false);\n  };\n\n  const handleSelectNoneOt = () => {\n    let states = books.oldTestament();\n    for( let i=0; i < states.length; i++) {\n      state[states[i]][0] = false;\n      state[states[i]][1] = false;\n      let name = states[i];\n      let b: boolean[] = [];\n      b[0] = false;\n      b[1] = false;\n      setState({ ...state, [name]: b });\n    }\n  };\n\n  const handleSelectAllOt = () => {\n    let states = books.oldTestament();\n    for( let i=0; i < states.length; i++) {\n      state[states[i]][0] = true;\n      state[states[i]][1] = false;\n      let name = states[i];\n      let b: boolean[] = [];\n      b[0] = true;\n      b[1] = false;\n      setState({ ...state, [name]: b });\n    }\n  };\n\n  const handleSelectNoneNt = () => {\n    let states = books.newTestament();\n    for( let i=0; i < states.length; i++) {\n      state[states[i]][0] = false;\n      state[states[i]][1] = false;\n      let name = states[i];\n      let b: boolean[] = [];\n      b[0] = false;\n      b[1] = false;\n      setState({ ...state, [name]: b });\n    }\n  };\n\n  const handleSelectAllNt = () => {\n    let states = books.newTestament();\n    for( let i=0; i < states.length; i++) {\n      state[states[i]][0] = true;\n      state[states[i]][1] = false;\n      let name = states[i];\n      let b: boolean[] = [];\n      b[0] = true;\n      b[1] = false;\n      setState({ ...state, [name]: b });\n    }\n  };\n\n\n  /* ----------------------------------------------------------\n      Form/checkbox stuff\n  */\n  // these are for the initial book selection\n  const handleChange = (name: string) => (event: React.ChangeEvent<HTMLInputElement>) => {\n    let b: boolean[] = [];\n    b[0] = event.target.checked;\n    b[1] = false;\n    setState({ ...state, [name]: b });\n  };\n\n  /* as of 2020-09-21:\n  The languages/orgs are:\n    Russian (RU)/ru_gl\n    Hindi (HI)/translationCore-Create-BCS\n    Kannada (KN)/translationCore-Create-BCS\n    Latin-American Spanish (ES-419)/Es-419_gl\n  */\n  const handleOrgLangChange = () => (event: React.ChangeEvent<HTMLInputElement>) => {\n    let val = (event.target as HTMLInputElement).value;\n    let org  = 'unfoldingword';\n    let lang = 'en';\n    if ( val === 'ru' ) {\n      org  = 'ru_gl';\n      lang = 'ru';\n    } else if ( val === 'hi' ) {\n      org  = 'translationCore-Create-BCS';\n      lang = 'hi';\n    } else if ( val === 'kn' ) {\n      org  = 'translationCore-Create-BCS';\n      lang = 'kn';\n    } else if ( val === 'es-419' ) {\n      org = 'Es-419_gl';\n      lang = 'es-419';\n    }\n    setOrg(org);\n    setLang(lang);\n  };\n\n  return (\n    <div className={classes.root}>\n      <CssBaseline />\n      <AppBar position=\"fixed\"\n          className={clsx(classes.appBar, {[classes.appBarShift]: open })}>\n        <Toolbar>\n          <IconButton\n            color=\"inherit\"\n            aria-label=\"open drawer\"\n            onClick={handleDrawerOpen}\n            edge=\"start\"\n            className={clsx(classes.menuButton, open && classes.hide)}\n          >\n            <MenuIcon />\n          </IconButton>\n          <Typography variant=\"h6\" className={classes.title}>\n            Book Package Content Validation\n          </Typography>\n        </Toolbar>\n      </AppBar>\n      <Drawer\n        className={classes.drawer}\n        variant=\"persistent\"\n        anchor=\"left\"\n        open={open}\n        classes={{\n          paper: classes.drawerPaper,\n        }}\n      >\n        <div className={classes.drawerHeader}>\n          <IconButton onClick={handleDrawerClose}>\n            {theme.direction === 'ltr' ? <ChevronLeftIcon /> : <ChevronRightIcon />}\n          </IconButton>\n        </div>\n        <Divider />\n          <Typography>Nothing here to see!</Typography>\n        <Divider />\n      </Drawer>\n      <Paper>\n        <Typography> <br/> <br/> </Typography>\n        <Stepper activeStep={activeStep}>\n          {steps.map((label, index) => {\n            const stepProps: { completed?: boolean } = {};\n            const labelProps: { optional?: React.ReactNode } = {};\n            if (isStepOptional(index)) {\n              labelProps.optional = <Typography variant=\"caption\">Optional</Typography>;\n            }\n            if (isStepSkipped(index)) {\n              stepProps.completed = false;\n            }\n            return (\n              <Step key={label} {...stepProps}>\n                <StepLabel {...labelProps}>{label}</StepLabel>\n              </Step>\n            );\n          })}\n        </Stepper>\n        <Container>\n          <div className={classes.alignItemsAndJustifyContent}>\n          <Typography className={classes.instructions}>{getStepContent(activeStep)}</Typography>\n          </div>\n\n          <div className={classes.alignItemsAndJustifyContent}>\n            <Button disabled={activeStep === 0} onClick={handleBack} color=\"primary\" variant=\"contained\" className={classes.button}>\n              Back\n            </Button>\n\n            {isStepOptional(activeStep) && (\n              <Button variant=\"contained\" color=\"primary\" onClick={handleSkip} className={classes.button}>\n                Skip\n              </Button>\n            )}\n\n            <Button disabled={activeStep === 2} variant=\"contained\" color=\"primary\" onClick={handleNext} className={classes.button}>\n              Next\n            </Button>\n\n          </div>\n\n          <div className={classes.alignItemsAndJustifyContent}>\n\n          {(activeStep === 0) && (\n              <>\n              <div>\n                <Paper>\n                  <FormControl component=\"fieldset\">\n                    <FormLabel component=\"legend\">Languages</FormLabel>\n                    <RadioGroup aria-label=\"orgLang\" name=\"orgLang\" value={lang} onChange={handleOrgLangChange()}>\n                      <FormControlLabel value=\"en\" control={<Radio />} label=\"English (unfoldingWord)\" />\n                      <FormControlLabel value=\"ru\" control={<Radio />} label=\"Russian (ru_gl)\" />\n                      <FormControlLabel value=\"hi\" control={<Radio />} label=\"Hindi (translationCore-Create-BCS)\" />\n                      <FormControlLabel value=\"kn\" control={<Radio />} label=\"Kannada (translationCore-Create-BCS)\" />\n                      <FormControlLabel value=\"es-419\" control={<Radio />} label=\"Latin-American Spanish (Es-419_gl)\" />\n                    </RadioGroup>\n                  </FormControl>\n                </Paper>\n              </div>\n              </>\n            )}\n\n\n            {(activeStep === 1) && (\n              <Grid container spacing={3}>\n                <Grid item xs={6}>\n                  <Paper>\n                    <Typography> <br/> </Typography>\n                    <div>\n                    <Button onClick={handleSelectAllOt} color=\"primary\" variant=\"contained\" className={classes.button}>\n                      Select All\n                    </Button>\n                    <Button onClick={handleSelectNoneOt} color=\"primary\" variant=\"contained\" className={classes.button}>\n                      Select None\n                    </Button>\n                    </div>\n                    <FormControl required component=\"fieldset\" className={classes.formControl}>\n                    <FormLabel component=\"legend\">Old Testament</FormLabel>\n                    <FormGroup>\n                      {books.oldTestament().map(t =>\n                        <FormControlLabel\n                          control={<Checkbox checked={state[t][0]} onChange={handleChange(t)} value={t} />}\n                          label={t} key={t}\n                        />\n                      )}\n                    </FormGroup>\n                    <FormHelperText />\n                    </FormControl>\n                  </Paper>\n                </Grid>\n                <Grid item xs={6}>\n                  <Paper>\n                    <Typography> <br/> </Typography>\n                    <div>\n                    <Button onClick={handleSelectAllNt} color=\"primary\" variant=\"contained\" className={classes.button}>\n                      Select All\n                    </Button>\n                    <Button onClick={handleSelectNoneNt} color=\"primary\" variant=\"contained\" className={classes.button}>\n                      Select None\n                    </Button>\n                    </div>\n\n                    <FormControl required component=\"fieldset\" className={classes.formControl}>\n                    <FormLabel component=\"legend\">New Testament</FormLabel>\n                    <FormGroup>\n                      {books.newTestament().map(t =>\n                        <FormControlLabel\n                          control={<Checkbox checked={state[t][0]} onChange={handleChange(t)} value={t} />}\n                          label={t} key={t}\n                        />\n                      )}\n                    </FormGroup>\n                    <FormHelperText />\n                    </FormControl>\n                  </Paper>\n                </Grid>\n              </Grid>\n            )}\n\n\n            {(activeStep === 2) && (\n              <>\n              <div>\n                <Paper>\n                {\n                  joinBookIds(state).map(id =>\n                    <div>\n                    <Typography variant=\"h6\" >Book Package for {books.bookTitleById(id)} </Typography>\n                    <BookPackageContentValidator bookID={id} key={id} username={org} language_code={lang} />\n                    </div>\n                  )\n                }\n                </Paper>\n              </div>\n              </>\n            )}\n\n\n          </div>\n        </Container>\n      </Paper>\n    </div>\n  );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport './fonts/SILEOTSR.ttf';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}